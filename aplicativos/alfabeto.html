<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprenda a Desenhar!</title>
    <style>
        /* --- ESTILOS CSS GERAIS (INLINE) --- */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f8ff; /* Azul clarinho */
            font-family: 'Comic Sans MS', cursive, sans-serif; /* Fonte divertida */
            color: #333;
            overflow-x: hidden; /* Evita barra de rolagem horizontal */
            padding: 10px; /* Adiciona um pouco de padding nas bordas para telas pequenas */
            box-sizing: border-box; /* Garante que padding não adicione largura extra */
        }

        .main-area {
            display: flex;
            align-items: flex-start; /* Alinha o canvas e a paleta no topo */
            margin-bottom: 15px;
            flex-wrap: nowrap; /* Impede quebra de linha por padrão */
        }

        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
            margin-bottom: 0; /* Remove margem inferior para alinhar com a paleta */
            position: relative;
            margin-right: 20px; /* Espaço entre o canvas e a paleta */
            width: 440px; /* Largura base para o container */
            max-width: 90%; /* Limita para telas menores */
            box-sizing: border-box;
        }

        h1 {
            color: #ff6347; /* Vermelho tomate */
            margin-bottom: 20px;
            font-size: 2em; /* Tamanho da fonte para telas grandes */
        }

        canvas {
            border: 2px dashed #00bfff; /* Borda tracejada azul claro */
            background-color: #e0ffff; /* Ciano clarinho para o fundo do canvas */
            touch-action: none; /* Previne scroll acidental em dispositivos touch */
            cursor: crosshair; /* Cursor de mira para desenho */
            width: 400px; /* Garante largura fixa no desktop */
            height: 400px; /* Garante altura fixa no desktop */
            max-width: 100%; /* Permite que o canvas encolha */
            height: auto; /* Permite que a altura se ajuste proporcionalmente */
            display: block; /* Remove espaço extra abaixo do canvas */
            margin: 0 auto; /* Centraliza o canvas dentro do container */
        }

        .category-selector, .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 80%;
            max-width: 620px; /* Ajusta largura máxima para o layout lado a lado */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px; /* Espaçamento entre os blocos de controle */
            box-sizing: border-box;
        }

        .controls {
            flex-direction: row; /* Organiza os botões em linha */
            align-items: center;
            justify-content: center; /* Centraliza os botões */
        }

        .character-buttons-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px; /* Espaçamento entre a linha de botões e o botão Aleatório */
            width: 100%; /* Ocupa largura total */
        }

        .color-palette {
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
            display: flex;
            flex-direction: column; /* Organiza as opções de cor verticalmente */
            align-items: center; /* Centraliza os itens horizontalmente */
            gap: 10px;
            margin-top: 0; /* Alinha com o topo do canvas */
            width: 100px; /* Largura definida para a paleta no desktop */
            flex-shrink: 0; /* Evita que a paleta encolha */
            box-sizing: border-box;
        }

        .color-palette > span {
            margin-bottom: 5px;
            white-space: nowrap; /* Evita quebra de linha do texto "Cor do Lápis" */
            font-size: 1.1em;
        }

        .color-swatches {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }

        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.1s ease, border-color 0.2s ease;
        }

        .color-box:hover {
            transform: scale(1.1);
        }

        .color-box.active {
            border-color: #4682b4;
            box-shadow: 0 0 0 3px rgba(70, 130, 180, 0.5);
        }

        button, select { /* Estilos também para o select */
            background-color: #32cd32;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            flex-shrink: 0;
            -webkit-appearance: none; /* Remove estilo padrão do navegador para select */
            -moz-appearance: none;
            appearance: none;
            text-align-last: center; /* Centraliza texto no select */
        }

        button:hover, select:hover {
            background-color: #228b22;
            transform: translateY(-2px);
        }

        button.active {
            background-color: #1e90ff;
            box-shadow: 0 0 0 3px #00bfff;
        }

        #clearButton {
            background-color: #ff6347;
            margin-left: 10px; /* Espaço entre os botões */
        }

        #clearButton:hover {
            background-color: #cd5c5c;
        }

        #randomButton {
            background-color: #8A2BE2; /* Azul violeta */
        }

        #randomButton:hover {
            background-color: #6A1EAC; /* Um tom mais escuro */
        }

        p {
            margin-top: 15px;
            font-size: 1.1em;
            color: #555;
            text-align: center;
            width: 100%; /* Para que o parágrafo ocupe toda a largura do container */
        }

        /* --- MEDIA QUERIES PARA RESPONSIVIDADE --- */

        /* Para Tablets (e telas um pouco menores que desktop) */
        @media (max-width: 768px) {
            .main-area {
                flex-direction: column; /* Empilha o canvas e a paleta */
                align-items: center; /* Centraliza no modo coluna */
            }

            .container {
                margin-right: 0; /* Remove o espaçamento lateral */
                margin-bottom: 20px; /* Adiciona espaçamento inferior quando empilhado */
                max-width: 95%; /* Ocupa mais largura em tablets */
                width: auto; /* Deixa a largura automática para se ajustar ao max-width */
            }

            .color-palette {
                width: 95%; /* Ocupa quase toda a largura em tablets */
                flex-direction: row; /* Cores em linha para tablets */
                flex-wrap: wrap; /* Permite que as cores quebrem a linha */
                justify-content: center;
                margin-top: 0; /* Ajusta o margin-top */
            }

            .color-palette > span {
                width: 100%; /* Faz o texto ocupar a largura total antes das caixas de cor */
                text-align: center;
            }

            .color-swatches {
                width: 100%;
                justify-content: center;
            }

            h1 {
                font-size: 1.8em;
            }

            button, select {
                font-size: 1em;
                padding: 8px 12px;
            }

            .category-selector, .controls {
                max-width: 95%; /* Ajusta a largura máxima para tablets */
                padding: 12px;
            }
        }

        /* Para Celulares (e telas menores) */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                padding: 15px;
                margin-bottom: 15px;
                max-width: 100%; /* Permite que ocupe toda a largura disponível */
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            canvas {
                width: 100%; /* Canvas ocupa a largura total */
                height: 300px; /* Altura fixa para celular ou ajuste com 'auto' */
            }

            .color-palette {
                padding: 10px;
                width: 100%; /* Paleta ocupa a largura total */
                flex-direction: row; /* Mantém as cores em linha */
                justify-content: center;
            }

            .color-palette > span {
                font-size: 1em;
                margin-bottom: 8px;
            }

            .color-box {
                width: 25px;
                height: 25px;
            }

            button, select {
                font-size: 0.9em;
                padding: 7px 10px;
                width: calc(50% - 10px); /* Botões ocupam metade da largura com espaçamento */
                box-sizing: border-box;
            }

            #clearButton {
                margin-left: 0; /* Remove margem extra entre os botões para celular */
            }

            .category-selector, .controls {
                padding: 10px;
                max-width: 100%;
            }

            .character-buttons-row {
                flex-direction: row; /* Mantém os botões de caracteres em linha, quebrando se necessário */
                justify-content: center;
                gap: 5px; /* Reduz o espaçamento entre os botões de caractere */
            }
            .character-buttons-row button {
                width: auto; /* Deixa o botão se ajustar ao conteúdo */
                padding: 5px 8px; /* Reduz o padding dos botões de caractere */
                font-size: 0.85em; /* Reduz o tamanho da fonte */
            }
        }
    </style>
</head>
<body>
    <div class="main-area">
        <div class="container">
            <h1 id="currentTitle">Vamos desenhar! ✍️</h1>
            <canvas id="drawingCanvas"></canvas>
            <br>
            <button id="randomButton">Próximo! 🎲</button>
             <button id="clearButton">Limpar 🔄</button>
            <p>Passe o dedo ou o mouse sobre o desenho tracejado! ✨</p>
        </div>
        <div class="color-palette">
            <span>Cor do Lápis:</span>
            <div class="color-swatches">
                </div>
            </div>
    </div>

    <div class="category-selector">
        <label for="categorySelect">Escolha a Categoria:</label>
        <select id="categorySelect">
            <option value="letras">Letras</option>
            <option value="numeros">Números</option>
            <option value="musicais">Figuras Musicais</option>
        </select>
    </div>

    <div class="controls">
        <div class="character-buttons-row">
            </div>

    </div>

    <script>
        // --- CÓDIGO JAVASCRIPT (INLINE) ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            const clearButton = document.getElementById('clearButton');
            const characterButtonsRow = document.querySelector('.character-buttons-row');
            const colorPaletteSwatches = document.querySelector('.color-swatches');
            const currentTitle = document.getElementById('currentTitle');
            const categorySelect = document.getElementById('categorySelect');
            const randomButton = document.getElementById('randomButton');

            // Configurações do Canvas (definidas no CSS, mas bom ter aqui para o JS se precisar)
            // OBS: As larguras e alturas do canvas agora são gerenciadas primariamente pelo CSS para responsividade,
            // mas mantemos os valores fixos aqui para o contexto de desenho do ctx.
            canvas.width = 400;
            canvas.height = 400;

            let isDrawing = false;
            let currentCategory = 'letras'; // Categoria inicial
            let currentCharacter = 'A'; // Caractere inicial
            let currentColor = '#4682b4'; // Cor inicial do lápis (azul aço)

            // --- Configurações de Desenho da Criança ---
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';

            // --- Dicionário de Caracteres por Categoria ---
            const charactersByCategory = {
                letras: [
                    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
                    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
                ],
                numeros: [
                    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
                ],
                musicais: [
                    'Pentagrama', 'Clave de Sol', 'Clave de Fá', 'Fermata', 'Semínima', 'Mínima', 'Colcheia', 'Semibreve', 'Ritornelo', 'Barra Simples', 'Barra Final'
                ]
            };

            // --- Cores disponíveis para o lápis ---
            const colors = [
                '#FF0000', '#008000', '#0000FF', '#FFFF00', '#FFA500',
                '#800080', '#FFC0CB', '#000000', '#FFFFFF'
            ];

            // --- Função para desenhar o Caractere Tracejado ---
            function drawDashedCharacter(char) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

                ctx.save();
                ctx.strokeStyle = '#a9a9a9'; // Cor dos traços (cinza escuro)
                ctx.lineWidth = 5;
                ctx.setLineDash([10, 10]);

                const cx = canvas.width / 2;
                const cy = canvas.height / 2; // Centraliza verticalmente

                // Lógica de desenho para caracteres e figuras musicais
                switch (char) {
                    // --- Letras ---
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'S':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'X':
                    case 'Y':
                    case 'Z':
                        ctx.font = 'bold 300px "Comic Sans MS", cursive, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeText(char, cx, cy + 20); // Ajuste fino para letras/números
                        break;
                    // --- Números ---
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        ctx.font = 'bold 300px "Comic Sans MS", cursive, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeText(char, cx, cy + 20); // Ajuste fino para letras/números
                        break;
                    // --- Figuras Musicais ---
                    case 'Pentagrama':
                        // As 5 linhas do pentagrama
                        const lineSpacing = 30; // Espaçamento entre as linhas
                        const startY = cy - (lineSpacing * 2); // Linha superior
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            ctx.moveTo(cx - 150, startY + (i * lineSpacing));
                            ctx.lineTo(cx + 150, startY + (i * lineSpacing));
                        }
                        ctx.stroke();
                        break;
                    case 'Clave de Sol':
                        ctx.beginPath();
                        // Roda da clave (ponto de partida da nota Sol)
                        ctx.arc(cx - 10, cy + 50, 20, 0, Math.PI * 2);
                        ctx.moveTo(cx - 10, cy + 30); // Ponto para iniciar a haste

                        // Haste principal
                        ctx.lineTo(cx - 10, cy - 80);

                        // Curva superior
                        ctx.bezierCurveTo(cx + 60, cy - 80, cx + 50, cy - 10, cx - 10, cy);

                        // Curva inferior para o centro
                        ctx.bezierCurveTo(cx - 40, cy + 10, cx - 40, cy + 40, cx - 10, cy + 40);

                        // Ponto final da "espiral"
                        ctx.bezierCurveTo(cx, cy - 90, cx + 30, cy - 90, cx + 20, cy - 50);

                        ctx.stroke();
                        break;
                    case 'Clave de Fá':
                        ctx.beginPath();
                        // Corpo principal da clave de fá
                        ctx.moveTo(cx + 60, cy - 60);
                        ctx.bezierCurveTo(cx - 50, cy - 70, cx - 50, cy + 70, cx + 60, cy + 60);
                        ctx.lineTo(cx + 60, cy - 60); // Fecha o formato

                        // Haste vertical
                        ctx.moveTo(cx, cy - 80);
                        ctx.lineTo(cx, cy + 80);

                        // Dois pontos
                        const dotRadius = 8;
                        ctx.arc(cx + 20 + dotRadius * 2, cy - 20, dotRadius, 0, Math.PI * 2); // Ponto superior
                        ctx.arc(cx + 20 + dotRadius * 2, cy + 20, dotRadius, 0, Math.PI * 2); // Ponto inferior
                        ctx.fill(); // Preenche os pontos
                        ctx.stroke(); // Desenha os pontos e o corpo principal
                        break;
                    case 'Fermata':
                        ctx.beginPath();
                        ctx.arc(cx, cy - 50, 40, 0, Math.PI, false); // Arco superior
                        ctx.moveTo(cx, cy - 10);
                        ctx.lineTo(cx, cy + 30); // Ponto abaixo
                        ctx.stroke();
                        break;
                    case 'Semínima':
                        // Cabeça da nota (preenchida) - para tracejado, desenhamos o contorno
                        ctx.beginPath();
                        ctx.ellipse(cx - 30, cy + 30, 20, 15, Math.PI / 6, 0, Math.PI * 2);
                        ctx.stroke(); // Contorno da cabeça
                        // Haste
                        ctx.beginPath();
                        ctx.moveTo(cx - 10, cy + 20);
                        ctx.lineTo(cx - 10, cy - 80);
                        ctx.stroke();
                        break;
                    case 'Mínima':
                        // Cabeça da nota (oca)
                        ctx.beginPath();
                        ctx.ellipse(cx - 30, cy + 30, 20, 15, Math.PI / 6, 0, Math.PI * 2);
                        ctx.stroke(); // Contorno da cabeça
                        // Haste
                        ctx.beginPath();
                        ctx.moveTo(cx - 10, cy + 20);
                        ctx.lineTo(cx - 10, cy - 80);
                        ctx.stroke();
                        break;
                    case 'Colcheia':
                         // Cabeça (preenchida para tracejado, contorno)
                        ctx.beginPath();
                        ctx.ellipse(cx - 30, cy + 30, 20, 15, Math.PI / 6, 0, Math.PI * 2);
                        ctx.stroke();
                        // Haste
                        ctx.beginPath();
                        ctx.moveTo(cx - 10, cy + 20);
                        ctx.lineTo(cx - 10, cy - 80);
                        ctx.stroke();
                        // Bandeira/colchete
                        ctx.beginPath();
                        ctx.moveTo(cx - 10, cy - 80);
                        ctx.bezierCurveTo(cx + 30, cy - 80, cx + 30, cy - 40, cx - 10, cy - 40);
                        ctx.stroke();
                        break;
                    case 'Semibreve':
                        // Cabeça da nota (oca e maior que mínima/semínima)
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, 60, 40, Math.PI / 6, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'Ritornelo':
                        // Duas barras verticais e dois pontos
                        const ritorneloX = cx - 50;
                        const ritorneloY = cy - 80;
                        ctx.lineWidth = 5; // Barra mais grossa
                        ctx.beginPath();
                        ctx.moveTo(ritorneloX, ritorneloY);
                        ctx.lineTo(ritorneloX, ritorneloY + 160); // Primeira barra

                        ctx.moveTo(ritorneloX + 15, ritorneloY);
                        ctx.lineTo(ritorneloX + 15, ritorneloY + 160); // Segunda barra (mais fina)
                        ctx.lineWidth = 2; // Restaura espessura para a segunda barra se quiser diferença
                        ctx.stroke();

                        // Pontos
                        ctx.beginPath();
                        ctx.arc(ritorneloX + 30, cy - 30, 8, 0, Math.PI * 2); // Ponto superior
                        ctx.arc(ritorneloX + 30, cy + 30, 8, 0, Math.PI * 2); // Ponto inferior
                        ctx.fill(); // Preenche os pontos
                        ctx.stroke();
                        break;
                    case 'Barra Simples':
                        ctx.beginPath();
                        ctx.moveTo(cx, cy - 80);
                        ctx.lineTo(cx, cy + 80);
                        ctx.stroke();
                        break;
                    case 'Barra Final':
                        ctx.beginPath();
                        ctx.lineWidth = 5; // Primeira barra mais grossa
                        ctx.moveTo(cx - 10, cy - 80);
                        ctx.lineTo(cx - 10, cy + 80);
                        ctx.stroke();

                        ctx.lineWidth = 2; // Segunda barra mais fina
                        ctx.moveTo(cx + 10, cy - 80);
                        ctx.lineTo(cx + 10, cy + 80);
                        ctx.stroke();
                        break;
                    default:
                        ctx.font = 'bold 150px "Comic Sans MS", cursive, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.strokeText('?', cx, cy); // Caractere padrão para não definido
                        break;
                }
                ctx.restore();
            }

            // --- Funções para obter a posição do mouse/toque ---
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function getTouchPos(e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }

            // --- Eventos de Desenho ---
            function startDrawing(e) {
                isDrawing = true;
                const pos = e.touches ? getTouchPos(e) : getMousePos(e);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.strokeStyle = currentColor;
            }

            function draw(e) {
                if (!isDrawing) return;
                const pos = e.touches ? getTouchPos(e) : getMousePos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            }

            function stopDrawing() {
                isDrawing = false;
            }

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); });
            canvas.addEventListener('touchend', stopDrawing);

            // --- Botão de Limpar ---
            clearButton.addEventListener('click', () => {
                drawDashedCharacter(currentCharacter);
            });

            // --- Geração Dinâmica dos Botões de Caracteres (por Categoria) ---
            function createCharacterButtons(category) {
                characterButtonsRow.innerHTML = ''; // Limpa os botões existentes
                const charsToDisplay = charactersByCategory[category];
                charsToDisplay.forEach(char => {
                    const button = document.createElement('button');
                    button.textContent = char;
                    button.classList.add('char-button');
                    // Define o primeiro caractere da nova categoria como ativo por padrão
                    if (!currentCharacter || (charsToDisplay.includes(currentCharacter) && char === currentCharacter) || (charsToDisplay[0] === char && !charsToDisplay.includes(currentCharacter))) {
                        button.classList.add('active');
                        currentCharacter = char; // Define o caractere atual
                        currentTitle.textContent = `Vamos desenhar ${char}! ✍️`;
                        drawDashedCharacter(char);
                    }
                    button.addEventListener('click', () => {
                        currentCharacter = char;
                        currentTitle.textContent = `Vamos desenhar ${char}! ✍️`;
                        drawDashedCharacter(char);
                        document.querySelectorAll('.char-button').forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                    });
                    characterButtonsRow.appendChild(button);
                });
                // Se a categoria mudar e o caractere anterior não existir na nova categoria, define o primeiro da nova.
                if (!charsToDisplay.includes(currentCharacter)) {
                    currentCharacter = charsToDisplay[0];
                    currentTitle.textContent = `Vamos desenhar ${currentCharacter}! ✍️`;
                    drawDashedCharacter(currentCharacter);
                    const firstButton = characterButtonsRow.querySelector('.char-button');
                    if(firstButton) firstButton.classList.add('active');
                }
            }

            // --- Geração Dinâmica da Paleta de Cores ---
            function createColorPalette() {
                colors.forEach(color => {
                    const colorBox = document.createElement('div');
                    colorBox.classList.add('color-box');
                    colorBox.style.backgroundColor = color;
                    if (color === currentColor) {
                        colorBox.classList.add('active');
                    }
                    colorBox.addEventListener('click', () => {
                        currentColor = color;
                        document.querySelectorAll('.color-box').forEach(box => box.classList.remove('active'));
                        colorBox.classList.add('active');
                    });
                    colorPaletteSwatches.appendChild(colorBox);
                });
            }

            // --- Evento do Seletor de Categoria ---
            categorySelect.addEventListener('change', (event) => {
                currentCategory = event.target.value;
                createCharacterButtons(currentCategory); // Recria os botões com base na nova categoria
            });

            // --- Evento do Botão Aleatório ---
            randomButton.addEventListener('click', () => {
                const charsInCurrentCategory = charactersByCategory[currentCategory];
                const randomIndex = Math.floor(Math.random() * charsInCurrentCategory.length);
                const randomChar = charsInCurrentCategory[randomIndex];

                currentCharacter = randomChar;
                currentTitle.textContent = `Vamos desenhar ${randomChar}! ✍️`;
                drawDashedCharacter(randomChar);

                // Desativa o botão ativo anterior e ativa o novo (se existir um botão para ele)
                document.querySelectorAll('.char-button').forEach(btn => btn.classList.remove('active'));
                const newActiveButton = Array.from(characterButtonsRow.children).find(btn => btn.textContent === randomChar);
                if (newActiveButton) {
                    newActiveButton.classList.add('active');
                }
            });

            // --- Inicialização ---
            createCharacterButtons(currentCategory); // Cria os botões da categoria inicial
            createColorPalette(); // Cria a paleta de cores
        });
        
    </script>
</body>
</html>