

<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Editor_Harmonia - M√£o Esquerda</title>

<script src="abcjs-basic-min.js"></script>
<script src="abcjs_plugin.min.js"></script>

<style>
/* ESTILOS EXISTENTES (mantenha todos) */
body{font-family:Arial;background:#f4f4f9;padding:20px}
.container{max-width:1300px;margin:auto;background:#fff;padding:20px;border-radius:8px;box-shadow: 0 4px 12px rgba(0,0,0,0.1);}
h2, h3, h4 { color: #333; border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 20px;}
.row{display:flex;gap:15px;margin-bottom:15px; flex-wrap: wrap;}
.box{flex:1;display:flex;flex-direction:column; min-width: 150px;}
label{font-weight:bold; color: #555; margin-bottom: 4px;}
input,select,textarea{padding:10px;font-size:15px; border: 1px solid #ccc; border-radius: 4px;}
button{padding:10px 14px;font-weight:bold;border:none;border-radius:4px;cursor:pointer; transition: background 0.3s;}
button.accent{background:#28a745;color:#fff}
button.accent:hover{background:#218838;}
button.secondary{background:#6c757d;color:#fff}
button.secondary:hover{background:#5a6268;}
button.danger{background:#dc3545;color:#fff}
button.danger:hover{background:#c82333;}
button.info{background:#17a2b8;color:#fff}
button.info:hover{background:#138496;}
.toolbar{display:flex;gap:10px;margin:10px 0; flex-wrap: wrap;}
#paper,#paperEdit,#paperLeftHand{border:1px solid #ddd;padding:15px;margin-top:10px; background: #f9f9f9; min-height: 50px; border-radius: 4px; overflow-x: auto;}
#output, #outputLeftHand { height: 50px; background: #eee; font-size: 14px; }
textarea{width:100%;font-family:monospace; margin-top: 5px;}
hr { margin: 25px 0; border: 0; border-top: 1px solid #eee; }
.chord-library {display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin: 15px 0;}
.chord-item {background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; text-align: center;}
.chord-abc {font-family: monospace; font-size: 12px; color: #495057;}
.chord-name {font-weight: bold; margin-bottom: 5px; color: #212529;}
.chord-controls {display: flex; gap: 5px; justify-content: center; margin-top: 5px;}
.chord-controls button {padding: 3px 8px; font-size: 12px;}
.status-bar {background: #e9ecef; padding: 10px; border-radius: 4px; margin: 10px 0; display: flex; justify-content: space-between; align-items: center;}
.measures-control {display: flex; align-items: center; gap: 10px;}
.auto-bar-toggle {display: flex; align-items: center; gap: 5px;}
.toggle-switch {position: relative; display: inline-block; width: 50px; height: 24px;}
.toggle-switch input {opacity: 0; width: 0; height: 0;}
.toggle-slider {position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px;}
.toggle-slider:before {position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%;}
input:checked + .toggle-slider {background-color: #28a745;}
input:checked + .toggle-slider:before {transform: translateX(26px);}
.import-export {background: #e7f3ff; padding: 15px; border-radius: 4px; margin: 10px 0;}
.import-export textarea {height: 100px; font-size: 12px;}
.measure-info {font-weight: bold; color: #495057; background: #fff; padding: 5px 10px; border-radius: 4px; border: 1px solid #dee2e6;}
.measure-highlight {background: #fff3cd; padding: 2px 5px; border-radius: 3px;}

/* NOVOS ESTILOS PARA M√ÉO ESQUERDA */
.left-hand-section {background: #f0f8ff; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #4a90e2;}
.hand-selector {display: flex; gap: 10px; margin-bottom: 15px;}
.hand-btn {padding: 8px 15px; border: 2px solid #dee2e6; background: white; border-radius: 5px; cursor: pointer;}
.hand-btn.active {background: #4a90e2; color: white; border-color: #4a90e2;}
.position-selector {display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0;}
.position-btn {padding: 6px 12px; background: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer;}
.position-btn.active {background: #17a2b8; color: white; border-color: #138496;}

/* NOVOS ESTILOS PARA PRESETS */
.presets-section {background: #f9f0ff; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #9c27b0; transition: all 0.3s ease;}
.presets-header {display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;}
.presets-header h3 {margin: 0; border-bottom: none;}
.presets-toggle-btn {background: #9c27b0; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;}
.presets-toggle-btn:hover {background: #7b1fa2;}
.presets-toggle-btn.collapsed .toggle-icon {transform: rotate(-90deg);}
.toggle-icon {transition: transform 0.3s ease;}
.presets-content {overflow: hidden; transition: all 0.3s ease;}
.presets-content.collapsed {max-height: 0; opacity: 0; margin: 0; padding: 0;}
.presets-grid {display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; margin-top: 10px;}
.preset-item {background: white; border: 1px solid #e1bee7; border-radius: 6px; padding: 12px; cursor: pointer; transition: all 0.2s;}
.preset-item:hover {background: #f3e5f5; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1);}
.preset-title {font-weight: bold; color: #7b1fa2; margin-bottom: 5px; font-size: 14px;}
.preset-description {font-size: 12px; color: #666; margin-bottom: 8px;}
.preset-chords {font-family: monospace; font-size: 11px; background: #f5f5f5; padding: 5px; border-radius: 3px; color: #333; max-height: 60px; overflow-y: auto;}
.preset-controls {display: flex; gap: 5px; margin-top: 8px;}
.preset-controls button {padding: 3px 8px; font-size: 11px; flex: 1;}
</style>
</head>

<body>
<div class="container">

<h2>üéπ Editor_NB3 ‚Äì Gerador de Acordes (M√£o Direita & Esquerda)</h2>

<!-- Seletor de M√£o -->
<div class="hand-selector">
  <button class="hand-btn active" onclick="switchHand('right')">üéπ M√£o Direita (Solo)</button>
  <button class="hand-btn" onclick="switchHand('left')">üéπ M√£o Esquerda (Acompanhamento)</button>
</div>

<!-- Status Bar com Contador de Compassos -->
<div class="status-bar">
  <div class="measures-control">
    <label>Compasso:</label>
    <select id="timeSignature" onchange="updateTimeSignature()">
      <option value="4/4" selected>4/4</option>
      <option value="3/4">3/4</option>
      <option value="6/8">6/8</option>
      <option value="2/4">2/4</option>
    </select>
    <div class="auto-bar-toggle">
      <label>Barra Autom√°tica:</label>
      <label class="toggle-switch">
        <input type="checkbox" id="autoBarToggle" checked>
        <span class="toggle-slider"></span>
      </label>
    </div>
  </div>
  <div id="measureCounter" class="measure-info">Compasso: 1 | 0/4 tempos</div>
</div>

<!-- SE√á√ÉO M√ÉO DIREITA (EXISTENTE) -->
<div id="rightHandSection">
  <h3>üéπ M√£o Direita - Acordes de Solo</h3>
  
  <!-- √Årea de Gera√ß√£o de Acordes -->
  <div class="row">
    <div class="box">
      <label>Cifra Base (Ex.: C, F#, Gm)</label>
      <input id="root" placeholder="C, F#, Bb" value="C">
    </div>
    <div class="box">
      <label>Qualidade (Ex.: m, m7, 7, ¬∞)</label>
      <input id="quality" placeholder="m, m7, 7, ¬∞" value="">
    </div>
    <div class="box">
      <label>Figura (Dura√ß√£o)</label>
      <select id="figure">
        <option value="4" selected>Semibreve</option>
        <option value="2">M√≠nima</option>
        <option value="3">M√≠nima Pontuada</option>
        <option value="">Sem√≠nima</option>
        <option value="3/">Sem√≠nima Pontuada</option> 
        <option value="/">Colcheia</option>
        <option value="3//">Colcheia Pontuada</option>
      </select>
    </div>
    <div class="box">
      <label>Invers√£o</label>
      <select id="inversion">
        <option value="0">Fundamental</option>
        <option value="1">1¬™ invers√£o</option>
        <option value="2">2¬™ invers√£o</option>
        <option value="3">3¬™ invers√£o</option>
      </select>
    </div>
  </div>

  <div class="row">
    <div class="box">
      <label>Oitava</label>
      <select id="octaveShift">
        <option value="0" selected>Original</option>
        <option value="1">Subir +1 oitava</option>
        <option value="2">Subir +2 oitavas</option>
        <option value="-1">Descer -1 oitava</option>
        <option value="-2">Descer -2 oitavas</option>
      </select>
    </div>
  </div>

  <!-- Bot√µes de Controle M√£o Direita -->

<div class="toolbar">
  <button class="accent" onclick="generate()">Gerar Acorde (M√£o Direita)</button>
  <button class="info" onclick="generateAllInversions()">Gerar Todas Invers√µes</button>
  <!-- NOVO: Bot√£o para gerar sem cifra -->
  <button class="secondary" onclick="generateWithoutSymbol()">Gerar Sem Cifra</button>
  <button class="secondary" onclick="appendToEditor()">‚ûï Inserir no Editor</button>
  <!-- NOVO: Bot√£o para remover √∫ltimo acorde -->
  <button class="info" onclick="saveRightHandToLibrary()">üíæ Salvar na Biblioteca</button>
</div>
  <label>Trecho Gerado (M√£o Direita):</label>
  <textarea id="output"></textarea>
  <div id="paper"></div>
</div>

<!-- SE√á√ÉO M√ÉO ESQUERDA (NOVA) -->
<div id="leftHandSection" class="left-hand-section" style="display: none;">
  <h3>üéπ M√£o Esquerda - Acordes de Acompanhamento</h3>
  
  <!-- Seletor de Posi√ß√£o para M√£o Esquerda -->
  <div>
    <label>Posi√ß√£o da M√£o Esquerda:</label>
    <div class="position-selector">
      <button class="position-btn active" onclick="selectLeftHandPosition(1)">1 Nota [Raiz]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(2)">2 Notas [1+5]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(3)">3 Notas [1+3+5]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(4)">4 Notas [1+8]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(5)">5 Notas [1+5+8]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(6)">6 Notas [1+3+5+8]</button>
      <button class="position-btn" onclick="selectLeftHandPosition(7)">7 Notas [1+5+10] (7¬™)</button>
    </div>
  </div>

  <div class="row">
    <div class="box">
      <label>Cifra Base (Ex.: C, F#, Gm)</label>
      <input id="rootLeft" placeholder="C, F#, Bb" value="C">
    </div>
    <div class="box">
      <label>Qualidade (Ex.: m, m7, 7, ¬∞)</label>
      <input id="qualityLeft" placeholder="m, m7, 7, ¬∞" value="">
    </div>
    <div class="box">
      <label>Figura (Dura√ß√£o)</label>
      <select id="figureLeft">
        <option value="4" selected>Semibreve</option>
        <option value="2">M√≠nima</option>
        <option value="3">M√≠nima Pontuada</option>
        <option value="">Sem√≠nima</option>
        <option value="3/">Sem√≠nima Pontuada</option> 
        <option value="/">Colcheia</option>
        <option value="3//">Colcheia Pontuada</option>
      </select>
    </div>
  </div>

  <div class="row">
    <div class="box">
      <label>Oitava Base</label>
      <select id="octaveBaseLeft">
        <option value="C,,">C,, (Muito grave)</option>
        <option value="C," selected>C, (Grave)</option>
        <option value="C">C (M√©dio grave)</option>
      </select>
    </div>
    <div class="box">
      <label>Espa√ßamento</label>
      <select id="spacingLeft">
        <option value="tight" selected>Ajustado</option>
        <option value="normal">Normal</option>
        <option value="wide">Aberto</option>
      </select>
    </div>
  </div>

  <!-- Bot√µes de Controle M√£o Esquerda -->
  <div class="toolbar">
    <button class="accent" onclick="generateLeftHand()">Gerar Acorde (M√£o Esquerda)</button>
    <button class="secondary" onclick="appendLeftToEditor()">Adicionar ao Editor</button>
    <button class="info" onclick="generateAllLeftHandPositions()">Gerar Todas Posi√ß√µes</button>
    <button class="info" onclick="saveLeftHandToLibrary()">üíæ Salvar na Biblioteca</button>
    
  </div>

  <label>Trecho Gerado (M√£o Esquerda):</label>
  <textarea id="outputLeftHand"></textarea>
  <div id="paperLeftHand"></div>
</div>

<hr>

<!-- NOVA SE√á√ÉO: PRESETS/EXEMPLOS -->
<div class="presets-section">
  <div class="presets-header">
    <h3>üéµ Presets & Exemplos</h3>
    <button class="presets-toggle-btn" id="presetsToggleBtn" onclick="togglePresets()">
      <span class="toggle-icon">‚ñº</span>
      <span id="presetsToggleText">Ocultar Presets</span>
    </button>
  </div>
  <div class="presets-content" id="presetsContent">
    <p>Clique em um preset para carregar os acordes na biblioteca:</p>
    <div id="presetsContainer" class="presets-grid">
      <!-- Presets ser√£o carregados aqui -->
    </div>
  </div>
</div>

<hr>

<!-- Biblioteca de Acordes -->
<h3>üìö Biblioteca de Acordes</h3>
<div id="chordLibrary" class="chord-library">
  <!-- Acordes ser√£o adicionados dinamicamente aqui -->
</div>
<div class="toolbar">
  <button class="secondary" onclick="saveLibrary()">üíæ Salvar Biblioteca</button>
  <button class="danger" onclick="clearLibrary()">üóëÔ∏è Limpar Biblioteca</button>
  <button class="accent" onclick="playEditor()">‚ñ∂ Play (Editor)</button>
  <button class="danger" onclick="clearEditor()">üóëÔ∏èLimpar Editor</button>
  <button class="secondary" onclick="addBar()">Adicionar Barra (|)</button>
  <button class="danger" onclick="removeLastChord()">üóëÔ∏è Remover Cifra</button>
  
</div>

<textarea id="editor" placeholder="Os acordes da sua progress√£o aparecer√£o aqui. Ex: [CEG]2 [FAC]2 |" 
          oninput="updateEditor()"></textarea>
<div id="paperEdit"></div>

<hr>

<!-- Restante do c√≥digo (Biblioteca, Exporta√ß√£o/Importa√ß√£o) permanece igual -->
<!-- Importa√ß√£o/Exporta√ß√£o da Biblioteca -->
<h3>üì§ Exportar / üì• Importar Biblioteca</h3>
<div class="import-export">
  <div class="row">
    <div class="box">
      <label>Exportar Biblioteca (JSON)</label>
      <textarea id="exportData" readonly></textarea>
      <button class="secondary" onclick="exportLibrary()">üìã Copiar JSON</button>
      <button class="secondary" onclick="downloadLibrary()">‚¨áÔ∏è Download</button>
    </div>
    <div class="box">
      <label>Importar Biblioteca (Cole o JSON)</label>
      <textarea id="importData" placeholder="Cole aqui o JSON da biblioteca..."></textarea>
      <button class="secondary" onclick="importLibrary()">üì• Importar</button>
      <button class="danger" onclick="clearImport()">Limpar</button>
    </div>
  </div>
</div>

</div>

<script>
let editorSynth = null;
let chordLibrary = [];
let currentMeasure = 1;
let currentBeat = 0;
let totalBeats = 4;
let autoBarEnabled = true;
let currentHand = 'right';
let leftHandPosition = 3;
let isPlaying = false;
let presetsCollapsed = false; // Estado inicial: n√£o colapsado

// PRESETS DEFINIDOS NO C√ìDIGO
const PRESETS = [

//CAMPO HARM√îNICO MAIOR TRIADE FUNDAMENTAL LINEAR
{
    id: 'campoHarm√¥nicoMaior',
    title: 'Campo Harm√¥nico Maior',
    description: 'Triade fundamental - linear',
    chords: [
      { name: "C", chord: "[CEG]4" },
      { name: "Dm", chord: "[DFA]4" },
      { name: "Em", chord: "[EGB]4" },
      { name: "F", chord: "[FAc]4" },
      { name: "G", chord: "[GBd]4" },
      { name: "Am", chord: "[Ace]4" },
      { name: "B¬∞", chord: "[Bdf]4" },
      { name: "C", chord: "[ceg]4" }
    ]
  },

//CAMPO HARM√îNICO MAIOR TRIADE FUNDAMENTAL ENCADEADO
{
    id: 'campoHarMaiorFunEncadeado',
    title: 'Campo Harm√¥nico Maior ',
    description: 'Triades fundamental encadeado',
    chords: [
      { name: "C", chord: "[CEG]4" },
      { name: "Dm", chord: "[DFA]4" },
      { name: "Em", chord: "[EGB,]4" },
      { name: "F", chord: "[FAC]4" },
      { name: "G", chord: "[GB,D]4" },
      { name: "Am", chord: "[ACE]4" },
      { name: "B¬∞", chord: "[BDF]4" },
      { name: "C", chord: "[CEG]4" }
    ]
  },

//CAMPO HARM√îNICO MAIOR TRIADE 1 INVERS√ÉO ENCADEADO
{
    id: 'campoHarMaior1NEncadeado',
    title: 'Campo Harm√¥nico Maior',
    description: 'Triades 1 Invers√£o encandeado',
    chords: [
      { name: "C", chord: "[cEG]4" },
      { name: "Dm", chord: "[dFA]4" },
      { name: "Em", chord: "[EGB,]4" },
      { name: "F", chord: "[FAc]4" },
      { name: "G", chord: "[GBd]4" },
      { name: "Am", chord: "[AcE]4" },
      { name: "B¬∞", chord: "[BdF]4" },
      { name: "C", chord: "[cEG]4" }
    ]
  },

//CAMPO HARM√îNICO MAIOR TRIADE 2 INVERS√ÉO ENCADEADO
{
    id: 'campoHarMaior2NEncadeado',
    title: 'Campo Harm√¥nico Maior',
    description: 'Triades 2 Invers√£o encandeado',
    chords: [
      { name: "C", chord: "[ceG]4" },
      { name: "Dm", chord: "[dfA]4" },
      { name: "Em", chord: "[eGB,]4" },
      { name: "F", chord: "[fAc]4" },
      { name: "G", chord: "[GBd]4" },
      { name: "Am", chord: "[Ace]4" },
      { name: "B¬∞", chord: "[Bde]4" },
      { name: "C", chord: "[ceG]4" }
    ]
  }

];

document.addEventListener("DOMContentLoaded", () => {
    
  // ===================== CONFIGURA√á√ïES B√ÅSICAS =====================
  const output = document.getElementById('output');
  const root = document.getElementById('root');
  const quality = document.getElementById('quality');
  const inversion = document.getElementById('inversion');
  const figure = document.getElementById('figure');
  const editor = document.getElementById('editor');
  const chordLibraryEl = document.getElementById('chordLibrary');
  const measureCounter = document.getElementById('measureCounter');
  const timeSignature = document.getElementById('timeSignature');
  const autoBarToggle = document.getElementById('autoBarToggle');
  const exportData = document.getElementById('exportData');
  const importData = document.getElementById('importData');
  const octaveShift = document.getElementById('octaveShift');
  
  // Elementos da M√£o Esquerda
  const outputLeftHand = document.getElementById('outputLeftHand');
  const rootLeft = document.getElementById('rootLeft');
  const qualityLeft = document.getElementById('qualityLeft');
  const figureLeft = document.getElementById('figureLeft');
  const octaveBaseLeft = document.getElementById('octaveBaseLeft');
  const spacingLeft = document.getElementById('spacingLeft');
  const rightHandSection = document.getElementById('rightHandSection');
  const leftHandSection = document.getElementById('leftHandSection');

  // Elementos para renderiza√ß√£o
  const paperElement = document.getElementById('paper');
  const paperLeftHand = document.getElementById('paperLeftHand');
  const paperEdit = document.getElementById('paperEdit');

  // Elementos para presets
  const presetsContainer = document.getElementById('presetsContainer');
  const presetsToggleBtn = document.getElementById('presetsToggleBtn');
  const presetsContent = document.getElementById('presetsContent');
  const presetsToggleText = document.getElementById('presetsToggleText');

  // ===================== FUN√á√ÉO PARA CRIAR ELEMENTO DE STATUS =====================
  function createStatusElement() {
    const status = document.createElement('div');
    status.id = 'status';
    status.style.cssText = 'position: fixed; top: 10px; right: 10px; padding: 10px; background: #333; color: white; border-radius: 5px; z-index: 1000; display: none;';
    document.body.appendChild(status);
    return status;
  }

  const statusElement = document.getElementById('status') || createStatusElement();

  function showStatus(message, type = 'info') {
    if (!statusElement) return;
    
    statusElement.textContent = message;
    statusElement.style.display = 'block';
    statusElement.style.background = type === 'error' ? '#dc3545' : 
                                    type === 'success' ? '#28a745' : 
                                    type === 'warning' ? '#ffc107' : '#17a2b8';
    
    setTimeout(() => {
      statusElement.style.display = 'none';
    }, 3000);
  }

  // ===================== FUN√á√ïES PARA PRESETS =====================
  window.togglePresets = function() {
    try {
      presetsCollapsed = !presetsCollapsed;
      
      if (presetsCollapsed) {
        // Ocultar presets
        presetsContent.classList.add('collapsed');
        presetsToggleBtn.classList.add('collapsed');
        presetsToggleText.textContent = 'Mostrar Presets';
        showStatus('Presets ocultados', 'info');
      } else {
        // Mostrar presets
        presetsContent.classList.remove('collapsed');
        presetsToggleBtn.classList.remove('collapsed');
        presetsToggleText.textContent = 'Ocultar Presets';
        showStatus('Presets mostrados', 'info');
      }
      
      // Salvar prefer√™ncia no localStorage
      localStorage.setItem('presetsCollapsed', presetsCollapsed);
      
    } catch (error) {
      console.error('Erro ao alternar presets:', error);
      showStatus('Erro ao alternar presets', 'error');
    }
  };

  function renderPresets() {
    if (!presetsContainer) return;
    
    presetsContainer.innerHTML = '';
    
    PRESETS.forEach((preset, index) => {
      const div = document.createElement('div');
      div.className = 'preset-item';
      div.setAttribute('data-preset-id', preset.id);
      
      // Criar preview dos acordes (nomes)
      const chordNames = preset.chords.map(c => c.name).join(', ');
      
      div.innerHTML = `
        <div class="preset-title">${preset.title}</div>
        <div class="preset-description">${preset.description}</div>
        <div class="preset-chords" title="${chordNames}">${chordNames.substring(0, 50)}${chordNames.length > 50 ? '...' : ''}</div>
        <div class="preset-controls">
          <button class="secondary" onclick="loadPreset(${index})" title="Carregar na Biblioteca">Carregar</button>
          <button class="info" onclick="previewPreset(${index})" title="Visualizar">Ver</button>
        </div>
      `;
      
      // Adicionar clique no item inteiro
      div.addEventListener('click', (e) => {
        // N√£o disparar se clicar nos bot√µes
        if (!e.target.closest('button')) {
          loadPreset(index);
        }
      });
      
      presetsContainer.appendChild(div);
    });
  }

  window.loadPreset = function(presetIndex) {
    try {
      if (presetIndex < 0 || presetIndex >= PRESETS.length) {
        showStatus('Preset n√£o encontrado', 'error');
        return;
      }
      
      const preset = PRESETS[presetIndex];
      
      // Adicionar todos os acordes do preset √† biblioteca
      preset.chords.forEach(chordItem => {
        const exists = chordLibrary.some(item => 
          item.name === chordItem.name && item.chord === chordItem.chord
        );
        
        if (!exists) {
          chordLibrary.push({
            name: chordItem.name,
            chord: chordItem.chord
          });
        }
      });
      
      // Atualizar a biblioteca
      renderChordLibrary();
      updateExportData();
      
      showStatus(`Preset "${preset.title}" carregado (${preset.chords.length} acordes)`, 'success');
      
      // Rolar para a biblioteca
      document.getElementById('chordLibrary').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
      });
      
    } catch (error) {
      console.error('Erro ao carregar preset:', error);
      showStatus('Erro ao carregar preset', 'error');
    }
  };

  window.previewPreset = function(presetIndex) {
    try {
      if (presetIndex < 0 || presetIndex >= PRESETS.length) {
        showStatus('Preset n√£o encontrado', 'error');
        return;
      }
      
      const preset = PRESETS[presetIndex];
      
      // Criar uma visualiza√ß√£o dos acordes
      let previewABC = "X:1\nT:" + preset.title + "\nM:4/4\nL:1/4\nK:C\n";
      
      preset.chords.forEach((chordItem, idx) => {
        previewABC += chordItem.chord + " ";
        if ((idx + 1) % 4 === 0) previewABC += "| ";
      });
      
      // Mostrar em um alerta ou modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        z-index: 10000; max-width: 500px; max-height: 80vh; overflow-y: auto;
        border: 2px solid #9c27b0;
      `;
      
      modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #7b1fa2;">${preset.title}</h3>
          <button onclick="this.parentElement.parentElement.remove()" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">X</button>
        </div>
        <p><strong>Descri√ß√£o:</strong> ${preset.description}</p>
        <p><strong>Acordes (${preset.chords.length}):</strong></p>
        <ul style="margin-top: 0; padding-left: 20px;">
          ${preset.chords.map(c => `<li><strong>${c.name}:</strong> ${c.chord}</li>`).join('')}
        </ul>
        <div id="presetPreviewPaper" style="margin-top: 15px; border: 1px solid #ddd; padding: 10px; border-radius: 4px;"></div>
        <div style="margin-top: 15px; text-align: center;">
          <button onclick="loadPreset(${presetIndex}); this.parentElement.parentElement.remove();" style="background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; margin-right: 10px;">Carregar na Biblioteca</button>
          <button onclick="this.parentElement.parentElement.remove()" style="background: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer;">Fechar</button>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Renderizar preview musical
      try {
        ABCJS.renderAbc("presetPreviewPaper", previewABC, {
          responsive: 'resize',
          staffwidth: 400,
          scale: 0.7,
          paddingtop: 5,
          paddingbottom: 5
        });
      } catch (e) {
        console.log('N√£o foi poss√≠vel renderizar preview:', e);
      }
      
    } catch (error) {
      console.error('Erro ao visualizar preset:', error);
      showStatus('Erro ao visualizar preset', 'error');
    }
  };

// ===================== TABELA DE ACORDES =====================
  const CHORDS = {
    "C":"[CEG]","C#":"[^C^E^G]","Db":"[_DF_A]","D":"[D^FA]","D#":"[^D^^F^A]",
    "Eb":"[_EG_B]","E":"[E^GB]","F":"[FAc]","F#":"[^F^A^c]","Gb":"[_G_B_d]",
    "G":"[GBd]","G#":"[^G^B^d]","Ab":"[_Ac_e]","A":"[A^ce]","A#":"[^A^^c^e]",
    "Bb":"[_Bdf]","B":"[B^d^f]",
    "Cm":"[C_EG]","C#m":"[^CE^G]","Dbm":"[_D_F_A]","Dm":"[DFA]",
    "D#m":"[^D^F^A]","Ebm":"[_E_G_B]","Em":"[EGB]","Fm":"[F_Ac]",
    "F#m":"[^FA^c]","Gbm":"[_G__B_d]","Gm":"[G_Bd]",
    "G#m":"[^GB^d]","Abm":"[_A_C_e]","Am":"[ACe]",
    "A#m":"[^A^C^e]","Bbm":"[_B_df]","Bm":"[BD^f]",
    "Caug":"[CE^G]","C+":"[CE^G]","C#aug":"[^C^E^^G]","C#+":"[^C^E^^G]","Dbaug":"[_DFA]","Db+":"[_DFA]","Daug":"[D^F^A]","D+":"[D^F^A]",
    "D#aug":"[^D^^F^^A]","D#+":"[^D^^F^^A]","Ebaug":"[_EGB]","Eb+":"[_EGB]","Eaug":"[E^G^B]","E+":"[E^G^B]",
    "Faug":"[FA^c]","F+":"[FA^c]","F#aug":"[^F^A^^c]","F#+":"[^F^A^^c]","Gbaug":"[_G_Bd]","Gb+":"[_G_Bd]",
    "Gaug":"[GB^d]","G+":"[GB^d]","G#aug":"[^G^B^^d]","G#+":"[^G^B^^d]","Abaug":"[_Ace]","Ab+":"[_Ace]",
    "Aaug":"[A^C^e]","A+":"[A^C^e]","A#aug":"[^A^^C^^e]","A#+":"[^A^^C^^e]","Bbaug":"[_Bd^f]","Bb+":"[_Bd^f]","Baug":"[B^d^^f]","B+":"[B^d^^f]",
    "Cdim":"[C_E_G]","C¬∞":"[C_E_G]","C#dim":"[^CEG]","C#¬∞":"[^CEG]",
    "Dbdim":"[_D_F__A]","Db¬∞":"[_D_F__A]","Ddim":"[DF_A]","D¬∞":"[DF_A]",
    "D#dim":"[^D^FA]","D#¬∞":"[^D^FA]","Ebdim":"[_E_G__B]","Eb¬∞":"[_E_G__B]",
    "Edim":"[EG_B]","E¬∞":"[EG_B]","Fdim":"[F_A_c]","F¬∞":"[F_A_c]",
    "F#dim":"[^FAc]","F#¬∞":"[^FAc]","Gbdim":"[_G__B__d]","Gb¬∞":"[_G__B__d]",
    "Gdim":"[G_B_d]","G¬∞":"[G_B_d]","G#dim":"[^GBd]","G#¬∞":"[^GBd]",
    "Abdim":"[_A_C__e]","Ab¬∞":"[_A_C__e]","Adim":"[AC_e]","A¬∞":"[AC_e]",
    "A#dim":"[^A^Ce]","A¬∞":"[AC_e]","Bbdim":"[_B_d_f]","Bb¬∞":"[_B_d_f]",
    "Bdim":"[BDf]","B¬∞":"[BDf]",
    "C7":"[CEG_B]","C#7":"[^C^E^G_B]","Db7":"[_DF_A_c]","D7":"[D^FAc]",
    "D#7":"[^D^^F^A^c]","Eb7":"[_EG_B_d]","E7":"[E^GBd]",
    "F7":"[FAc_e]","F#7":"[^F^A^c_e]","Gb7":"[_G_B_d_f]",
    "G7":"[GBd_f]","G#7":"[^G^B^d_f]","Ab7":"[_Ac_e_g]",
    "A7":"[A^ceg]","A#7":"[^A^^c^e_g]","Bb7":"[_Bdf_a]","B7":"[B^d^fa]",
    "Cm7":"[C_EG_B]","C#m7":"[^CE^G_B]","Dbm7":"[_D_F_A_c]","Dm7":"[DFA_c]",
    "D#m7":"[^D^F^A^c]","Ebm7":"[_E_G_B_d]","Em7":"[EGB_d]",
    "Fm7":"[F_Ac_e]","F#m7":"[^FA^c_e]","Gbm7":"[_G__B_d_f]",
    "Gm7":"[G_Bd_f]","G#m7":"[^GB^d_f]","Abm7":"[_A_C_e_g]",
    "Am7":"[ACe_g]","A#m7":"[^A^C^e_g]","Bbm7":"[_B_df_a]","Bm7":"[BD^f_a]",
    "C6":"[CEGA]","C#6":"[^C^E^G^A]","Db6":"[_DF_AB]","D6":"[D^FAB]",
    "D#6":"[^D^^F^A^B]","Eb6":"[_EG_Bc]","E6":"[E^GBc]",
    "F6":"[FAcd]","F#6":"[^F^A^c^d]","Gb6":"[_G_B_de]",
    "G6":"[GBde]","G#6":"[^G^B^d^e]","Ab6":"[_Ac_ef]",
    "A6":"[A^cef]","A#6":"[^A^^c^e^f]","Bb6":"[_Bdfg]","B6":"[B^d^fg]",
    "C7+":"[CEGB]","C#7+":"[^C^E^G^B]","Db7+":"[_DF_Ac]","D7+":"[D^FA^c]",
    "D#7+":"[^D^^F^A^^c]","Eb7+":"[_EG_Bd]","E7+":"[E^GB^d]",
    "F7+":"[FAce]","F#7+":"[^F^A^c^e]","Gb7+":"[_G_B_df]",
    "G7+":"[GBd^f]","G#7+":"[^G^B^d^^f]","Ab7+":"[_Ac_eg]",
    "A7+":"[A^ce^g]","A#7+":"[^A^^c^e^^g]","Bb7+":"[_Bdfa]","B7+":"[B^d^f^a]",
    "C9":"[CEG_BD]","C#9":"[^C^E^G_BD]","Db9":"[_DF_A_CE]","D9":"[D^FACE]",
    "D#9":"[^D^^F^A^CE]","Eb9":"[_EG_B_DF]","E9":"[E^GBDF]",
    "F9":"[FAc_eg]","F#9":"[^F^A^c_eg]","Gb9":"[_G_B_d_fa]",
    "G9":"[GBd_fa]","G#9":"[^G^B^d_fa]","Ab9":"[_Ac_e_gb]",
    "A9":"[A^ce_gb]","A#9":"[^A^^c^e_gb]","Bb9":"[_Bdf_ac]","B9":"[B^d^fac]",
    "C7(#5)":"[CE^G_B]","C#7(#5)":"[^C^E^^GB]","Db7(#5)":"[_DF^A_c]","D7(#5)":"[D^F^Ac]",
    "D#7(#5)":"[^D^^F^^A^c]","Eb7(#5)":"[_EG^B_d]","E7(#5)":"[E^G^Bd]",
    "F7(#5)":"[FA^c_e]","F#7(#5)":"[^F^A^^ce]","Gb7(#5)":"[_G_B^d_f]",
    "G7(#5)":"[GB^df]","G#7(#5)":"[^G^B^^d^f]","Ab7(#5)":"[_Ac^e_g]",
    "A7(#5)":"[A^C^eg]","A#7(#5)":"[^A^^C^^e^g]","Bb7(#5)":"[_Bd^f_a]","B7(#5)":"[B^d^^fa]",
    "C4":"[CFG]","C#4":"[^C^F^G]","Db4":"[_D_G_A]","D4":"[DGA]",
    "D#4":"[^D^G^A]","Eb4":"[_E_A_B]","E4":"[EAB]",
    "F4":"[FBc]","F#4":"[^F^B^c]","Gb4":"[_G_C_d]",
    "G4":"[GCd]","G#4":"[^G^C^d]","Ab4":"[_A_D_e]",
    "A4":"[ADe]","A#4":"[^A^D^e]","Bb4":"[_B_ef]","B4":"[Be^f]",
    "C2":"[CDG]","C#2":"[^C^D^G]","Db2":"[_D_E_A]","D2":"[DEA]",
    "D#2":"[^D^E^A]","Eb2":"[_EF_B]","E2":"[E^FB]",
    "F2":"[FGc]","F#2":"[^F^G^c]","Gb2":"[_G_A_d]",
    "G2":"[GAd]","G#2":"[^G^A^d]","Ab2":"[_A_B_e]",
    "A2":"[ABe]","A#2":"[^A^B^e]","Bb2":"[_Bcf]","B2":"[B^c^f]",
    "Cm7b5":"[C_E_G_B]","C#m7b5":"[^CEGB]","Dbm7b5":"[_D_F__A_c]","Dm7b5":"[DF_Ac]",
    "D#m7b5":"[^D^FA^c]","Ebm7b5":"[_E_G__B_d]","Em7b5":"[EG_Bd]",
    "Fm7b5":"[F_A_c_e]","F#m7b5":"[^FAce]","Gbm7b5":"[_G__B__d_f]",
    "Gm7b5":"[G_B_df]","G#m7b5":"[^GBd^f]","Abm7b5":"[_A_C__e_g]",
    "Am7b5":"[AC_eg]","A#m7b5":"[^A^Ce^g]","Bbm7b5":"[_B_d_f_a]","Bm7b5":"[BDfa]",
    "Cm6":"[C_EGA]","C#m6":"[^CE^G^A]","Dbm6":"[_D_F_A_B]","Dm6":"[DFAB]",
    "D#m6":"[^D^F^A^B]","Ebm6":"[_E_G_Bc]","Em6":"[EGB^c]",
    "Fm6":"[F_Acd]","F#m6":"[^FA^c^d]","Gbm6":"[_G__B_d_e]",
    "Gm6":"[G_Bde]","G#m6":"[^GB^d^e]","Abm6":"[_A_C_ef]",
    "Am6":"[ACe^f]","A#m6":"[^A^C^e^f]","Bbm6":"[_B_dfg]","Bm6":"[BD^f^g]"
  };
  // ===================== FUN√á√ïES AUXILIARES =====================
  function separarNotas(abcChord) {
    if (!abcChord || !abcChord.startsWith('[')) return [];
    
    const notasStr = abcChord.replace(/[\[\]]/g, "");
    if (!notasStr.includes(' ')) {
      const regex = /([_^=]*[A-Ga-g][,']*)/g;
      const matches = notasStr.match(regex) || [];
      return matches;
    }
    return notasStr.trim().split(/\s+/);
  }

  function formatarNotasABC(notasArray) {
    if (!notasArray || !notasArray.length) return '';
    return notasArray.join(' ');
  }

  function formatarAcordeABC(abcChord) {
    if (!abcChord.startsWith('[')) return abcChord;
    const conteudo = abcChord.slice(1, -1);
    const partes = conteudo.split(/\s+/);
    return '[' + partes.join(' ') + ']';
  }

  function subirOitava(nota) {
    const match = nota.match(/^([_^=]*)([A-Ga-g])([,']*)$/);
    if (!match) return nota;
    
    const accidentes = match[1];
    const letra = match[2];
    const oitavas = match[3] || "";
    
    if (oitavas.includes(',')) {
      const numVirgulas = (oitavas.match(/,/g) || []).length;
      if (numVirgulas > 1) {
        const novasOitavas = ','.repeat(numVirgulas - 1);
        return accidentes + letra + novasOitavas;
      } else {
        return accidentes + letra;
      }
    } else if (letra === letra.toUpperCase()) {
      return accidentes + letra.toLowerCase();
    } else {
      return accidentes + letra + "'" + oitavas.replace(/'/g, '');
    }
  }

  function transporNotaOitava(nota, dir) {
    const match = nota.match(/^([_^=]*)([A-Ga-g])([,']*)$/);
    if (!match) return nota;

    let acc = match[1];
    let letter = match[2];
    let oct = match[3] || "";
    
    if (dir > 0) {
      for (let i = 0; i < Math.abs(dir); i++) {
        if (oct.includes(',')) {
          const numVirgulas = (oct.match(/,/g) || []).length;
          if (numVirgulas > 1) {
            oct = ','.repeat(numVirgulas - 1);
          } else {
            oct = '';
          }
        } else if (letter === letter.toUpperCase()) {
          letter = letter.toLowerCase();
        } else {
          oct += "'";
        }
      }
    } else if (dir < 0) {
      for (let i = 0; i < Math.abs(dir); i++) {
        if (oct.includes("'")) {
          oct = oct.replace(/'$/, '');
        } else if (letter === letter.toLowerCase()) {
          letter = letter.toUpperCase();
        } else {
          oct += ',';
        }
      }
    }
    
    return acc + letter + oct;
  }

  function inverterAcorde(abcChord, inv) {
    if (inv === 0) return abcChord;
    
    const notas = separarNotas(abcChord);
    if (notas.length <= 1) return abcChord;
    
    let notasParaInverter = [...notas];
    
    for (let i = 0; i < inv; i++) {
      if (i >= notasParaInverter.length - 1) break;
      const primeiraNota = notasParaInverter.shift();
      const notaSubida = subirOitava(primeiraNota);
      notasParaInverter.push(notaSubida);
    }
    
    return formatarAcordeABC(`[${formatarNotasABC(notasParaInverter)}]`);
  }

  function transporAcordeOitava(abcChord, dir) {
    if (dir === 0) return abcChord;
    const notas = separarNotas(abcChord);
    if (!notas || !notas.length) return abcChord;
    const novas = notas.map(n => transporNotaOitava(n, dir));
    return formatarAcordeABC(`[${formatarNotasABC(novas)}]`);
  }

  function getDurationValue(durationStr) {
    const durationMap = {
      '4': 4,
      '2': 2,
      '3': 3,
      '/': 1,
      '3/': 1.5,
      '//': 0.5,
      '3//': 0.75,
      '8': 0.5,
      '16': 0.25
    };
    return durationMap[durationStr] || 1;
  }

  function parseABCChord(chordABC) {
    if (!chordABC) return { chord: '', duration: '4' };
    
    const match = chordABC.match(/^(\[[^\]]+\])(\d*\.?\d*\/?\d*\.?\d*)$/);
    if (match) {
      return {
        chord: match[1],
        duration: match[2] || '4'
      };
    }
    
    const match2 = chordABC.match(/^(\[[^\]]+\])$/);
    if (match2) {
      return { chord: match2[1], duration: '4' };
    }
    
    return { chord: chordABC, duration: '4' };
  }

  // ===================== FUN√á√ïES DE VALIDA√á√ÉO =====================
  function validateABC(abcString) {
    if (!abcString) return { valid: false, error: 'String vazia' };
    
    try {
      if (!abcString.includes('X:')) {
        return { valid: false, error: 'Falta cabe√ßalho X:' };
      }
      
      if (!abcString.includes('K:')) {
        return { valid: false, error: 'Falta indica√ß√£o de clave K:' };
      }
      
      const testDiv = document.createElement('div');
      ABCJS.renderAbc(testDiv, abcString);
      
      return { valid: true, error: null };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }

  // ===================== FUN√á√ÉO FIND VOICE SECTION MELHORADA =====================
  function findVoiceSection(lines, voiceNumber) {
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      const isVoice1 = voiceNumber === 1 && (line.startsWith('V:1') || line.includes('M√£o Direita') || line.includes('clef=treble'));
      const isVoice2 = voiceNumber === 2 && (line.startsWith('V:2') || line.includes('M√£o Esquerda') || line.includes('clef=bass'));
      
      if (isVoice1 || isVoice2) {
        // Encontrar onde termina esta voz
        let endIndex = i + 1;
        
        while (endIndex < lines.length) {
          const nextLine = lines[endIndex].trim();
          
          // Parar se encontrar outra voz ou cabe√ßalho
          if (nextLine.startsWith('V:') || 
              nextLine.startsWith('X:') ||
              nextLine.startsWith('T:') ||
              nextLine.startsWith('C:') ||
              nextLine.startsWith('M:') ||
              nextLine.startsWith('L:') ||
              nextLine.startsWith('K:')) {
            break;
          }
          
          endIndex++;
        }
        
        // Garantir que endIndex n√£o seja menor que i+1
        if (endIndex <= i) {
          endIndex = i + 1;
        }
        
        const contentLines = lines.slice(i + 1, endIndex);
        
        return {
          startIndex: i,
          endIndex: endIndex,
          contentLines: contentLines
        };
      }
    }
    return null;
  }

  // ===================== FUN√á√ÉO GERAR ACORDE M√ÉO DIREITA =====================
 window.generate = function() {
  try {
    const rootValue = root.value.trim();
    const qualityValue = quality.value.trim();
    const cifraCompleta = rootValue + qualityValue;
    const inv = parseInt(inversion.value) || 0;
    const duracao = figure.value || '4';
    const octaveShiftValue = parseInt(octaveShift?.value || 0);

    let chordKey = cifraCompleta;
    
    if (!CHORDS[cifraCompleta]) {
      if (!CHORDS[rootValue]) {
        output.value = `ERRO: Cifra "${cifraCompleta}" n√£o encontrada.`;
        showStatus(`Cifra "${cifraCompleta}" n√£o encontrada`, 'error');
        if (paperElement) {
          ABCJS.renderAbc("paper", "X:1\nM:4/4\nL:1/4\nK:C\nz4", {
            responsive: 'resize',
            staffwidth: 900,
            scale: 0.7
          });
        }
        return;
      }
      chordKey = rootValue;
    }

    let acorde = CHORDS[chordKey];
    acorde = inverterAcorde(acorde, inv);
    acorde = transporAcordeOitava(acorde, octaveShiftValue);
    
    // MODIFICA√á√ÉO: Gerar COM cifra por padr√£o
    const resultadoFinal = `"${cifraCompleta}"` + acorde + duracao;
    output.value = resultadoFinal;

    if (paperElement) {
      ABCJS.renderAbc("paper", `X:1\nM:4/4\nL:1/4\nK:C\n${resultadoFinal}`, {
        responsive: 'resize',
        staffwidth: 900,
        scale: 0.7,
        paddingtop: 5,
        paddingbottom: 5,
        paddingright: 5,
        paddingleft: 5
      });
    }
    
    showStatus(`Acorde ${cifraCompleta} gerado`, 'success');
  } catch (error) {
    console.error('Erro em generate:', error);
    showStatus('Erro ao gerar acorde', 'error');
  }
};

// Vers√£o sem cifra (opcional)
window.generateWithoutSymbol = function() {
  try {
    const rootValue = root.value.trim();
    const qualityValue = quality.value.trim();
    const cifraCompleta = rootValue + qualityValue;
    const inv = parseInt(inversion.value) || 0;
    const duracao = figure.value || '4';
    const octaveShiftValue = parseInt(octaveShift?.value || 0);

    let chordKey = cifraCompleta;
    
    if (!CHORDS[cifraCompleta] && CHORDS[rootValue]) {
      chordKey = rootValue;
    }

    if (!CHORDS[chordKey]) {
      output.value = `ERRO: Cifra n√£o encontrada.`;
      showStatus(`Cifra n√£o encontrada`, 'error');
      return;
    }

    let acorde = CHORDS[chordKey];
    acorde = inverterAcorde(acorde, inv);
    acorde = transporAcordeOitava(acorde, octaveShiftValue);
    
    // SEM cifra
    const resultadoFinal = acorde + duracao;
    output.value = resultadoFinal;

    if (paperElement) {
      ABCJS.renderAbc("paper", `X:1\nM:4/4\nL:1/4\nK:C\n${resultadoFinal}`, {
        responsive: 'resize',
        staffwidth: 900,
        scale: 0.7,
        paddingtop: 5,
        paddingbottom: 5,
        paddingright: 5,
        paddingleft: 5
      });
    }
    
    showStatus(`Acorde gerado (sem cifra)`, 'success');
  } catch (error) {
    console.error('Erro em generateWithoutSymbol:', error);
    showStatus('Erro ao gerar acorde', 'error');
  }
};

  // ===================== NOVAS FUN√á√ïES PARA SALVAR NA BIBLIOTECA =====================
  window.saveRightHandToLibrary = function() {
    try {
      const generated = output.value;
      if (!generated || generated.startsWith('ERRO')) {
        showStatus('Gere um acorde v√°lido primeiro', 'warning');
        return;
      }
      
      const rootValue = root.value.trim();
      const qualityValue = quality.value.trim();
      const cifraCompleta = rootValue + qualityValue;
      const inv = parseInt(inversion.value) || 0;
      
      let chordName = cifraCompleta;
      if (inv > 0) {
        chordName += ` Inv${inv}`;
      }
      
      // Adicionar √† biblioteca
      addToLibrary(chordName, generated);
      
      showStatus(`"${chordName}" salvo na biblioteca`, 'success');
      
    } catch (error) {
      console.error('Erro em saveRightHandToLibrary:', error);
      showStatus('Erro ao salvar na biblioteca', 'error');
    }
  };

  window.saveLeftHandToLibrary = function() {
    try {
      const generated = outputLeftHand.value;
      if (!generated || generated.startsWith('ERRO')) {
        showStatus('Gere um acorde v√°lido primeiro', 'warning');
        return;
      }
      
      const rootValue = rootLeft.value.trim();
      const qualityValue = qualityLeft.value.trim();
      const cifraCompleta = rootValue + qualityValue;
      
      // Criar nome descritivo
      let chordName = cifraCompleta;
      
      // Adicionar informa√ß√£o da posi√ß√£o
      const positionNames = {
        1: "Raiz",
        2: "1+5", 
        3: "1+3+5",
        4: "1+8",
        5: "1+5+8",
        6: "1+3+5+8",
        7: "1+5+10"
      };
      
      chordName += ` LH${leftHandPosition} (${positionNames[leftHandPosition]})`;
      
      // Adicionar √† biblioteca
      addToLibrary(chordName, generated);
      
      showStatus(`"${chordName}" salvo na biblioteca`, 'success');
      
    } catch (error) {
      console.error('Erro em saveLeftHandToLibrary:', error);
      showStatus('Erro ao salvar na biblioteca', 'error');
    }
  };

  // ===================== FUN√á√ïES M√ÉO ESQUERDA =====================
  window.switchHand = function(hand) {
    try {
      currentHand = hand;
      
      document.querySelectorAll('.hand-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      const activeBtn = document.querySelector(`.hand-btn[onclick="switchHand('${hand}')"]`);
      if (activeBtn) activeBtn.classList.add('active');
      
      if (hand === 'right') {
        if (rightHandSection) rightHandSection.style.display = 'block';
        if (leftHandSection) leftHandSection.style.display = 'none';
      } else {
        if (rightHandSection) rightHandSection.style.display = 'none';
        if (leftHandSection) leftHandSection.style.display = 'block';
      }
      
      showStatus(`M√£o ${hand === 'right' ? 'Direita' : 'Esquerda'} selecionada`, 'info');
    } catch (error) {
      console.error('Erro em switchHand:', error);
    }
  };

  window.selectLeftHandPosition = function(position) {
    try {
      leftHandPosition = position;
      
      document.querySelectorAll('.position-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      const buttons = document.querySelectorAll('.position-btn');
      if (buttons.length >= position) {
        buttons[position - 1].classList.add('active');
      }
      
      if (rootLeft && rootLeft.value.trim()) {
        generateLeftHand();
      }
      
      showStatus(`Posi√ß√£o ${position} selecionada`, 'info');
    } catch (error) {
      console.error('Erro em selectLeftHandPosition:', error);
    }
  };

  function getLeftHandIntervals(chordNotes, position) {
    if (!chordNotes || chordNotes.length === 0) return [];
    const rootNote = chordNotes[0];
    
    switch(position) {
      case 1: return [rootNote];
      case 2: 
        if (chordNotes.length >= 3) return [rootNote, chordNotes[2]];
        return [rootNote, rootNote];
      case 3: return chordNotes.slice(0, Math.min(3, chordNotes.length));
      case 4: return [rootNote, rootNote + "'"];
      case 5: 
        if (chordNotes.length >= 3) return [rootNote, chordNotes[2], rootNote + "'"];
        return [rootNote, rootNote, rootNote + "'"];
      case 6: 
        if (chordNotes.length >= 3) return [rootNote, chordNotes[1], chordNotes[2], rootNote + "'"];
        return [rootNote, rootNote, rootNote, rootNote + "'"];
      case 7: 
        if (chordNotes.length >= 4) return [rootNote, chordNotes[2], chordNotes[1] + "'"];
        else if (chordNotes.length >= 3) return [rootNote, chordNotes[2], chordNotes[1] + "'"];
        return [rootNote, rootNote, rootNote + "'"];
      default: return chordNotes.slice(0, Math.min(3, chordNotes.length));
    }
  }

function adjustOctaveForLeftHand(notesArray, baseOctave) {
  return notesArray.map(note => {
    // Extrair a parte da nota (sem acidentes e oitavas)
    const match = note.match(/^([_^=]*)([A-Ga-g])([,']*)$/);
    if (!match) return note;
    
    const accidentes = match[1]; // acidentes (_, ^, =)
    const letra = match[2]; // letra (A-G, a-g)
    const oitavasExistente = match[3] || ""; // oitavas que j√° existem
    
    // Determinar a oitava base
    let oitavaNova = "";
    switch(baseOctave) {
      case 'C,,': 
        oitavaNova = ",,";
        break;
      case 'C,': 
        oitavaNova = ",";
        break;
      case 'C': 
        oitavaNova = ""; // Sem v√≠rgulas para oitava C
        break;
      default: 
        oitavaNova = ",";
    }
    
    // Manter a letra mai√∫scula ou min√∫scula conforme a nota original
    // Se a nota original era min√∫scula, manter min√∫scula; se era mai√∫scula, manter mai√∫scula
    const letraFinal = letra; // Mant√©m como est√° (mai√∫scula ou min√∫scula)
    
    // Combinar tudo
    return accidentes + letraFinal + oitavaNova + oitavasExistente;
  });
}

  function applySpacing(notesArray, spacing) {
    const result = [...notesArray];
    if (spacing === 'wide' && result.length > 1) {
      if (result.length >= 3 && leftHandPosition !== 3 && leftHandPosition !== 6) {
        result.splice(1, 1);
      }
    }
    return result;
  }

  window.generateLeftHand = function() {
  try {
    const rootValue = rootLeft.value.trim();
    const qualityValue = qualityLeft.value.trim();
    const cifraCompleta = rootValue + qualityValue;
    const duracao = figureLeft.value || '4';
    const baseOctave = octaveBaseLeft.value;
    const spacing = spacingLeft.value;

    let chordKey = cifraCompleta;
    
    if (!CHORDS[cifraCompleta]) {
      if (!CHORDS[rootValue]) {
        outputLeftHand.value = `ERRO: Cifra "${cifraCompleta}" n√£o encontrada.`;
        showStatus(`Cifra "${cifraCompleta}" n√£o encontrada`, 'error');
        if (paperLeftHand) {
          ABCJS.renderAbc("paperLeftHand", "X:1\nM:4/4\nL:1/4\nK:C\nz4", {
            responsive: 'resize',
            staffwidth: 900,
            scale: 0.7
          });
        }
        return;
      }
      chordKey = rootValue;
    }

    const originalChord = CHORDS[chordKey];
    const originalNotes = separarNotas(originalChord);
    let leftHandNotes = getLeftHandIntervals(originalNotes, leftHandPosition);
    leftHandNotes = adjustOctaveForLeftHand(leftHandNotes, baseOctave);
    leftHandNotes = applySpacing(leftHandNotes, spacing);
    
    const leftHandChord = formatarAcordeABC(`[${formatarNotasABC(leftHandNotes)}]`);
    const resultadoFinal = leftHandChord + duracao;
    outputLeftHand.value = resultadoFinal;

    if (paperLeftHand) {
      // RENDERIZAR COM CLAVE DE F√Å
      const abcString = `X:1\nM:4/4\nL:1/4\nK:C clef=bass\n${resultadoFinal}`;
      
      ABCJS.renderAbc("paperLeftHand", abcString, {
        responsive: 'resize',
        staffwidth: 900,
        scale: 0.7,
        paddingtop: 5,
        paddingbottom: 5,
        paddingright: 5,
        paddingleft: 5
      });
    }
    
    showStatus(`M√£o esquerda gerada (Posi√ß√£o ${leftHandPosition})`, 'success');
    return resultadoFinal;
  } catch (error) {
    console.error('Erro em generateLeftHand:', error);
    showStatus('Erro ao gerar m√£o esquerda', 'error');
    return null;
  }
};

  // ===================== EDITOR DE PARTITURA =====================
  function initializeEditor() {
    if (!editor) return;
    
    if (!editor.value.trim()) {
      editor.value = 
`X:1
T:T√≠tulo da M√∫sica
C:Compositor
Q:80
M:4/4
L:1/4
K:C
V:1
V:2 bass 
`;
      updateEditor();
    }
  }

  function renderFullScore() {
    try {
      if (!editor || !editor.value.trim()) {
        return;
      }
      
      const validation = validateABC(editor.value);
      if (!validation.valid) {
        showStatus(`Erro na partitura: ${validation.error}`, 'error');
        return;
      }
      
      const visualOptions = {
        responsive: 'resize',
        staffwidth: 900,
        scale: 0.9,
        paddingtop: 10,
        paddingbottom: 10,
        paddingright: 10,
        paddingleft: 10,
        viewportHorizontal: true
      };
      
      // Renderizar no paperEdit
      if (paperEdit) {
        ABCJS.renderAbc("paperEdit", editor.value, visualOptions);
      }
      
      updateMeasureCounter();
      
    } catch (error) {
      console.error('Erro em renderFullScore:', error);
    }
  }

  window.updateEditor = function() {
    if (!editor) return;
    
    try {
      const lines = editor.value.split('\n');
      let hasHeader = false;
      let hasVoices = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('X:')) hasHeader = true;
        if (trimmed.startsWith('V:')) hasVoices = true;
      }
      
      if (!hasHeader) {
        editor.value = 
`X:1
T:T√≠tulo da M√∫sica
C:Compositor
%%score 1|2
Q:80
M:4/4
L:1/4
K:C
V:1 
V:2 bass 
`;
      } else if (!hasVoices) {
        editor.value += '\nV:1 clef=treble name="M√£o Direita"\nz4\nV:2 clef=bass name="M√£o Esquerda"\nz4';
      }
      
      renderFullScore();
      updateExportData();
      
    } catch (error) {
      console.error('Erro em updateEditor:', error);
      showStatus('Erro ao atualizar editor', 'error');
    }
  };

  function updateMeasureCounter() {
    try {
      if (!editor || !measureCounter) return;
      
      const lines = editor.value.split('\n');
      let measureCount = 0;
      let beatCount = 0;
      let inMusic = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('K:')) {
          inMusic = true;
          continue;
        }
        
        if (inMusic && trimmed && !trimmed.startsWith('%') && !trimmed.startsWith('//')) {
          const measures = trimmed.split('|');
          if (measures.length > 1) {
            measureCount += measures.length - 1;
          }
          
          const elements = trimmed.split(/\s+/);
          for (const element of elements) {
            if (element === '|' || element === '') continue;
            
            const parsed = parseABCChord(element);
            const duration = getDurationValue(parsed.duration);
            if (duration > 0) {
              beatCount += 4 / duration;
            }
          }
        }
      }
      
      const currentMeasureCalc = Math.floor(beatCount / totalBeats) + 1;
      const currentBeatInMeasure = beatCount % totalBeats;
      
      currentMeasure = Math.max(1, Math.max(measureCount, currentMeasureCalc));
      measureCounter.textContent = `Compasso: ${currentMeasure} | ${currentBeatInMeasure.toFixed(1)}/${totalBeats} tempos`;
      
    } catch (error) {
      console.error('Erro em updateMeasureCounter:', error);
      if (measureCounter) measureCounter.textContent = 'Compasso: 1 | 0/4 tempos';
    }
  }

  // ===================== FUN√á√ïES PARA ADICIONAR AO EDITOR =====================
  window.appendToEditor = function() {
    try {
      const generated = output.value;
      if (!generated || generated.startsWith('ERRO') || !editor) {
        showStatus('Gere um acorde v√°lido primeiro', 'warning');
        return;
      }
      
      // Adicionar √† biblioteca (AGORA TAMB√âM SALVA AUTOMATICAMENTE)
      const rootValue = root.value.trim();
      const qualityValue = quality.value.trim();
      const cifraCompleta = rootValue + qualityValue;
      const inv = parseInt(inversion.value) || 0;
      
      let chordName = cifraCompleta;
      if (inv > 0) {
        chordName += ` Inv${inv}`;
      }
      
      addToLibrary(chordName, generated);
      
      const lines = editor.value.split('\n');
      let voice1Section = findVoiceSection(lines, 1);
      
      if (!voice1Section) {
        // Se n√£o tem V:1, verificar se tem estrutura b√°sica
        if (!editor.value.includes('V:')) {
          editor.value = 
`X:1
T:T√≠tulo da M√∫sica
C:Compositor
Q:80
M:4/4
L:1/4
K:C
V:1 clef=treble name="M√£o Direita"
${generated}
V:2 clef=bass name="M√£o Esquerda"
z4`;
        } else {
          editor.value += '\nV:1 clef=treble name="M√£o Direita"\n' + generated;
        }
      } else {
        // Encontrar a √∫ltima linha de conte√∫do em V:1
        let lastContentIndex = -1;
        for (let i = voice1Section.startIndex + 1; i < voice1Section.endIndex; i++) {
          if (lines[i].trim() && !lines[i].trim().startsWith('//')) {
            lastContentIndex = i;
          }
        }
        
        if (lastContentIndex === -1) {
          // N√£o tem conte√∫do ainda, adicionar na primeira linha ap√≥s V:1
          lines.splice(voice1Section.startIndex + 1, 0, generated);
        } else {
          // Adicionar ao final da √∫ltima linha com conte√∫do
          const currentLine = lines[lastContentIndex].trim();
          
          if (currentLine && !currentLine.endsWith(' ') && !currentLine.endsWith('|')) {
            lines[lastContentIndex] = currentLine + ' ' + generated;
          } else if (currentLine) {
            lines[lastContentIndex] = currentLine + generated;
          } else {
            lines[lastContentIndex] = generated;
          }
        }
        
        editor.value = lines.join('\n');
      }
      
      updateEditor();
      showStatus('Acorde adicionado √† m√£o direita e salvo na biblioteca', 'success');
      
    } catch (error) {
      console.error('Erro em appendToEditor:', error);
      showStatus('Erro ao adicionar ao editor', 'error');
    }
  };

  window.appendLeftToEditor = function() {
    try {
      const generated = outputLeftHand.value;
      if (!generated || generated.startsWith('ERRO') || !editor) {
        showStatus('Gere um acorde v√°lido primeiro', 'warning');
        return;
      }
      
      // AGORA SALVA AUTOMATICAMENTE NA BIBLIOTECA TAMB√âM
      const rootValue = rootLeft.value.trim();
      const qualityValue = qualityLeft.value.trim();
      const cifraCompleta = rootValue + qualityValue;
      
      // Criar nome descritivo
      let chordName = cifraCompleta;
      
      // Adicionar informa√ß√£o da posi√ß√£o
      const positionNames = {
        1: "Raiz",
        2: "1+5", 
        3: "1+3+5",
        4: "1+8",
        5: "1+5+8",
        6: "1+3+5+8",
        7: "1+5+10"
      };
      
      chordName += ` LH${leftHandPosition} (${positionNames[leftHandPosition]})`;
      
      // Adicionar √† biblioteca
      addToLibrary(chordName, generated);
      
      const lines = editor.value.split('\n');
      let voice2Section = findVoiceSection(lines, 2);
      
      if (!voice2Section) {
        // Se n√£o tem V:2, adicionar estrutura b√°sica
        let insertPos = lines.length;
        
        // Encontrar onde colocar V:2 (ap√≥s V:1 se existir)
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].includes('V:1') || lines[i].includes('M√£o Direita')) {
            // Encontrar onde termina V:1
            let v1End = i + 1;
            while (v1End < lines.length && !lines[v1End].trim().startsWith('V:')) {
              v1End++;
            }
            insertPos = v1End;
            break;
          }
        }
        
        lines.splice(insertPos, 0, 'V:2 clef=bass name="M√£o Esquerda"', generated);
        editor.value = lines.join('\n');
      } else {
        // Encontrar a √∫ltima linha de conte√∫do em V:2
        let lastContentIndex = -1;
        for (let i = voice2Section.startIndex + 1; i < voice2Section.endIndex; i++) {
          if (lines[i].trim() && !lines[i].trim().startsWith('//')) {
            lastContentIndex = i;
          }
        }
        
        if (lastContentIndex === -1) {
          // N√£o tem conte√∫do ainda, adicionar na primeira linha ap√≥s V:2
          lines.splice(voice2Section.startIndex + 1, 0, generated);
        } else {
          // Adicionar ao final da √∫ltima linha com conte√∫do
          const currentLine = lines[lastContentIndex].trim();
          
          if (currentLine && !currentLine.endsWith(' ') && !currentLine.endsWith('|')) {
            lines[lastContentIndex] = currentLine + ' ' + generated;
          } else if (currentLine) {
            lines[lastContentIndex] = currentLine + generated;
          } else {
            lines[lastContentIndex] = generated;
          }
        }
        
        editor.value = lines.join('\n');
      }
      
      updateEditor();
      showStatus('Acorde adicionado √† m√£o esquerda e salvo na biblioteca', 'success');
      
    } catch (error) {
      console.error('Erro em appendLeftToEditor:', error);
      showStatus('Erro ao adicionar ao editor', 'error');
    }
  };

  // ===================== BIBLIOTECA DE ACORDES =====================
  function addToLibrary(name, chord) {
    try {
      const exists = chordLibrary.some(item => item.name === name && item.chord === chord);
      if (!exists) {
        chordLibrary.push({ name, chord });
        renderChordLibrary();
        updateExportData();
      }
    } catch (error) {
      console.error('Erro em addToLibrary:', error);
    }
  }

  function renderChordLibrary() {
    if (!chordLibraryEl) return;
    
    try {
      chordLibraryEl.innerHTML = '';
      
      if (chordLibrary.length === 0) {
        chordLibraryEl.innerHTML = '<div class="empty-library">Nenhum acorde na biblioteca</div>';
        return;
      }
      
      chordLibrary.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'chord-item';
        div.innerHTML = `
          <span class="chord-name">${item.name}</span>
          <span class="chord-abc">${item.chord}</span>
          <div class="chord-controls">
            <button onclick="playChordFromLibrary(${index})" title="Tocar">‚ñ∂</button>
            <button onclick="insertFromLibrary(${index})" title="Inserir">+</button>
            <button onclick="removeFromLibrary(${index})" title="Remover">√ó</button>
          </div>
        `;
        chordLibraryEl.appendChild(div);
      });
    } catch (error) {
      console.error('Erro em renderChordLibrary:', error);
    }
  }

  window.insertFromLibrary = function(index) {
    try {
      if (index >= 0 && index < chordLibrary.length && editor) {
        const chord = chordLibrary[index].chord;
        const cursorPos = editor.selectionStart;
        const text = editor.value;
        
        const beforeChar = text.substring(cursorPos - 1, cursorPos);
        const spaceNeeded = beforeChar && beforeChar !== ' ' && beforeChar !== '\n' && beforeChar !== '';
        
        editor.value = text.substring(0, cursorPos) + 
                      (spaceNeeded ? ' ' : '') + 
                      chord + 
                      ' ' + 
                      text.substring(cursorPos);
        
        updateEditor();
        
        const newPos = cursorPos + (spaceNeeded ? 1 : 0) + chord.length + 1;
        editor.selectionStart = newPos;
        editor.selectionEnd = newPos;
        editor.focus();
        
        showStatus(`"${chordLibrary[index].name}" inserido`, 'success');
      }
    } catch (error) {
      console.error('Erro em insertFromLibrary:', error);
      showStatus('Erro ao inserir da biblioteca', 'error');
    }
  };

  window.playChordFromLibrary = function(index) {
    try {
      if (index >= 0 && index < chordLibrary.length) {
        const chord = chordLibrary[index].chord;
        const parsed = parseABCChord(chord);
        playChord(parsed.chord, parsed.duration);
        showStatus(`Tocando "${chordLibrary[index].name}"`, 'info');
      }
    } catch (error) {
      console.error('Erro em playChordFromLibrary:', error);
      showStatus('Erro ao tocar acorde', 'error');
    }
  };

  window.removeFromLibrary = function(index) {
    try {
      if (index >= 0 && index < chordLibrary.length) {
        const removedName = chordLibrary[index].name;
        chordLibrary.splice(index, 1);
        renderChordLibrary();
        updateExportData();
        showStatus(`"${removedName}" removido da biblioteca`, 'success');
      }
    } catch (error) {
      console.error('Erro em removeFromLibrary:', error);
      showStatus('Erro ao remover da biblioteca', 'error');
    }
  };

 // ===================== PLAYBACK =====================
window.playChord = function(chordABC, duration) {
  try {
    if (editorSynth) {
      editorSynth.stop();
    }
    
    const abcString = `X:1\nM:4/4\nL:1/4\nK:C\n${chordABC}${duration}`;
    
    // Criar objeto visual
    const visualObj = ABCJS.renderAbc("paper", abcString)[0];
    
    // Inicializar sintetizador
    editorSynth = new ABCJS.synth.CreateSynth();
    
    editorSynth.init({
      visualObj: visualObj,
      options: {
        soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/",
        chordsOff: false
      }
    }).then(() => {
      return editorSynth.prime();
    }).then(() => {
      editorSynth.start();
      isPlaying = true;
      showStatus(`Tocando acorde`, 'success');
    }).catch(error => {
      console.error("Erro ao tocar acorde:", error);
      showStatus('Erro ao tocar acorde: ' + error.message, 'error');
    });
  } catch (error) {
    console.error("Erro em playChord:", error);
    showStatus('Erro ao tocar acorde', 'error');
  }
};

window.playEditor = function() {
  try {
    if (!editor || !editor.value.trim()) {
      showStatus('O editor est√° vazio!', 'warning');
      return;
    }
    
    if (isPlaying) {
      stopPlayback();
      return;
    }
    
    const validation = validateABC(editor.value);
    if (!validation.valid) {
      showStatus(`Erro na partitura: ${validation.error}`, 'error');
      return;
    }
    
    if (editorSynth) {
      editorSynth.stop();
      editorSynth = null;
    }
    
    // Atualizar visualiza√ß√£o
    renderFullScore();
    
    const visualObj = ABCJS.renderAbc("paperEdit", editor.value, {
      responsive: 'resize',
      staffwidth: 900,
      viewportHorizontal: true
    })[0];
    
    // Criar novo sintetizador
    editorSynth = new ABCJS.synth.CreateSynth();
    
    showStatus('Preparando playback...', 'info');
    
    editorSynth.init({
      visualObj: visualObj,
      options: {
        soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/",
        chordsOff: false,
        midiTranspose: 0,
        visualTranspose: 0,
        qpm: 80
      }
    }).then(() => {
      return editorSynth.prime();
    }).then(() => {
      showStatus('Tocando partitura...', 'info');
      isPlaying = true;
      
      const playBtn = document.querySelector('button[onclick="playEditor()"]');
      if (playBtn) playBtn.textContent = '‚èπ Stop';
      
      editorSynth.start();
      
      // Detectar quando termina
      if (editorSynth.audioContext) {
        editorSynth.audioContext.onended = () => {
          isPlaying = false;
          const playBtn = document.querySelector('button[onclick="playEditor()"]');
          if (playBtn) playBtn.textContent = '‚ñ∂ Play (Editor)';
          showStatus('Playback conclu√≠do', 'success');
        };
      }
      
    }).catch(error => {
      console.error("Erro ao tocar partitura:", error);
      showStatus('Erro ao tocar partitura: ' + error.message, 'error');
      isPlaying = false;
    });
    
  } catch (error) {
    console.error("Erro em playEditor:", error);
    showStatus('Erro ao tocar partitura', 'error');
    isPlaying = false;
  }
};

window.stopPlayback = function() {
  try {
    if (editorSynth) {
      editorSynth.stop();
      editorSynth = null;
      isPlaying = false;
      
      const playBtn = document.querySelector('button[onclick="playEditor()"]');
      if (playBtn) playBtn.textContent = '‚ñ∂ Play (Editor)';
      
      showStatus('Playback interrompido', 'info');
    }
  } catch (error) {
    console.error('Erro em stopPlayback:', error);
  }
};

  // ===================== EXPORT/IMPORT =====================
  window.updateExportData = function() {
    try {
      if (!exportData) return;
      
      const data = {
        version: '1.0',
        editor: editor ? editor.value : '',
        chords: chordLibrary,
        settings: {
          currentHand,
          leftHandPosition,
          timeSignature: timeSignature ? timeSignature.value : '4/4',
          autoBarEnabled,
          presetsCollapsed
        },
        timestamp: new Date().toISOString()
      };
      
      exportData.value = JSON.stringify(data, null, 2);
      
    } catch (error) {
      console.error('Erro em updateExportData:', error);
    }
  };

  window.exportLibrary = function() {
    try {
      updateExportData();
      if (exportData && exportData.value) {
        navigator.clipboard.writeText(exportData.value)
          .then(() => showStatus('Biblioteca copiada para a √°rea de transfer√™ncia!', 'success'))
          .catch(() => {
            exportData.select();
            document.execCommand('copy');
            showStatus('Biblioteca copiada!', 'success');
          });
      }
    } catch (error) {
      console.error('Erro em exportLibrary:', error);
      showStatus('Erro ao exportar biblioteca', 'error');
    }
  };

  window.downloadLibrary = function() {
    try {
      updateExportData();
      if (!exportData || !exportData.value) return;
      
      const blob = new Blob([exportData.value], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'biblioteca_acordes.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showStatus('Biblioteca baixada!', 'success');
    } catch (error) {
      console.error('Erro em downloadLibrary:', error);
      showStatus('Erro ao baixar biblioteca', 'error');
    }
  };

  window.importLibrary = function() {
    try {
      if (!importData) return;
      
      const jsonText = importData.value.trim();
      if (!jsonText) {
        showStatus('Cole o JSON da biblioteca primeiro', 'warning');
        return;
      }
      
      const data = JSON.parse(jsonText);
      
      if (data.editor && editor) {
        editor.value = data.editor;
      }
      
      if (data.chords && Array.isArray(data.chords)) {
        chordLibrary = data.chords;
        renderChordLibrary();
      }
      
      if (data.settings) {
        currentHand = data.settings.currentHand || 'right';
        leftHandPosition = data.settings.leftHandPosition || 3;
        
        if (data.settings.timeSignature && timeSignature) {
          timeSignature.value = data.settings.timeSignature;
          updateTimeSignature();
        }
        
        autoBarEnabled = data.settings.autoBarEnabled !== false;
        if (autoBarToggle) {
          autoBarToggle.checked = autoBarEnabled;
        }
        
        // Restaurar estado dos presets
        presetsCollapsed = data.settings.presetsCollapsed || false;
        if (presetsCollapsed) {
          presetsContent.classList.add('collapsed');
          presetsToggleBtn.classList.add('collapsed');
          presetsToggleText.textContent = 'Mostrar Presets';
        } else {
          presetsContent.classList.remove('collapsed');
          presetsToggleBtn.classList.remove('collapsed');
          presetsToggleText.textContent = 'Ocultar Presets';
        }
        
        switchHand(currentHand);
        selectLeftHandPosition(leftHandPosition);
      }
      
      updateEditor();
      showStatus('Biblioteca importada com sucesso!', 'success');
      
    } catch (e) {
      console.error('Erro em importLibrary:', e);
      showStatus('Erro ao importar biblioteca: ' + e.message, 'error');
    }
  };

  window.clearImport = function() {
    if (importData) {
      importData.value = '';
      showStatus('Campo de importa√ß√£o limpo', 'info');
    }
  };

  window.saveLibrary = function() {
    try {
      updateExportData();
      localStorage.setItem('chordLibrary', JSON.stringify(chordLibrary));
      localStorage.setItem('editorContent', editor ? editor.value : '');
      localStorage.setItem('presetsCollapsed', presetsCollapsed);
      showStatus('Biblioteca salva localmente', 'success');
    } catch (error) {
      console.error('Erro em saveLibrary:', error);
      showStatus('Erro ao salvar biblioteca', 'error');
    }
  };

  window.clearLibrary = function() {
    try {
      if (confirm('Tem certeza que deseja limpar toda a biblioteca?')) {
        chordLibrary = [];
        renderChordLibrary();
        updateExportData();
        showStatus('Biblioteca limpa', 'success');
      }
    } catch (error) {
      console.error('Erro em clearLibrary:', error);
      showStatus('Erro ao limpar biblioteca', 'error');
    }
  };

  window.clearEditor = function() {
    try {
      if (editor && confirm('Tem certeza que deseja limpar o editor?')) {
        editor.value = '';
        updateEditor();
        showStatus('Editor limpo', 'success');
      }
    } catch (error) {
      console.error('Erro em clearEditor:', error);
      showStatus('Erro ao limpar editor', 'error');
    }
  };

  // ===================== INICIALIZA√á√ÉO =====================
  function init() {
    try {
      // Configurar autoBarToggle
      if (autoBarToggle) {
        autoBarToggle.checked = autoBarEnabled;
        autoBarToggle.addEventListener('change', function() {
          autoBarEnabled = this.checked;
          showStatus(`Barras autom√°ticas ${autoBarEnabled ? 'ativadas' : 'desativadas'}`, 'info');
        });
      }
      
      // Configurar timeSignature
      if (timeSignature) {
        timeSignature.addEventListener('change', updateTimeSignature);
      }
      
      // Sincronizar campos entre m√£os
      if (rootLeft && root) {
        rootLeft.addEventListener('input', () => {
          root.value = rootLeft.value;
        });
        
        root.addEventListener('input', () => {
          rootLeft.value = root.value;
        });
      }
      
      if (qualityLeft && quality) {
        qualityLeft.addEventListener('input', () => {
          quality.value = qualityLeft.value;
        });
        
        quality.addEventListener('input', () => {
          qualityLeft.value = quality.value;
        });
      }
      
      // Configurar listener para atualizar exporta√ß√£o
      if (editor) {
        editor.addEventListener('input', updateExportData);
      }
      
      // Carregar dados salvos
      try {
        const savedLibrary = localStorage.getItem('chordLibrary');
        if (savedLibrary) {
          chordLibrary = JSON.parse(savedLibrary);
        }
        
        const savedEditor = localStorage.getItem('editorContent');
        if (savedEditor && editor) {
          editor.value = savedEditor;
        }
        
        const savedPresetsState = localStorage.getItem('presetsCollapsed');
        if (savedPresetsState !== null) {
          presetsCollapsed = savedPresetsState === 'true';
          
          // Aplicar estado salvo
          if (presetsCollapsed) {
            presetsContent.classList.add('collapsed');
            presetsToggleBtn.classList.add('collapsed');
            presetsToggleText.textContent = 'Mostrar Presets';
          }
        }
      } catch (e) {
        console.log('Nenhum dado salvo encontrado');
      }
      
      // Gerar acorde inicial
      generate();
      
      // Inicializar editor
      updateEditor();
      
      // Renderizar biblioteca
      renderChordLibrary();
      
      // Inicializar export data
      updateExportData();
      
      // Renderizar presets
      renderPresets();
      
      showStatus('Aplicativo carregado com sucesso!', 'success');
      
    } catch (error) {
      console.error('Erro na inicializa√ß√£o:', error);
      showStatus('Erro ao inicializar aplicativo', 'error');
    }
  }

  function updateTimeSignature() {
    try {
      if (!timeSignature || !editor) return;
      
      const sig = timeSignature.value;
      const match = sig.match(/(\d+)\/(\d+)/);
      if (match) {
        totalBeats = parseInt(match[1]);
        updateMeasureCounter();
        
        const lines = editor.value.split('\n');
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].trim().startsWith('M:')) {
            lines[i] = `M:${sig}`;
            break;
          }
        }
        editor.value = lines.join('\n');
        updateEditor();
        
        showStatus(`F√≥rmula de compasso alterada para ${sig}`, 'success');
      }
    } catch (error) {
      console.error('Erro em updateTimeSignature:', error);
      showStatus('Erro ao alterar compasso', 'error');
    }
  }

  window.generateAllLeftHandPositions = function() {
    try {
      const rootValue = rootLeft.value.trim();
      const qualityValue = qualityLeft.value.trim();
      const cifraCompleta = rootValue + qualityValue;
      const duracao = figureLeft.value || '4';
      const baseOctave = octaveBaseLeft.value;

      let chordKey = cifraCompleta;
      
      if (!CHORDS[cifraCompleta] && CHORDS[rootValue]) {
        chordKey = rootValue;
      }

      if (!CHORDS[chordKey]) {
        showStatus('Cifra n√£o encontrada!', 'error');
        return;
      }

      for (let pos = 1; pos <= 7; pos++) {
        const originalChord = CHORDS[chordKey];
        const originalNotes = separarNotas(originalChord);
        let leftHandNotes = getLeftHandIntervals(originalNotes, pos);
        leftHandNotes = adjustOctaveForLeftHand(leftHandNotes, baseOctave);
        
        const leftHandChord = formatarAcordeABC(`[${formatarNotasABC(leftHandNotes)}]`);
        const resultadoFinal = leftHandChord + duracao;
        
        const chordName = `${cifraCompleta} LH${pos}`;
        addToLibrary(chordName, resultadoFinal);
      }
      
      showStatus('Todas as 7 posi√ß√µes da m√£o esquerda foram adicionadas √† biblioteca!', 'success');
      
    } catch (error) {
      console.error('Erro em generateAllLeftHandPositions:', error);
      showStatus('Erro ao gerar posi√ß√µes', 'error');
    }
  };

  // ===================== FUN√á√ïES PARA INSERIR BARRA =====================
  window.addBar = function() {
    try {
      if (!editor) return;
      
      const lines = editor.value.split('\n');
      let modified = false;
      
      // Usar a m√£o atual selecionada para determinar a voz
      const currentVoice = currentHand === 'right' ? 1 : 2;
      let voiceSection = findVoiceSection(lines, currentVoice);
      
      if (!voiceSection) {
        // Se n√£o encontrou a voz, adicionar estrutura b√°sica
        editor.value = 
`X:1
T:T√≠tulo da M√∫sica
C:Compositor
Q:80
M:4/4
L:1/4
K:C
V:1 clef=treble name="M√£o Direita"
z4
V:2 clef=bass name="M√£o Esquerda"
z4`;
        updateEditor();
        showStatus('Estrutura b√°sica adicionada. Agora voc√™ pode inserir barras.', 'info');
        return;
      }
      
      // Encontrar a √∫ltima linha com conte√∫do na voz
      let lastContentLineIndex = -1;
      for (let i = voiceSection.startIndex + 1; i < voiceSection.endIndex; i++) {
        if (lines[i].trim() && !lines[i].trim().startsWith('//')) {
          lastContentLineIndex = i;
        }
      }
      
      if (lastContentLineIndex === -1) {
        // Se n√£o tem conte√∫do, adicionar barra ap√≥s o cabe√ßalho
        lines.splice(voiceSection.startIndex + 1, 0, '|');
        modified = true;
      } else {
        // Adicionar barra ao final da √∫ltima linha com conte√∫do
        const currentLine = lines[lastContentLineIndex].trim();
        
        if (!currentLine.endsWith('|')) {
          // Se a linha n√£o termina com |, adicionar espa√ßo e |
          lines[lastContentLineIndex] = currentLine + ' |';
          modified = true;
        } else {
          showStatus('A linha j√° termina com uma barra', 'info');
          return;
        }
      }
      
      if (modified) {
        editor.value = lines.join('\n');
        updateEditor();
        
        // Posicionar cursor ap√≥s a barra
        const cursorPos = editor.value.length;
        editor.selectionStart = cursorPos;
        editor.selectionEnd = cursorPos;
        editor.focus();
        
        showStatus(`Barra inserida na ${currentVoice === 1 ? 'm√£o direita (V:1)' : 'm√£o esquerda (V:2)'}`, 'success');
      }
      
    } catch (error) {
      console.error('Erro em addBar:', error);
      showStatus('Erro ao inserir barra', 'error');
    }
  };
// ===================== FUN√á√ÉO PARA ADICIONAR CIFRAS =====================
window.addChordSymbols = function() {
  try {
    if (!editor || !editor.value.trim()) {
      showStatus('O editor est√° vazio!', 'warning');
      return;
    }
    
    const lines = editor.value.split('\n');
    let modified = false;
    
    // Processar cada linha da partitura
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Ignorar cabe√ßalhos e linhas de coment√°rio
      if (line.startsWith('X:') || line.startsWith('T:') || 
          line.startsWith('C:') || line.startsWith('M:') || 
          line.startsWith('L:') || line.startsWith('K:') ||
          line.startsWith('V:') || line.startsWith('%') ||
          line.startsWith('//') || line === '') {
        continue;
      }
      
      // Procurar por acordes [ ] na linha
      const chordRegex = /(\[[^\]]+\]\d*\.?\d*\/?\d*\.?\d*)/g;
      let match;
      let newLine = line;
      
      while ((match = chordRegex.exec(line)) !== null) {
        const chordABC = match[1];
        
        // Encontrar o nome do acorde correspondente
        let chordName = findChordName(chordABC);
        
        if (chordName) {
          // Adicionar cifra antes do acorde
          newLine = newLine.replace(chordABC, `"${chordName}"${chordABC}`);
          modified = true;
        }
      }
      
      if (newLine !== line) {
        lines[i] = newLine;
      }
    }
    
    if (modified) {
      editor.value = lines.join('\n');
      updateEditor();
      showStatus('Cifras adicionadas aos acordes', 'success');
    } else {
      showStatus('Nenhum acorde encontrado para adicionar cifras', 'info');
    }
    
  } catch (error) {
    console.error('Erro em addChordSymbols:', error);
    showStatus('Erro ao adicionar cifras', 'error');
  }
};

// Fun√ß√£o auxiliar para encontrar o nome do acorde
function findChordName(chordABC) {
  try {
    // Extrair as notas do acorde
    const notesMatch = chordABC.match(/\[([^\]]+)\]/);
    if (!notesMatch) return null;
    
    const notes = notesMatch[1].split(' ').filter(n => n.trim() !== '');
    
    // Procurar no dicion√°rio de acordes
    for (const [name, abc] of Object.entries(CHORDS)) {
      const chordNotes = abc.replace(/[\[\]]/g, '').split(' ').filter(n => n.trim() !== '');
      
      // Comparar se as notas s√£o equivalentes (ignorando oitavas)
      if (areChordNotesEquivalent(notes, chordNotes)) {
        return name;
      }
    }
    
    return null;
  } catch (error) {
    console.error('Erro em findChordName:', error);
    return null;
  }
}

// Fun√ß√£o para comparar acordes (ignorando oitavas)
function areChordNotesEquivalent(notes1, notes2) {
  try {
    if (notes1.length !== notes2.length) return false;
    
    // Normalizar notas (remover oitavas e acidentes)
    const normalizeNote = (note) => {
      const match = note.match(/^([_^=]*)([A-Ga-g])/);
      return match ? match[2].toUpperCase() : '';
    };
    
    const normalized1 = notes1.map(normalizeNote).sort();
    const normalized2 = notes2.map(normalizeNote).sort();
    
    return JSON.stringify(normalized1) === JSON.stringify(normalized2);
  } catch (error) {
    return false;
  }
}
  // ===================== INICIALIZAR APLICATIVO =====================
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
});
</script>
</body>
  </html>
