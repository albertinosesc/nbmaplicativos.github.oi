<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Percep√ß√£o Auditiva - Modos e Escalas</title>

    <script src="https://cdn.jsdelivr.net/npm/abcjs@6.4.2/dist/abcjs-basic-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
    <script src="https://unpkg.com/tonejs-instrument@1.1.0/lib/Tone.instrument.js"></script>
    
    <style>
/* Bloco CSS Completo */
body { font-family: Arial, Helvetica, sans-serif; background:#f7f9fb; padding:18px; max-width:1200px; margin:auto; }
h1 { text-align:center; color:#222; margin-bottom:6px; }
.controls { display:flex; gap:16px; flex-wrap:wrap; justify-content:center; margin-bottom:14px; }
.control { background:#fff; padding:14px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-width:240px; }
label strong { display:block; margin-bottom:6px; color:#333; }
select, button, input[type="number"], input[type="range"] { width:100%; padding:8px; border-radius:8px; border:1px solid #ccc; font-size:14px; box-sizing:border-box; }
button { cursor:pointer; }
#paper { margin:16px auto; width:100%; max-width:900px; background:#fff; padding:16px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-height:80px; }
#status { text-align:center; margin-top:12px; padding:8px; border-radius:8px; font-weight:700; }
.status-default { color:#444; background: none; }
.status-awaiting { color:#0d47a1; background:#e3f2fd; }
.status-correct { color:#fff; background:#2e7d32; }
.status-wrong { color:#fff; background:#c62828; }
.note-buttons { display:flex; gap:10px; justify-content:center; margin-top:16px; flex-wrap:wrap; }
.note-buttons button { padding:10px 14px; border-radius:8px; border:none; background:#1976d2; color:white; font-weight:700; min-width:56px; }
.note-buttons button:disabled { background:#cfd8dc; color:#666; cursor:not-allowed; }
.note-buttons button.correct { background:#2e7d32; }
.note-buttons button.wrong { background:#c62828; }
.small { font-size:13px; color:#555; margin-top:8px; }
.row { display:flex; gap:8px; align-items:center; }
.row > input[type="number"] { width:120px; flex:0 0 120px; }
.val { font-weight:700; margin-left:6px; }
#scoreboard { text-align:center; margin-bottom:10px; font-weight:700; color:#333; }
#scoreboard span { color:#1976d2; margin:0 6px; }
.select-actions { display:flex; gap:6px; margin-top:8px; }
.select-actions button { padding:6px 8px; font-size:13px; background:#efefef; border:1px solid #d0d0d0; cursor:pointer; }
.checkbox-row { display: flex; align-items: center; margin-top: 8px; }
.checkbox-row input[type="checkbox"] { margin-right: 8px; width: auto; }
@media (max-width:900px) { 
  .controls { flex-direction:column; } 
  .control { min-width:auto; } 
}
    </style>
</head>
<body>
    <h1>üéπ Treino de Percep√ß√£o Auditiva ‚Äî Modos e Escalas</h1>

    <div id="scoreboard">Acertos: <span id="correctCount">0</span> / Tentativas: <span id="attemptCount">0</span>
        <button onclick="resetScore()" style="margin-left:8px;padding:6px 10px;background:#c62828;color:white;border:none;border-radius:6px;cursor:pointer;" type="button">Limpar Placar</button>
    </div>

    <div class="controls">
        <div class="control">
            <label><strong>Notas poss√≠veis (respostas)</strong></label>
            <select id="notas" multiple size="13">
                <option value="C" selected>C</option><option value="C#" selected>C#</option><option value="D" selected>D</option><option value="D#" selected>D#</option>
                <option value="E" selected>E</option><option value="F" selected>F</option><option value="F#" selected>F#</option><option value="G" selected>G</option>
                <option value="G#" selected>G#</option><option value="A" selected>A</option><option value="A#" selected>A#</option><option value="B" selected>B</option>
                <option value="C(6)" selected>C (Oitava Acima)</option> 
            </select>
            <div class="select-actions">
                <button id="selAllBtn" type="button">Selecionar Todas</button>
                <button id="clearAllBtn" type="button">Limpar Sele√ß√£o</button>
            </div>
            <div class="small">Somente notas selecionadas aparecem nos bot√µes de resposta (modo manual).</div>
        </div>

        <div class="control">
            <label><strong>T√¥nica da Sequ√™ncia (Escala)</strong></label>
            <select id="tom">
                <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
                <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
                <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>

            <label style="margin-top:8px"><strong>T√¥nica do Intervalo (1¬™ Nota)</strong></label>
            <div class="checkbox-row" style="margin-bottom: 8px;">
                <input type="checkbox" id="randomizeInitialRoot">
                <label for="randomizeInitialRoot" style="margin:0; font-weight:normal;">T√¥nica Aleat√≥ria a cada Rodada</label>
            </div>

            <label style="margin-top:8px"><strong>Notas Aleat√≥rias (Origem)</strong></label>
            <select id="initialRootNoteSource" disabled>
                <option value="chromatic">Escala Crom√°tica (Todas as 12)</option>
                <option value="mode">Escala do Modo Selecionado</option>
            </select>

            <select id="initialRootNote">
                <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
                <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
                <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
            </select>

            <label style="margin-top:8px"><strong>Oitava da nota secreta</strong></label>
            <select id="oitava">
                <option value="3">3</option>
                <option value="4" selected>4</option>
                <option value="5">5</option>
            </select>

            <label style="margin-top:8px"><strong>Modo / Escala</strong></label>
            <select id="modo">
                <option value="ionian">J√¥nio (Maior)</option>
                <option value="dorian">D√≥rico</option>
                <option value="phrygian">Fr√≠gio</option>
                <option value="lydian">L√≠dio</option>
                <option value="mixolydian">Mixol√≠dio</option>
                <option value="aeolian">Menor Natural (E√≥lio)</option>
                <option value="harmonic_minor">Menor Harm√¥nica</option>
                <option value="melodic_minor">Menor Mel√≥dica (asc)</option>
                <option value="locrian">L√≥crio</option>
                <option value="chromatic">Crom√°tica</option>
            </select>

            <label style="margin-top:8px"><strong>Dire√ß√£o da Sequ√™ncia</strong></label>
            <select id="direcao">
                <option value="desc">Decrescente</option>
                <option value="asc">Ascendente</option>
                <option value="both_desc_asc">Decrescente e Ascendente</option>
                <option value="both_asc_desc">Ascendente e Decrescente</option>
            </select>
        </div>

        <div class="control">
            <label><strong>Controles</strong></label>
            <button id="btnStart" style="background:#2e7d32;color:white;margin-bottom:8px;" type="button">‚ñ∂ Iniciar Treino</button>
            <button id="btnStop" style="background:#e53935;color:white;margin-bottom:8px;" type="button">‚èπ Parar</button>
            <button id="btnRepeat" style="background:#6a1b9a;color:white;margin-bottom:8px;" disabled type="button">üîÅ Ouvir Nota Novamente</button>
            
            <label style="margin-top:8px"><strong>Tocar t√¥nica antes da nota oculta</strong></label>
            <div class="checkbox-row">
                <input type="checkbox" id="playTonicBefore" checked>
                <label for="playTonicBefore" style="margin:0; font-weight:normal;">Ativado</label>
            </div>
            
            <label style="margin-top:8px"><strong>Tocar Sequ√™ncia ap√≥s Palpite</strong></label>
            <div class="checkbox-row">
                <input type="checkbox" id="playSequenceAfterGuess" checked>
                <label for="playSequenceAfterGuess" style="margin:0; font-weight:normal;">Ativado</label>
            </div>

            <label style="margin-top:8px"><strong>Avan√ßar Automaticamente</strong></label>
            <div class="checkbox-row">
                <input type="checkbox" id="autoAdvance">
                <label for="autoAdvance" style="margin:0; font-weight:normal;">Avan√ßar p/ pr√≥xima nota ap√≥s sequ√™ncia (sem palpite)</label>
            </div>

            <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">
            
            <label style="margin-top:8px"><strong>Timbre do Instrumento</strong></label>
            <select id="instrumentSelector">
                <option value="0" selected>0 - Piano Ac√∫stico</option>
                <option value="25">25 - Viol√£o (Guitarra Nylon)</option>
                <option value="40">40 - Violino</option>
                <option value="56">56 - Trompete</option>
                <option value="73">73 - Flauta</option>
            </select>
            <div class="small">Selecione o timbre. Ele ser√° carregado automaticamente.</div>

            <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">
            
            <label><strong>Quantidade de Notas de Preenchimento</strong></label>
            <div class="row" style="justify-content: space-between;">
                <input id="fillNotesNum" type="number" min="0" max="100" step="1" value="0" style="width: 100%;">
            </div>
            <div class="small">Notas aleat√≥rias da escala para tocar entre a t√¥nica e a nota secreta.</div>
            
            <label style="margin-top:8px"><strong>Tempo (entre notas de Preenchimento)</strong></label>
            <div class="row">
                <input id="delayFillBetweenRange" type="range" min="50" max="1000" step="50" value="100">
                <input id="delayFillBetweenNum" type="number" min="50" max="1000" step="50" value="100">
            </div>
            <div class="small">Controla a velocidade das notas de preenchimento.</div>
            
            <label style="margin-top:8px"><strong>Tempo (T√¥nica/Preenchimento $\to$ Nota Secreta)</strong></label>
            <div class="row">
                <input id="delayTonicSecretRange" type="range" min="0" max="2000" step="50" value="750">
                <input id="delayTonicSecretNum" type="number" min="0" max="2000" step="50" value="750">
            </div>
            <div class="small">Controla o atraso ap√≥s o preenchimento (ou t√¥nica) e a nota secreta.</div>

            <label style="margin-top:8px"><strong>Tempo (Nota Secreta $\to$ Sequ√™ncia)</strong></label>
            <div class="row">
                <input id="delayBeforeRange" type="range" min="0" max="3000" step="50" value="750">
                <input id="delayBeforeNum" type="number" min="0" max="3000" step="50" value="750">
            </div>

            <label style="margin-top:8px"><strong>Tempo (entre notas da Sequ√™ncia de Escala)</strong></label>
            <div class="row">
                <input id="delayBetweenSequenceRange" type="range" min="25" max="1500" step="25" value="570">
                <input id="delayBetweenSequenceNum" type="number" min="25" max="1500" step="25" value="570">
            </div>
            <div class="small">Controla a velocidade das notas da sequ√™ncia tocada ap√≥s o palpite (se ativado).</div>
            
            <label style="margin-top:8px"><strong>Tempo (Sequ√™ncia $\to$ Pr√≥xima Nota)</strong></label>
            <div class="row">
                <input id="delayAfterRange" type="range" min="0" max="5000" step="50" value="1100">
                <input id="delayAfterNum" type="number" min="0" max="5000" step="50" value="1100">
            </div>
        </div>
    </div>

    <div id="paper"></div>
    <div id="status" class="status-default">üéπ Carregando Piano Ac√∫stico...</div>
    <div class="note-buttons" id="noteButtons"></div>

<script>
/* ============================
    Dados e Configura√ß√µes
    ============================ */
const NOTE_NAMES_BASE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_NAMES = [...NOTE_NAMES_BASE, "C(6)"];
const MODOS = {
    ionian:           [0,2,4,5,7,9,11],
    dorian:           [0,2,3,5,7,9,10],
    phrygian:         [0,1,3,5,7,8,10],
    lydian:           [0,2,4,6,7,9,11],
    mixolydian:       [0,2,4,5,7,9,10],
    aeolian:          [0,2,3,5,7,8,10],
    harmonic_minor: [0,2,3,5,7,8,11],
    melodic_minor:    [0,2,3,5,7,9,11], // ascendente
    locrian:          [0,1,3,5,6,8,10],
    chromatic:        [0,1,2,3,4,5,6,7,8,9,10,11]
};

// NOVO: MAPEAMENTO DE TECLAS
// A l√≥gica foi desenhada para facilitar a digita√ß√£o na m√£o direita (QWERTY/QWERTZ/AZERTY)
const KEYBOARD_MAP = {
    'C': 'C',
    'D': 'D',
    'E': 'E',
    'F': 'F',
    'G': 'G',
    'A': 'A',
    'B': 'B',
    'I': 'C#', // I
    'O': 'D#', // O
    'K': 'F#', // K
    'L': 'G#', // L
    '√á': 'A#', // √á (Funciona em teclados ABNT2, no US pode ser ';')
    ';': 'A#' // Adicionando ';' para teclados US que usam ele no lugar de '√á'
};


let instrument = null;
let instrumentType = 'sampler';
let currentMidiProgram = 0;

const simpleSynthConfig = {
    oscillator: { type: "sine" },
    envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
};

const SYNTH_PRESETS = {
    0: { oscillator: { type: "triangle8" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0.4, release: 0.8 } },
    25: { 
        oscillator: { type: "sawtooth" }, 
        envelope: { attack: 0.002, decay: 1.5, sustain: 0.0, release: 0.5, releaseCurve: 'linear' } 
    },
    40: {
        synth: "AMSynth",
        oscillator: { type: "sawtooth" },
        modulation: { type: "square" },
        envelope: { attack: 0.1, decay: 0.8, sustain: 0.6, release: 1.2 }
    },
    56: {
        synth: "FMSynth",
        harmonicity: 3.01,
        modulationIndex: 14,
        oscillator: { type: "sine" },
        envelope: { attack: 0.05, decay: 0.4, sustain: 0.6, release: 0.5 }
    },
    73: { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.9, sustain: 0.7, release: 1.5 } },
    default: simpleSynthConfig 
};


/* ============================
    L√≥gica do Instrumento / Timbre
    ============================ */
function loadInstrumentFromMIDIProgram(programNumber) {
    DOM.btnStart.disabled = true;
    DOM.instrumentSelector.disabled = true;
    
    DOM.statusEl.textContent = `üéµ Tentando carregar timbre MIDI Program ${programNumber}...`;
    DOM.statusEl.className = "status-awaiting";

    if (instrument) {
        instrument.dispose();
        instrument = null;
    }
    
    currentMidiProgram = programNumber;
    DOM.instrumentSelector.value = programNumber;
    
    try {
        // Verifica se √© um MIDI program que tem samples dispon√≠veis no tonejs-instrument
        const instrumentUrls = Tone.Instrument.loadProgram(programNumber);

        if (!instrumentUrls) {
             fallbackToSimpleSynth();
             return;
        }

        instrument = new Tone.Sampler({
            urls: instrumentUrls,
            onload: () => {
                instrument.toDestination();
                instrumentType = 'sampler';
                DOM.statusEl.textContent = `üéπ Timbre ${programNumber} (Sampler) pronto. Clique em 'Iniciar Treino'.`;
                DOM.btnStart.disabled = false;
                DOM.instrumentSelector.disabled = false;
                DOM.statusEl.className = "status-default";
                updateUIState();
            },
            onerror: (error) => {
                console.error(`Erro ao carregar samples para ${programNumber}. Fallback para Synth.`, error);
                fallbackToSimpleSynth();
            }
        });
        
    } catch(e) {
        console.error("Erro ao inicializar Sampler. Fallback para Synth simples.", e);
        fallbackToSimpleSynth();
    }
}

function fallbackToSimpleSynth() {
    if (instrument) {
        instrument.dispose();
        instrument = null;
    }

    const preset = SYNTH_PRESETS[currentMidiProgram] || SYNTH_PRESETS.default;
    let synthName = "Synth";

    if (preset.synth === "AMSynth") {
        instrument = new Tone.AMSynth(preset).toDestination();
        synthName = "AMSynth";
    } else if (preset.synth === "FMSynth") {
        instrument = new Tone.FMSynth(preset).toDestination();
        synthName = "FMSynth";
    } else {
        instrument = new Tone.Synth(preset).toDestination();
    }

    instrumentType = 'synth';
    DOM.statusEl.textContent = `üîä Sampler falhou. √Åudio Sintetizado (${synthName} - Program ${currentMidiProgram}) pronto.`;
    DOM.btnStart.disabled = false;
    DOM.instrumentSelector.disabled = false;
    DOM.statusEl.className = "status-default";
    updateUIState();
}


/* ============================
    Dados e Estado
    ============================ */

const state = {
    playing: false,
    awaitingGuess: false,
    currentSecretNote: null,
    secretNoteOctave: 4,
    selectedNotes: [],
    keyRoot: "C", 
    initialRoot: "C",
    initialRootSource: "chromatic",
    modoAtual: "ionian",
    direction: "asc",
    playTonic: true,
    randomizeInitialRoot: false,
    score: { correct:0, attempts:0 },
    pendingTimeout: null,
    lastGuess: null,
    fillNotes: 0
};

/* DOM refs */
// IDs atualizadas e novas adicionadas para corresponder ao HTML corrigido
const DOM = {
    btnStart: document.getElementById("btnStart"),
    btnStop: document.getElementById("btnStop"),
    btnRepeat: document.getElementById("btnRepeat"),
    autoAdvance: document.getElementById("autoAdvance"),
    statusEl: document.getElementById("status"),
    noteButtonsDiv: document.getElementById("noteButtons"),
    paperEl: document.getElementById("paper"),
    notasSelect: document.getElementById("notas"),
    tomSelect: document.getElementById("tom"),
    initialRootNoteSelect: document.getElementById("initialRootNote"),
    randomizeInitialRoot: document.getElementById("randomizeInitialRoot"),
    initialRootNoteSource: document.getElementById("initialRootNoteSource"),
    modoSelect: document.getElementById("modo"),
    direcaoSelect: document.getElementById("direcao"),
    oitavaSelect: document.getElementById("oitava"),
    playTonicBefore: document.getElementById("playTonicBefore"),
    playSequenceAfterGuess: document.getElementById("playSequenceAfterGuess"), 
    correctCount: document.getElementById("correctCount"),
    attemptCount: document.getElementById("attemptCount"),
    delayBeforeRange: document.getElementById("delayBeforeRange"),
    delayBeforeNum: document.getElementById("delayBeforeNum"),
    delayBetweenSequenceRange: document.getElementById("delayBetweenSequenceRange"), // ID para SEQU√äNCIA
    delayBetweenSequenceNum: document.getElementById("delayBetweenSequenceNum"), // ID para SEQU√äNCIA
    delayFillBetweenRange: document.getElementById("delayFillBetweenRange"), // NOVO: ID para PREENCHIMENTO
    delayFillBetweenNum: document.getElementById("delayFillBetweenNum"), // NOVO: ID para PREENCHIMENTO
    delayAfterRange: document.getElementById("delayAfterRange"),
    delayAfterNum: document.getElementById("delayAfterNum"),
    instrumentSelector: document.getElementById("instrumentSelector"),
    delayTonicSecretRange: document.getElementById("delayTonicSecretRange"),
    delayTonicSecretNum: document.getElementById("delayTonicSecretNum"),
    fillNotesNum: document.getElementById("fillNotesNum"), 
};

function populateInitialRootNoteSelect() {
    const select = DOM.initialRootNoteSelect;
    select.innerHTML = '';
    NOTE_NAMES_BASE.forEach(note => {
        const option = document.createElement('option');
        option.value = note;
        option.textContent = note;
        if (note === 'C') option.selected = true;
        select.appendChild(option);
    });
}


/* ============================
    Convers√µes e utilit√°rios musicais
    ============================ */
function letterToScientific(letter, octave){
    if (letter === "C(6)") {
        const targetOctave = Math.min(6, octave + 1);
        return "C" + targetOctave;
    }
    return letter + octave;
}

function midiToScientific(m){
    const idx = ((m%12)+12)%12;
    const oct = Math.floor(m/12)-1;
    return NOTE_NAMES_BASE[idx] + oct;
}

function scientificToABC(sci){
    const m = sci.match(/^([A-G])(#|b)?(-?\d+)$/);
    if(!m) return sci;
    const letter=m[1], acc=m[2]||"", oct=parseInt(m[3],10);
    const accToken = acc==="#" ? "^" : (acc==="b" ? "_" : "");
    let base;
    if(oct>4){
        base = letter.toLowerCase();
        if(oct>5) base += "'".repeat(oct-5);
    } else if(oct<4){
        base = letter.toUpperCase() + ",".repeat(4-oct);
    } else base = letter.toUpperCase();
    return accToken + base;
}

function generateModeScaleMidi(root, modo, octave){
    const rootIdx = NOTE_NAMES_BASE.indexOf(root);
    const tonicMidi = 12*(octave + 1) + rootIdx;
    const pattern = MODOS[modo] || [];
    const midis = pattern.map(i => tonicMidi + i);
    return { midis, tonicMidi };
}

function buildSequenceForSecret(selectedNoteName, scaleData, dir, baseOctave){
    const { midis, tonicMidi } = scaleData;
    const tonicAbove = tonicMidi + 12;

    let targetMidi;

    if (selectedNoteName === "C(6)") {
        targetMidi = tonicAbove; 
    } else {
        const rootIdx = NOTE_NAMES_BASE.indexOf(selectedNoteName);
        targetMidi = 12 * (baseOctave + 1) + rootIdx;
        
        let foundMidi = midis.find(m => ((m % 12) === (targetMidi % 12)));
        if (foundMidi === undefined) {
             targetMidi = 12 * (baseOctave + 1) + rootIdx;
        } else {
            targetMidi = foundMidi;
        }
    }

    let fullScaleMidis = [];
    midis.forEach(m => fullScaleMidis.push(m - 12));
    fullScaleMidis = fullScaleMidis.concat(midis);
    midis.forEach(m => fullScaleMidis.push(m + 12));
    fullScaleMidis = [...new Set(fullScaleMidis)].sort((a,b) => a-b);
    
    if(!fullScaleMidis.includes(targetMidi)) {
        fullScaleMidis.push(targetMidi);
        fullScaleMidis.sort((a,b) => a-b);
    }

    const targetIndex = fullScaleMidis.indexOf(targetMidi);
    if(targetIndex === -1){
        return { seq: [targetMidi], isDouble: false }; 
    }

    function buildSimpleSequence(startMidi, direction) {
        const startIndex = fullScaleMidis.indexOf(startMidi);
        if (startIndex === -1) return [startMidi];

        let sequence = [startMidi];
        
        if (direction === "asc") {
            let nextTonic = tonicAbove;
            while (nextTonic < startMidi) { nextTonic += 12; }
            
            for(let i = startIndex + 1; i < fullScaleMidis.length; i++){
                const midi = fullScaleMidis[i];
                sequence.push(midi);
                if(midi >= nextTonic) {
                    if (midi > nextTonic) { 
                        sequence.pop();
                        sequence.push(nextTonic);
                    }
                    break;
                }
            }
        } else { // desc
            let nextTonic = tonicMidi;
            while (nextTonic > startMidi) { nextTonic -= 12; }
            
            for(let i = startIndex - 1; i >= 0; i--){
                const midi = fullScaleMidis[i];
                sequence.push(midi);
                if(midi <= nextTonic) {
                       if (midi < nextTonic) {
                        sequence.pop();
                        sequence.push(nextTonic);
                    }
                    break;
                }
            }
        }
        return sequence;
    }
    
    if (dir === "desc" || dir === "asc") {
        return { seq: buildSimpleSequence(targetMidi, dir), isDouble: false };
    } 
    
    // CORRE√á√ÉO: L√≥gica para Sequ√™ncias Duplas (Nota Secreta REPETIDA no ponto de invers√£o)
    if (dir === "both_desc_asc") {
        const descSeq = buildSimpleSequence(targetMidi, "desc"); 
        const ascSeq = buildSimpleSequence(targetMidi, "asc");  
        
        // Concatena a sequ√™ncia decrescente e a ascendente,
        // garantindo que a nota TargetMidi (G no exemplo) seja repetida no ponto de inflex√£o.
        return { seq: [...descSeq, ...ascSeq], isDouble: true };
    } 
    
    if (dir === "both_asc_desc") {
        const ascSeq = buildSimpleSequence(targetMidi, "asc");  
        const descSeq = buildSimpleSequence(targetMidi, "desc"); 
        
        // Concatena a sequ√™ncia ascendente e a decrescente,
        // garantindo que a nota TargetMidi (G no exemplo) seja repetida no ponto de inflex√£o.
        return { seq: [...ascSeq, ...descSeq], isDouble: true };
    }

    return { seq: [targetMidi], isDouble: false }; 
}

function getNotesFromMode(root, modo, octave) {
    const { midis } = generateModeScaleMidi(root, modo, octave);
    const uniqueNoteNames = midis.map(m => NOTE_NAMES_BASE[((m%12)+12)%12]);
    return [...new Set(uniqueNoteNames)];
}

function midisToABCTokens(midis){
    return midis.map(m => scientificToABC(midiToScientific(m))).join(" ");
}

function renderABC(tokens, key, initialRoot){
    let abcTokens = tokens;
    const isDouble = DOM.direcaoSelect.value.startsWith('both');
    
    let preSequence = [];

    const initialNoteSci = letterToScientific(initialRoot, state.secretNoteOctave);
    const initialNoteABC = scientificToABC(initialNoteSci);
    const secretNoteSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
    const secretNoteABC = scientificToABC(secretNoteSci);
    
    let fillTokens = "";
    if (state.fillNotes > 0) {
        // Usamos 'X' para indicar notas n√£o especificadas na partitura
        // A dura√ß√£o √© ajustada para 16n para o preenchimento (assumindo que o delay √© curto)
        fillTokens = Array(state.fillNotes).fill('X').join(" ");
    }
    
    if (state.playTonic) {
        preSequence.push(`[L:1/2] ${initialNoteABC}`); // T√¥nica
        if (fillTokens) preSequence.push(`[L:1/16] ${fillTokens}`); // Preenchimento
        preSequence.push(`[L:1/2] ${secretNoteABC}`); // Nota Secreta
    } else {
        preSequence.push(`[L:1/2] ${secretNoteABC}`); // Nota Secreta
    }
    
    // L√≥gica de Partitura para Sequ√™ncias Duplas (para adicionar o |:)
    let sequenceTokens = "";
    if (tokens) {
        if(isDouble) {
            const targetToken = scientificToABC(letterToScientific(state.currentSecretNote, state.secretNoteOctave));
            const seqArray = tokens.split(" ");
            
            // Procura o ponto de repeti√ß√£o da nota secreta (inflex√£o)
            let inversionIndex = -1;
            for(let i = 1; i < seqArray.length; i++) {
                if (seqArray[i] === targetToken) {
                    inversionIndex = i;
                    break;
                }
            }
            
            if (inversionIndex !== -1) {
                // Se for encontrado, coloca o s√≠mbolo de repeti√ß√£o na partitura
                const part1 = seqArray.slice(0, inversionIndex).join(" "); // Antes da repeti√ß√£o
                const part2 = seqArray.slice(inversionIndex).join(" ");   // Da repeti√ß√£o em diante
                sequenceTokens = `[L:1/4] ${part1} |: ${part2}`;
            } else {
                 sequenceTokens = `[L:1/4] ${tokens}`;
            }

        } else {
            sequenceTokens = `[L:1/4] ${tokens}`;
        }
    }

    const abc = `X:1\nL:1/4\nK:${key}\n%%MIDI program ${currentMidiProgram}\n${preSequence.join(" ")} | ${sequenceTokens}`;

    try {
        ABCJS.renderAbc("paper", abc);
    } catch(e){
        DOM.paperEl.innerHTML = "<div style='color:#c62828;font-weight:700;padding:8px;'>Erro ao renderizar partitura.</div>";
        console.error("ABCJS render error", e);
    }
}

/* ============================
    √ÅUDIO: tocar nota
    ============================ */

/** * Fun√ß√£o auxiliar para delay com async/await */
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

/** * Tenta iniciar o contexto de √°udio se ainda n√£o estiver rodando (resolve autoplay policy) */
async function ensureAudioContextRunning() {
    if (Tone.context.state !== 'running') {
        try {
            await Tone.start();
            return true;
        } catch (e) {
            console.error("Falha ao iniciar √°udio:", e);
            return false;
        }
    }
    return true;
}

function playNoteScientific(sci, dur="8n"){
    if (!instrument) return false;
    
    try {
        // Usa Tone.now() para agendamento preciso se o transporte estiver ativo
        const time = Tone.context.state === 'running' ? Tone.now() : undefined; 
        instrument.triggerAttackRelease(sci, dur, time);
        return true;
    } catch (error) {
        console.error("Erro ao tocar nota:", sci, error);
        return false;
    }
}

// Toca sequ√™ncia (array de scientific strings), respeitando delayBetweenSequence (ms)
async function playScientificSequence(scientificNotes) {
    if (!await ensureAudioContextRunning()) return; 

    // USA O CONTROLE ESPEC√çFICO DA SEQU√äNCIA
    const delayBetween = parseInt(DOM.delayBetweenSequenceNum.value, 10); 
    const noteDuration = instrumentType === 'synth' ? "8n" : (delayBetween > 200 ? "4n" : "8n"); 
    
    for(let i = 0; i < scientificNotes.length; i++) {
        if(!state.playing) break;
        const note = scientificNotes[i];
        playNoteScientific(note, noteDuration);
        if(i < scientificNotes.length - 1) {
          await delay(delayBetween);
        }
    }
}

function playHiddenScientific(sci){
    const dur = instrumentType === 'synth' ? "4n" : "2n";
    playNoteScientific(sci, dur); 
}

// Toca as notas de preenchimento
async function playFillNotes(count, scaleNotes, delayBetween){
    if (count <= 0) return;
    
    const fillNotesMidis = scaleNotes.midis;
    const notesToPlay = [];

    for(let i = 0; i < count; i++) {
        const randomMidi = fillNotesMidis[Math.floor(Math.random() * fillNotesMidis.length)];
        notesToPlay.push(midiToScientific(randomMidi));
    }

    // Dura√ß√£o fixa e curta para as notas de preenchimento. 
    const noteDuration = instrumentType === 'synth' ? "16n" : "8n"; 
    
    for(let i = 0; i < notesToPlay.length; i++) {
        if(!state.playing) break;
        playNoteScientific(notesToPlay[i], noteDuration);
        // Usa o delay espec√≠fico do preenchimento
        if(i < notesToPlay.length - 1) {
          await delay(delayBetween); 
        }
    }
}


/* ============================
    UI helpers (placar, bot√µes) 
    ============================ */
function updateScoreboard(){
    DOM.correctCount.textContent = state.score.correct;
    DOM.attemptCount.textContent = state.score.attempts;
}

function resetScore(){
    state.score = { correct:0, attempts:0 };
    updateScoreboard();
}

function updateResponseButtons(){
    const opts = Array.from(DOM.notasSelect.selectedOptions).map(o => o.value);
    DOM.noteButtonsDiv.innerHTML = "";
    if(opts.length === 0){
        DOM.statusEl.textContent = "Selecione notas para aparecerem como bot√µes de resposta.";
        return;
    }
    opts.forEach(n => {
        const b = document.createElement("button");
        b.type = "button";
        
        // NOVO: Adiciona a tecla correspondente ao texto do bot√£o
        let keyText = "";
        for (const [key, note] of Object.entries(KEYBOARD_MAP)) {
            if (note === n) {
                keyText = ` (${key})`;
                break;
            }
        }
        b.textContent = n + keyText;
        b.dataset.note = n;
        b.onclick = onGuess;
        DOM.noteButtonsDiv.appendChild(b);
    });
    updateUIState();
}

function updateUIState(){
    const isInstrumentReady = instrument && (instrumentType === 'synth' || instrument.loaded);
    DOM.btnStart.disabled = state.playing || !isInstrumentReady;
    DOM.btnStop.disabled = !state.playing;
    DOM.btnRepeat.disabled = !(state.playing && state.awaitingGuess);
    
    const configDisabled = state.playing && !state.awaitingGuess;
    DOM.notasSelect.disabled = configDisabled;
    DOM.tomSelect.disabled = configDisabled;
    DOM.modoSelect.disabled = configDisabled;
    DOM.direcaoSelect.disabled = configDisabled;
    DOM.oitavaSelect.disabled = configDisabled || state.currentSecretNote === 'C(6)';
    DOM.playTonicBefore.disabled = configDisabled;
    DOM.playSequenceAfterGuess.disabled = configDisabled; 
    DOM.autoAdvance.disabled = configDisabled;
    
    DOM.randomizeInitialRoot.disabled = configDisabled;
    const isRandom = DOM.randomizeInitialRoot.checked;
    DOM.initialRootNoteSelect.disabled = configDisabled || isRandom;
    DOM.initialRootNoteSource.disabled = configDisabled || !isRandom;
    
    DOM.instrumentSelector.disabled = configDisabled; 
    
    DOM.delayTonicSecretRange.disabled = configDisabled;
    DOM.delayTonicSecretNum.disabled = configDisabled;
    DOM.fillNotesNum.disabled = configDisabled;
    
    DOM.delayBetweenSequenceRange.disabled = configDisabled; // Controle da SEQU√äNCIA
    DOM.delayBetweenSequenceNum.disabled = configDisabled; // Controle da SEQU√äNCIA
    
    const isFillActive = parseInt(DOM.fillNotesNum.value, 10) > 0;
    DOM.delayFillBetweenRange.disabled = configDisabled || !isFillActive; // NOVO: Controle do PREENCHIMENTO
    DOM.delayFillBetweenNum.disabled = configDisabled || !isFillActive; // NOVO: Controle do PREENCHIMENTO

    DOM.delayAfterRange.disabled = configDisabled;
    DOM.delayAfterNum.disabled = configDisabled;

    const answerButtons = DOM.noteButtonsDiv.querySelectorAll("button");
    answerButtons.forEach(b => {
        b.disabled = !state.awaitingGuess;
        if (state.awaitingGuess) {
            b.classList.remove("correct", "wrong");
        }
    });
}

/* ============================
    Fluxo principal
    ============================ */

async function startRound(){
    const isInstrumentReady = instrument && (instrumentType === 'synth' || instrument.loaded);
    if(state.playing || !isInstrumentReady) return;
    
    const selOpts = Array.from(DOM.notasSelect.selectedOptions);
    if(selOpts.length === 0){
        alert("Selecione pelo menos uma nota!");
        return;
    }

    // REFOR√áO: Inicia o contexto de √°udio com o clique do bot√£o
    if (!await ensureAudioContextRunning()) return;

    state.playing = true;
    state.selectedNotes = selOpts.map(o => o.value);
    state.keyRoot = DOM.tomSelect.value;
    state.randomizeInitialRoot = DOM.randomizeInitialRoot.checked;
    state.initialRootSource = DOM.initialRootNoteSource.value;
    state.modoAtual = DOM.modoSelect.value;
    state.direction = DOM.direcaoSelect.value;
    state.secretNoteOctave = parseInt(DOM.oitavaSelect.value, 10);
    state.playTonic = DOM.playTonicBefore.checked;
    state.fillNotes = parseInt(DOM.fillNotesNum.value, 10); 

    DOM.paperEl.innerHTML = "";
    DOM.statusEl.textContent = "Treino ativo ‚Äî tocando notas...";
    DOM.statusEl.className = "status-awaiting";
    updateUIState();

    await playNextNote();
}

function stopAll(){
    state.playing = false;
    state.awaitingGuess = false;
    state.currentSecretNote = null;
    if(state.pendingTimeout) {
        clearTimeout(state.pendingTimeout);
        state.pendingTimeout = null;
    }
    DOM.paperEl.innerHTML = "";
    DOM.statusEl.textContent = "Parado.";
    DOM.statusEl.className = "status-default";
    updateUIState();
}

async function playNextNote() {
    if(!state.playing) return;

    state.currentSecretNote = state.selectedNotes[Math.floor(Math.random() * state.selectedNotes.length)];
    const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
    
    if (state.randomizeInitialRoot) {
        let possibleRoots = [];
        if (state.initialRootSource === 'chromatic') {
            possibleRoots = NOTE_NAMES_BASE;
        } else { 
            possibleRoots = getNotesFromMode(state.keyRoot, state.modoAtual, 4);
            if (possibleRoots.length === 0) possibleRoots = NOTE_NAMES_BASE;
        }
        state.initialRoot = possibleRoots[Math.floor(Math.random() * possibleRoots.length)];
    } else {
        state.initialRoot = DOM.initialRootNoteSelect.value; 
    }
    const initialRootSci = letterToScientific(state.initialRoot, state.secretNoteOctave); 

    state.awaitingGuess = true;
    state.lastGuess = null;

    DOM.oitavaSelect.disabled = state.currentSecretNote === "C(6)";

    if (DOM.autoAdvance.checked) {
        DOM.statusEl.textContent = "üéß Modo Autom√°tico: Tocando nota oculta. Aguarde a sequ√™ncia...";
    } else {
        DOM.statusEl.textContent = "üéß Modo Manual: Ou√ßa a nota oculta. Clique ou pressione a tecla correspondente.";
    }
    DOM.statusEl.className = "status-awaiting";
    DOM.paperEl.innerHTML = "";

    const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
    allButtons.forEach(btn => {
        btn.classList.remove("correct", "wrong");
    });

    await delay(100);
    
    const scaleData = generateModeScaleMidi(state.keyRoot, state.modoAtual, state.secretNoteOctave);
    const delayTonicSecret = parseInt(DOM.delayTonicSecretNum.value, 10) || 0; 
    const delayBetweenFill = parseInt(DOM.delayFillBetweenNum.value, 10) || 0; 

    if(state.playTonic){
        playHiddenScientific(initialRootSci);
        
        if (state.fillNotes > 0) {
            await playFillNotes(state.fillNotes, scaleData, delayBetweenFill);
        }
        
        await delay(delayTonicSecret);
    }

    playHiddenScientific(secretSci);

    updateUIState();

    if (DOM.autoAdvance.checked) {
        const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
        const waitTime = instrumentType === 'synth' ? 500 : 1000;
        await delay(waitTime + delayBefore); // Usa o delay
        if (state.playing) {
            DOM.statusEl.textContent = "üéµ Modo Autom√°tico: Tocando sequ√™ncia...";
            autoAdvanceSequence();
        }
    }
}

/* Avan√ßa automaticamente (simula acerto) */
async function autoAdvanceSequence() {
    if(!state.playing) return;

    state.awaitingGuess = false;
    state.lastGuess = state.currentSecretNote;
    state.score.attempts++;
    state.score.correct++;
    updateScoreboard();
    updateUIState();

    const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

    if (DOM.playSequenceAfterGuess.checked) {
        let modeToGenerate = state.modoAtual;
        if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

        const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, state.secretNoteOctave);
        const { seq: seqMidis } = buildSequenceForSecret(state.currentSecretNote, scaleData, state.direction, state.secretNoteOctave); 
        const scientificSeq = seqMidis.map(m => midiToScientific(m));
        const abcTokens = midisToABCTokens(seqMidis);

        DOM.paperEl.innerHTML = "";
        renderABC(abcTokens, state.keyRoot, state.initialRoot);

        DOM.statusEl.textContent = "üéµ Modo Autom√°tico: Tocando sequ√™ncia...";
        DOM.statusEl.className = "status-correct";
        
        await playScientificSequence(scientificSeq); // playScientificSequence usa delayBetweenSequenceNum
    } else {
        DOM.statusEl.textContent = "‚úÖ Acertou! Avan√ßando...";
        DOM.statusEl.className = "status-correct";
        DOM.paperEl.innerHTML = "";
    }
    
    if(state.playing) {
        state.pendingTimeout = setTimeout(async () => {
            state.pendingTimeout = null;
            if(state.playing) {
                await playNextNote();
            }
        }, delayAfter);
    }
}

/* repetir nota oculta */
async function repeatNote(){
    if(!state.awaitingGuess || !state.currentSecretNote){
        DOM.statusEl.textContent = "Nenhuma nota ativa para repetir.";
        return;
    }
    
    // REFOR√áO: Inicia/Resume o contexto de √°udio com o clique do bot√£o
    if (!await ensureAudioContextRunning()) return;

    const initialRootSci = letterToScientific(state.initialRoot, state.secretNoteOctave); 
    const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
    const waitTime = instrumentType === 'synth' ? 500 : 1000;
    const delayTonicSecret = parseInt(DOM.delayTonicSecretNum.value, 10) || 0;
    const delayBetweenFill = parseInt(DOM.delayFillBetweenNum.value, 10) || 0; 
    const scaleData = generateModeScaleMidi(state.keyRoot, state.modoAtual, state.secretNoteOctave);

    if(state.playTonic){
        playHiddenScientific(initialRootSci);
        
        if (state.fillNotes > 0) {
            await playFillNotes(state.fillNotes, scaleData, delayBetweenFill);
        }

        await delay(delayTonicSecret + waitTime); // Usa a nova fun√ß√£o de delay
        if(state.playing) playHiddenScientific(secretSci);
    } else {
        playHiddenScientific(secretSci);
    }
}

/* quando usu√°rio clica em uma nota (tenta adivinhar) - SOMENTE MODO MANUAL */
async function onGuess(e){
    // Se a chamada for de um evento de teclado (e n√£o um clique de bot√£o), o 'e' ser√° o objeto de evento do teclado.
    const guessedNote = e.target.dataset ? e.target.dataset.note : e.guessedNote;
    
    if(!state.awaitingGuess || !state.playing || DOM.autoAdvance.checked || !guessedNote) return;

    // REFOR√áO: Inicia/Resume o contexto de √°udio com o clique do bot√£o
    if (!await ensureAudioContextRunning()) return;

    state.awaitingGuess = false;
    state.lastGuess = guessedNote;
    state.score.attempts++;
    updateScoreboard();
    updateUIState();

    const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
    allButtons.forEach(btn => {
        if(btn.dataset.note === guessedNote) {
            btn.classList.add(guessedNote === state.currentSecretNote ? "correct" : "wrong");
        }
        if(btn.dataset.note === state.currentSecretNote && guessedNote !== state.currentSecretNote) {
            btn.classList.add("correct");
        }
    });

    const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
    const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

    if(guessedNote === state.currentSecretNote){
        state.score.correct++;
        updateScoreboard();

        let sequenceWasPlayed = false; 

        if (DOM.playSequenceAfterGuess.checked) {
            let modeToGenerate = state.modoAtual;
            if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

            const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, state.secretNoteOctave);
            const { seq: seqMidis } = buildSequenceForSecret(state.currentSecretNote, scaleData, state.direction, state.secretNoteOctave);
            const scientificSeq = seqMidis.map(m => midiToScientific(m));
            const abcTokens = midisToABCTokens(seqMidis);

            DOM.paperEl.innerHTML = "";
            renderABC(abcTokens, state.keyRoot, state.initialRoot);

            DOM.statusEl.textContent = "‚úÖ Acertou! Preparando para tocar a sequ√™ncia...";
            DOM.statusEl.className = "status-correct";

            // 1. Atraso ANTES da sequ√™ncia (se configurado)
            if(delayBefore > 0) {
                await delay(delayBefore); 
            }

            if(state.playing) { 
                DOM.statusEl.textContent = "üéµ Tocando sequ√™ncia...";
                // 2. Toca a sequ√™ncia e AGUARDA
                await playScientificSequence(scientificSeq); 
                sequenceWasPlayed = true; // Define a flag
                DOM.statusEl.textContent = "‚úÖ Acertou! Sequ√™ncia tocada. Avan√ßando...";
            }
        } else {
            DOM.statusEl.textContent = "‚úÖ Acertou! Avan√ßando...";
            DOM.statusEl.className = "status-correct";
            DOM.paperEl.innerHTML = "";
        }
        
        // 3. Atraso M√çNIMO AP√ìS a sequ√™ncia (para garantir o fim da nota)
        if (sequenceWasPlayed) {
             const minDelay = instrumentType === 'synth' ? 100 : 200; 
             await delay(minDelay); 
        }

        // 4. Agendamento da pr√≥xima rodada com o delayAfter
        if(state.pendingTimeout) {
            clearTimeout(state.pendingTimeout);
            state.pendingTimeout = null;
        }

        if(state.playing) {
            state.pendingTimeout = setTimeout(async () => {
                state.pendingTimeout = null;
                if(state.playing) {
                    await playNextNote();
                }
            }, delayAfter);
        }

    } else {
        // --- L√≥gica de ERRO ---
        DOM.statusEl.textContent = `‚ùå Errado ‚Äî a nota correta era ${state.currentSecretNote}.`;
        DOM.statusEl.className = "status-wrong";
        
        if (DOM.playSequenceAfterGuess.checked) {
            let modeToGenerate = state.modoAtual;
            if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";
            const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, state.secretNoteOctave);
            const { seq: seqMidis } = buildSequenceForSecret(state.currentSecretNote, scaleData, state.direction, state.secretNoteOctave);
            const abcTokens = midisToABCTokens(seqMidis);
            renderABC(abcTokens, state.keyRoot, state.initialRoot);
        }

        // Garante que o timer anterior seja limpo
        if(state.pendingTimeout) {
            clearTimeout(state.pendingTimeout);
            state.pendingTimeout = null;
        }

        if(state.playing) {
            // No erro, o delay √© fixo em 3 segundos para dar tempo de visualizar a partitura/erro.
            state.pendingTimeout = setTimeout(async () => {
                state.pendingTimeout = null;
                if(state.playing) {
                    await playNextNote();
                }
            }, 3000); 
        }
    }
}

/* ============================
    Eventos
    ============================ */

DOM.btnStart.addEventListener("click", startRound);
DOM.btnStop.addEventListener("click", stopAll);
DOM.btnRepeat.addEventListener("click", repeatNote);

// REFOR√áO DE √ÅUDIO: Qualquer intera√ß√£o inicial na p√°gina tenta ligar o √°udio.
document.addEventListener("mousedown", ensureAudioContextRunning);
document.addEventListener("touchstart", ensureAudioContextRunning);
document.addEventListener("keydown", ensureAudioContextRunning);


document.getElementById("selAllBtn").addEventListener("click", () => {
    Array.from(DOM.notasSelect.options).forEach(o => o.selected = true);
    updateResponseButtons();
});
document.getElementById("clearAllBtn").addEventListener("click", () => {
    Array.from(DOM.notasSelect.options).forEach(o => o.selected = false);
    updateResponseButtons();
});

DOM.notasSelect.addEventListener("change", updateResponseButtons);

DOM.randomizeInitialRoot.addEventListener("change", () => {
    state.randomizeInitialRoot = DOM.randomizeInitialRoot.checked;
    DOM.initialRootNoteSelect.disabled = DOM.randomizeInitialRoot.checked;
    DOM.initialRootNoteSource.disabled = !DOM.randomizeInitialRoot.checked;
    updateUIState();
});

DOM.initialRootNoteSource.addEventListener("change", () => {
    state.initialRootSource = DOM.initialRootNoteSource.value;
});

DOM.initialRootNoteSelect.addEventListener("change", () => {
    if (!state.randomizeInitialRoot) {
        state.initialRoot = DOM.initialRootNoteSelect.value;
    }
});

DOM.autoAdvance.addEventListener("change", () => {
    if (DOM.autoAdvance.checked && state.playing && state.awaitingGuess) {
        const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
        allButtons.forEach(btn => {
            if(btn.dataset.note === state.currentSecretNote) {
                btn.classList.add("correct");
            }
        });
        autoAdvanceSequence();
    }
    updateUIState();
});

DOM.instrumentSelector.addEventListener("change", (e) => {
    const programNum = parseInt(e.target.value, 10);
    loadInstrumentFromMIDIProgram(programNum);
});

DOM.fillNotesNum.addEventListener("input", () => {
    let v = parseInt(DOM.fillNotesNum.value, 10);
    if(isNaN(v)) v = 0;
    v = Math.max(0, Math.min(100, v)); 
    DOM.fillNotesNum.value = v;
    state.fillNotes = v;
    // Atualiza o estado da UI para habilitar/desabilitar o novo controle de delay de preenchimento
    updateUIState(); 
});


function syncRangeAndNum(rangeEl, numEl){
    rangeEl.addEventListener("input", () => {
        numEl.value = rangeEl.value;
    });
    numEl.addEventListener("input", () => {
        let v = parseInt(numEl.value, 10);
        if(isNaN(v)) v = parseInt(rangeEl.min,10);
        v = Math.max(parseInt(rangeEl.min,10), Math.min(parseInt(rangeEl.max,10), v));
        numEl.value = v;
        rangeEl.value = v;
    });
}

// Sincroniza√ß√£o de todos os controles de tempo
syncRangeAndNum(DOM.delayTonicSecretRange, DOM.delayTonicSecretNum);
syncRangeAndNum(DOM.delayBeforeRange, DOM.delayBeforeNum);
syncRangeAndNum(DOM.delayBetweenSequenceRange, DOM.delayBetweenSequenceNum); // SEQU√äNCIA
syncRangeAndNum(DOM.delayFillBetweenRange, DOM.delayFillBetweenNum); // PREENCHIMENTO (Novo)
syncRangeAndNum(DOM.delayAfterRange, DOM.delayAfterNum);


// NOVO: TRATAMENTO DE EVENTOS DO TECLADO
document.addEventListener("keydown", (e) => {
    // N√£o interfere com input fields
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
        return;
    }
    
    // Converte a tecla para a nota correspondente (em mai√∫sculas)
    const key = e.key.toUpperCase();
    const note = KEYBOARD_MAP[key];

    // Trata a tecla "Repetir Nota" (ex: Espa√ßo ou R)
    if (key === ' ' || key === 'R') {
        e.preventDefault();
        DOM.btnRepeat.click();
        return;
    }

    // Se encontrou uma nota mapeada
    if (note) {
        // Verifica se essa nota est√° na lista de bot√µes exibidos (notas selecionadas)
        const button = DOM.noteButtonsDiv.querySelector(`button[data-note="${note}"]`);

        if (button && state.awaitingGuess && !DOM.autoAdvance.checked) {
             e.preventDefault();
             
             // Cria um objeto de evento simulado para passar para onGuess
             const simulatedEvent = {
                target: button,
                guessedNote: note
             };
             
             onGuess(simulatedEvent);
        }
    }
});


document.addEventListener("DOMContentLoaded", () => {
    populateInitialRootNoteSelect();
    loadInstrumentFromMIDIProgram(0); 
    updateResponseButtons();
    updateScoreboard();
    updateUIState();
});
</script>
</body>
</html>
