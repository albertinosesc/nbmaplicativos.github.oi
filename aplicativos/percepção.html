<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Percep√ß√£o Auditiva</title>

  <script src="https://cdn.jsdelivr.net/npm/abcjs@6.4.2/dist/abcjs-basic-min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>
  <script src="https://unpkg.com/tonejs-instrument@1.1.0/lib/Tone.instrument.js"></script>


  <style>
/* Bloco CSS Completo */
body { font-family: Arial, Helvetica, sans-serif; background:#f7f9fb; padding:18px; max-width:1200px; margin:auto; }
h1 { text-align:center; color:#222; margin-bottom:6px; }
.controls { display:flex; gap:16px; flex-wrap:wrap; justify-content:center; margin-bottom:14px; }
.control { background:#fff; padding:14px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-width:240px; }
label strong { display:block; margin-bottom:6px; color:#333; }
select, button, input[type="number"], input[type="range"] { width:100%; padding:8px; border-radius:8px; border:1px solid #ccc; font-size:14px; box-sizing:border-box; }
button { cursor:pointer; }
#paper { margin:16px auto; width:100%; max-width:900px; background:#fff; padding:16px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-height:80px; }
#status { text-align:center; margin-top:12px; padding:8px; border-radius:8px; font-weight:700; }
.status-default { color:#444; background: none; }
.status-awaiting { color:#0d47a1; background:#e3f2fd; }
.status-correct { color:#fff; background:#2e7d32; }
.status-wrong { color:#fff; background:#c62828; }
.note-buttons { display:flex; gap:10px; justify-content:center; margin-top:16px; flex-wrap:wrap; }
.note-buttons button { padding:10px 14px; border-radius:8px; border:none; background:#1976d2; color:white; font-weight:700; min-width:56px; }
.note-buttons button:disabled { background:#cfd8dc; color:#666; cursor:not-allowed; }
.note-buttons button.correct { background:#2e7d32; }
.note-buttons button.wrong { background:#c62828; }
.small { font-size:13px; color:#555; margin-top:8px; }
.row { display:flex; gap:8px; align-items:center; }
.row > input[type="number"] { width:120px; flex:0 0 120px; }
.val { font-weight:700; margin-left:6px; }
#scoreboard { text-align:center; margin-bottom:10px; font-weight:700; color:#333; }
#scoreboard span { color:#1976d2; margin:0 6px; }
.select-actions { display:flex; gap:6px; margin-top:8px; }
.select-actions button { padding:6px 8px; font-size:13px; background:#efefef; border:1px solid #d0d0d0; cursor:pointer; }
.checkbox-row { display: flex; align-items: center; margin-top: 8px; }
.checkbox-row input[type="checkbox"] { margin-right: 8px; width: auto; }
@media (max-width:900px) { 
  .controls { flex-direction:column; } 
  .control { min-width:auto; } 
}
  </style>
</head>
<body>
  <h1>üéπ Treino de Percep√ß√£o Auditiva ‚Äî Modos e Escalas</h1>

  <div id="scoreboard">Acertos: <span id="correctCount">0</span> / Tentativas: <span id="attemptCount">0</span>
    <button onclick="resetScore()" style="margin-left:8px;padding:6px 10px;background:#c62828;color:white;border:none;border-radius:6px;cursor:pointer;" type="button">Limpar Placar</button>
  </div>

  <div class="controls">
        <div class="control">
      <label><strong>Notas poss√≠veis (respostas)</strong></label>
      <select id="notas" multiple size="13">
        <option value="C" selected>C</option><option value="C#" selected>C#</option><option value="D" selected>D</option><option value="D#" selected>D#</option>
        <option value="E" selected>E</option><option value="F" selected>F</option><option value="F#" selected>F#</option><option value="G" selected>G</option>
        <option value="G#" selected>G#</option><option value="A" selected>A</option><option value="A#" selected>A#</option><option value="B" selected>B</option>
        <option value="C(6)" selected>C (Oitava Acima)</option> 
      </select>
      <div class="select-actions">
        <button id="selAllBtn" type="button">Selecionar Todas</button>
        <button id="clearAllBtn" type="button">Limpar Sele√ß√£o</button>
      </div>
      <div class="small">Somente notas selecionadas aparecem nos bot√µes de resposta (modo manual).</div>
    </div>

        <div class="control">
      <label><strong>T√¥nica da Sequ√™ncia (Escala)</strong></label>
      <select id="tom">
        <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#" >D#</option>
        <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
        <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
      </select>

      <label style="margin-top:8px"><strong>T√¥nica do Intervalo (1¬™ Nota)</strong></label>
      <div class="checkbox-row" style="margin-bottom: 8px;">
        <input type="checkbox" id="randomizeInitialRoot">
        <label for="randomizeInitialRoot" style="margin:0; font-weight:normal;">T√¥nica Aleat√≥ria a cada Rodada</label>
      </div>

      <label style="margin-top:8px"><strong>Notas Aleat√≥rias (Origem)</strong></label>
      <select id="initialRootNoteSource" disabled>
          <option value="chromatic">Escala Crom√°tica (Todas as 12)</option>
          <option value="mode">Escala do Modo Selecionado</option>
      </select>

      <select id="initialRootNote">
        <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
        <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
        <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
      </select>

      <label style="margin-top:8px"><strong>Oitava da nota secreta</strong></label>
      <select id="oitava">
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
      </select>

      <label style="margin-top:8px"><strong>Modo / Escala</strong></label>
      <select id="modo">
        <option value="ionian">J√¥nio (Maior)</option>
        <option value="dorian">D√≥rico</option>
        <option value="phrygian">Fr√≠gio</option>
        <option value="lydian">L√≠dio</option>
        <option value="mixolydian">Mixol√≠dio</option>
        <option value="aeolian">Menor Natural (E√≥lio)</option>
        <option value="harmonic_minor">Menor Harm√¥nica</option>
        <option value="melodic_minor">Menor Mel√≥dica (asc)</option>
        <option value="locrian">L√≥crio</option>
        <option value="chromatic">Crom√°tica</option>
      </select>

      <label style="margin-top:8px"><strong>Dire√ß√£o</strong></label>
      <select id="direcao">
        <option value="asc">Ascendente</option>
        <option value="desc">Descendente</option>
      </select>

    </div>

        <div class="control">
      <label><strong>Controles</strong></label>
      <button id="btnStart" style="background:#2e7d32;color:white;margin-bottom:8px;" type="button">‚ñ∂ Iniciar Treino</button>
      <button id="btnStop" style="background:#e53935;color:white;margin-bottom:8px;" type="button">‚èπ Parar</button>
      <button id="btnRepeat" style="background:#6a1b9a;color:white;margin-bottom:8px;" disabled type="button">üîÅ Ouvir Nota Novamente</button>
      
      <label style="margin-top:8px"><strong>Tocar t√¥nica antes da nota oculta</strong></label>
      <div class="checkbox-row">
        <input type="checkbox" id="playTonicBefore" checked>
        <label for="playTonicBefore" style="margin:0; font-weight:normal;">Ativado (Toca T√¥nica do Intervalo)</label>
      </div>

          <label style="margin-top:8px"><strong>Avan√ßar Automaticamente</strong></label>
      <div class="checkbox-row">
        <input type="checkbox" id="autoAdvance">
        <label for="autoAdvance" style="margin:0; font-weight:normal;">Avan√ßar p/ pr√≥xima nota ap√≥s sequ√™ncia (sem palpite)</label>
      </div>

      <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">
      
      <label style="margin-top:8px"><strong>Timbre do Instrumento</strong></label>
      <select id="instrumentSelector">
        <option value="0" selected>0 - Piano Ac√∫stico</option>
        <option value="25">25 - Viol√£o (Guitarra Nylon)</option>
        <option value="40">40 - Violino</option>
        <option value="56">56 - Trompete</option>
        <option value="73">73 - Flauta</option>
      </select>
      <div class="small">Selecione o timbre. Ele ser√° carregado automaticamente.</div>
      <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">

          <label><strong>Tempo (Nota ‚Üí Sequ√™ncia)</strong></label>
      <div class="row">
        <input id="delayBeforeRange" type="range" min="0" max="3000" step="50" value="750">
        <input id="delayBeforeNum" type="number" min="0" max="3000" step="50" value="750">
      </div>

          <label style="margin-top:8px"><strong>Tempo (entre notas da sequ√™ncia)</strong></label>
      <div class="row">
        <input id="delayBetweenRange" type="range" min="25" max="1500" step="25" value="570">
        <input id="delayBetweenNum" type="number" min="25" max="1500" step="25" value="570">
      </div>

          <label style="margin-top:8px"><strong>Tempo (Sequ√™ncia ‚Üí Pr√≥xima Nota)</strong></label>
      <div class="row">
        <input id="delayAfterRange" type="range" min="0" max="5000" step="50" value="1100">
        <input id="delayAfterNum" type="number" min="0" max="5000" step="50" value="1100">
      </div>
      <div class="small">Voc√™ pode arrastar o slider ou digitar o valor num√©rico ‚Äî ambos sincronizados. O √∫ltimo slider controla o avan√ßo autom√°tico.</div>
    </div>
  </div>

  <div id="paper"></div>
  <div id="status" class="status-default">üéπ Carregando Piano Ac√∫stico...</div>
  <div class="note-buttons" id="noteButtons"></div>

<script>
/* ============================
   Dados e Configura√ß√µes
   ============================ */
const NOTE_NAMES_BASE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const NOTE_NAMES = [...NOTE_NAMES_BASE, "C(6)"];
const MODOS = {
  ionian:         [0,2,4,5,7,9,11],
  dorian:         [0,2,3,5,7,9,10],
  phrygian:       [0,1,3,5,7,8,10],
  lydian:         [0,2,4,6,7,9,11],
  mixolydian:     [0,2,4,5,7,9,10],
  aeolian:        [0,2,3,5,7,8,10],
  harmonic_minor: [0,2,3,5,7,8,11],
  melodic_minor:  [0,2,3,5,7,9,11], // ascendente
  locrian:        [0,1,3,5,6,8,10],
  chromatic:      [0,1,2,3,4,5,6,7,8,9,10,11]
};

// ** INSTRUMENTOS **
let instrument = null;
let instrumentType = 'sampler';
let currentMidiProgram = 0;

// Configura√ß√£o do Synth Simples (Fallback)
const simpleSynthConfig = {
  oscillator: { type: "sine" },
  envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
};

// ** CONFIGURA√á√ïES DE SINTETIZADOR PARA OS INSTRUMENTOS R√ÅPIDOS **
const SYNTH_PRESETS = {
    // 0: Piano (Tom mais percussivo, usando onda triangular complexa)
    0: { oscillator: { type: "triangle8" }, envelope: { attack: 0.005, decay: 0.3, sustain: 0.4, release: 0.8 } },
    
    // 25: Viol√£o (Guitarra Ac√∫stica de Nylon)
    25: { 
        oscillator: { type: "sawtooth" }, 
        envelope: { attack: 0.002, decay: 1.5, sustain: 0.0, release: 0.5, releaseCurve: 'linear' } 
    },

    // 40: Violino (AMSynth para adicionar complexidade)
    40: {
        synth: "AMSynth",
        oscillator: { type: "sawtooth" },
        modulation: { type: "square" },
        envelope: { attack: 0.1, decay: 0.8, sustain: 0.6, release: 1.2 }
    },
    // 56: Trompete (FMSynth para simular o brilho do brass)
    56: {
        synth: "FMSynth",
        harmonicity: 3.01,
        modulationIndex: 14,
        oscillator: { type: "sine" },
        envelope: { attack: 0.05, decay: 0.4, sustain: 0.6, release: 0.5 }
    },
    // 73: Flauta (Tom puro, usando envelope longo)
    73: { oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.9, sustain: 0.7, release: 1.5 } },
    
    // Outros: Padr√£o simples (seu "fallback" original)
    default: simpleSynthConfig 
};


/* ============================
   L√≥gica do Instrumento / Timbre
   ============================ */

/**
 * Carrega um Tone.Sampler para o MIDI Program especificado.
 * Se falhar, faz fallback para Tone.Synth usando um preset.
 * @param {number} programNumber - O n√∫mero MIDI Program (0-127).
 */
function loadInstrumentFromMIDIProgram(programNumber) {
    DOM.btnStart.disabled = true; // Desabilita o Start enquanto carrega
    DOM.instrumentSelector.disabled = true; // Desabilita o seletor enquanto carrega
    
    DOM.statusEl.textContent = `üéµ Tentando carregar timbre MIDI Program ${programNumber}...`;
    DOM.statusEl.className = "status-awaiting";

    if (instrument) {
        instrument.dispose();
        instrument = null;
    }
    
    currentMidiProgram = programNumber;
    
    // Sincroniza o seletor para garantir que a op√ß√£o correta esteja vis√≠vel
    DOM.instrumentSelector.value = programNumber;
    
    try {
        const instrumentUrls = Tone.Instrument.loadProgram(programNumber);

        if (!instrumentUrls) {
             console.warn(`N√£o h√° samples dispon√≠veis para o MIDI Program ${programNumber}. Fallback para Synth.`);
             fallbackToSimpleSynth();
             return;
        }

        // Tenta carregar o Sampler (som real)
        instrument = new Tone.Sampler({
            urls: instrumentUrls,
            onload: () => {
                instrument.toDestination();
                instrumentType = 'sampler';
                DOM.statusEl.textContent = `üéπ Timbre ${programNumber} (Sampler) pronto. Clique em 'Iniciar Treino'.`;
                DOM.btnStart.disabled = false;
                DOM.instrumentSelector.disabled = false; // Habilita o seletor
                DOM.statusEl.className = "status-default";
                updateUIState();
            },
            onerror: (error) => {
                console.error(`Erro ao carregar samples para ${programNumber}. Fallback para Synth.`, error);
                fallbackToSimpleSynth();
            }
        });
        
    } catch(e) {
        console.error("Erro ao inicializar Sampler. Fallback para Synth simples.", e);
        fallbackToSimpleSynth();
    }
}

/**
 * Faz o fallback para um Synth, usando um preset espec√≠fico para o MIDI Program.
 */
function fallbackToSimpleSynth() {
    if (instrument) {
        instrument.dispose();
        instrument = null;
    }

    const preset = SYNTH_PRESETS[currentMidiProgram] || SYNTH_PRESETS.default;
    let synthName = "Synth";

    if (preset.synth === "AMSynth") {
        instrument = new Tone.AMSynth(preset).toDestination();
        synthName = "AMSynth";
    } else if (preset.synth === "FMSynth") {
        instrument = new Tone.FMSynth(preset).toDestination();
        synthName = "FMSynth";
    } else {
        instrument = new Tone.Synth(preset).toDestination();
    }

    instrumentType = 'synth';
    DOM.statusEl.textContent = `üîä Sampler falhou. √Åudio Sintetizado (${synthName} - Program ${currentMidiProgram}) pronto.`;
    DOM.btnStart.disabled = false;
    DOM.instrumentSelector.disabled = false; // Habilita o seletor
    DOM.statusEl.className = "status-default";
    updateUIState();
}


/* ============================
   Dados e Estado
   ============================ */

const state = {
  playing: false,
  awaitingGuess: false,
  currentSecretNote: null,
  secretNoteOctave: 4,
  selectedNotes: [],
  keyRoot: "C", 
  initialRoot: "C",
  initialRootSource: "chromatic",
  modoAtual: "ionian",
  direction: "asc",
  playTonic: true,
  randomizeInitialRoot: false,
  score: { correct:0, attempts:0 },
  pendingTimeout: null,
  lastGuess: null
};

/* DOM refs */
const DOM = {
  btnStart: document.getElementById("btnStart"),
  btnStop: document.getElementById("btnStop"),
  btnRepeat: document.getElementById("btnRepeat"),
  autoAdvance: document.getElementById("autoAdvance"),
  statusEl: document.getElementById("status"),
  noteButtonsDiv: document.getElementById("noteButtons"),
  paperEl: document.getElementById("paper"),
  notasSelect: document.getElementById("notas"),
  tomSelect: document.getElementById("tom"),
  initialRootNoteSelect: document.getElementById("initialRootNote"),
  randomizeInitialRoot: document.getElementById("randomizeInitialRoot"),
  initialRootNoteSource: document.getElementById("initialRootNoteSource"),
  modoSelect: document.getElementById("modo"),
  direcaoSelect: document.getElementById("direcao"),
  oitavaSelect: document.getElementById("oitava"),
  playTonicBefore: document.getElementById("playTonicBefore"),
  correctCount: document.getElementById("correctCount"),
  attemptCount: document.getElementById("attemptCount"),
  delayBeforeRange: document.getElementById("delayBeforeRange"),
  delayBeforeNum: document.getElementById("delayBeforeNum"),
  delayBetweenRange: document.getElementById("delayBetweenRange"),
  delayBetweenNum: document.getElementById("delayBetweenNum"),
  delayAfterRange: document.getElementById("delayAfterRange"),
  delayAfterNum: document.getElementById("delayAfterNum"),
  instrumentSelector: document.getElementById("instrumentSelector")
};

// Popula o Select da T√¥nica do Intervalo
function populateInitialRootNoteSelect() {
    const select = DOM.initialRootNoteSelect;
    select.innerHTML = '';
    NOTE_NAMES_BASE.forEach(note => {
        const option = document.createElement('option');
        option.value = note;
        option.textContent = note;
        if (note === 'C') option.selected = true;
        select.appendChild(option);
    });
}


/* ============================
   Convers√µes e utilit√°rios musicais
   ============================ */
// Converte letras especiais para nota√ß√£o cient√≠fica
function letterToScientific(letter, octave){
  if (letter === "C(6)") {
    const targetOctave = Math.min(6, octave + 1);
    return "C" + targetOctave;
  }
  return letter + octave;
}

function midiToScientific(m){
  const idx = ((m%12)+12)%12;
  const oct = Math.floor(m/12)-1;
  return NOTE_NAMES_BASE[idx] + oct;
}

function scientificToABC(sci){
  const m = sci.match(/^([A-G])(#|b)?(-?\d+)$/);
  if(!m) return sci;
  const letter=m[1], acc=m[2]||"", oct=parseInt(m[3],10);
  const accToken = acc==="#" ? "^" : (acc==="b" ? "_" : "");
  let base;
  if(oct>4){
    base = letter.toLowerCase();
    if(oct>5) base += "'".repeat(oct-5);
  } else if(oct<4){
    base = letter.toUpperCase() + ",".repeat(4-oct);
  } else base = letter.toUpperCase();
  return accToken + base;
}

/** Gera a escala em midis com base na t√¥nica + modo, usando a oitava de refer√™ncia */
function generateModeScaleMidi(root, modo, octave){
  const rootIdx = NOTE_NAMES_BASE.indexOf(root);
  const tonicMidi = 12*(octave + 1) + rootIdx;
  const pattern = MODOS[modo] || [];
  const midis = pattern.map(i => tonicMidi + i);
  return { midis, tonicMidi };
}

/** Constr√≥i sequ√™ncia a partir da nota secreta e fecha na t√¥nica (superior ou inferior). */
function buildSequenceForSecret(selectedNoteName, scaleData, dir, baseOctave){
  const { midis, tonicMidi } = scaleData;
  const tonicAbove = tonicMidi + 12;

  let targetMidi;

  if (selectedNoteName === "C(6)") {
    targetMidi = tonicAbove; 
  } else {
    const rootIdx = NOTE_NAMES_BASE.indexOf(selectedNoteName);
    targetMidi = 12 * (baseOctave + 1) + rootIdx;
    
    let foundMidi = midis.find(m => ((m % 12) === (targetMidi % 12)));
    if (foundMidi === undefined) {
         targetMidi = 12 * (baseOctave + 1) + rootIdx;
    } else {
        targetMidi = foundMidi;
    }
  }

  let fullScaleMidis = [];
  midis.forEach(m => fullScaleMidis.push(m - 12));
  fullScaleMidis = fullScaleMidis.concat(midis);
  midis.forEach(m => fullScaleMidis.push(m + 12));
  fullScaleMidis = [...new Set(fullScaleMidis)].sort((a,b) => a-b);
  
  if(!fullScaleMidis.includes(targetMidi)) {
      fullScaleMidis.push(targetMidi);
      fullScaleMidis.sort((a,b) => a-b);
  }

  const targetIndex = fullScaleMidis.indexOf(targetMidi);
  if(targetIndex === -1){
    return [targetMidi]; 
  }

  let sequence = [];

  if(dir === "asc"){
    let nextTonic = tonicAbove;
    while (nextTonic < targetMidi) {
      nextTonic += 12;
    }
    
    for(let i = targetIndex; i < fullScaleMidis.length; i++){
      const midi = fullScaleMidis[i];
      sequence.push(midi);
      if(midi >= nextTonic) {
          if (midi > nextTonic) { 
              sequence.pop();
              sequence.push(nextTonic);
          }
          break;
      }
    }
  } else { // Descendente
    let nextTonic = tonicMidi;
    while (nextTonic > targetMidi) {
      nextTonic -= 12;
    }
    
    for(let i = targetIndex; i >= 0; i--){
      const midi = fullScaleMidis[i];
      sequence.push(midi);
      if(midi <= nextTonic) {
           if (midi < nextTonic) {
              sequence.pop();
              sequence.push(nextTonic);
          }
          break;
      }
    }
  }

  return sequence;
}

/** Obt√©m as notas em Scientific Notation de uma escala/modo */
function getNotesFromMode(root, modo, octave) {
    const { midis } = generateModeScaleMidi(root, modo, octave);
    const uniqueNoteNames = midis.map(m => NOTE_NAMES_BASE[((m%12)+12)%12]);
    return [...new Set(uniqueNoteNames)];
}

function midisToABCTokens(midis){
  return midis.map(m => scientificToABC(midiToScientific(m))).join(" ");
}

function renderABC(tokens, key, initialRoot){
  let abcTokens = tokens;
  
  if (state.playTonic) {
    const initialNoteSci = letterToScientific(initialRoot, state.secretNoteOctave);
    const initialNoteABC = scientificToABC(initialNoteSci);
    const secretNoteSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
    const secretNoteABC = scientificToABC(secretNoteSci);
    
    abcTokens = `[L:1/2] ${initialNoteABC} ${secretNoteABC} | [L:1/4] ${tokens}`;
    
  } else {
    const secretNoteSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
    const secretNoteABC = scientificToABC(secretNoteSci);
    abcTokens = `[L:1/2] ${secretNoteABC} | [L:1/4] ${tokens}`;
  }
  
  const abc = `X:1\nL:1/4\nK:${key}\n%%MIDI program ${currentMidiProgram}\n${abcTokens}`;
  try {
    ABCJS.renderAbc("paper", abc);
  } catch(e){
    DOM.paperEl.innerHTML = "<div style='color:#c62828;font-weight:700;padding:8px;'>Erro ao renderizar partitura.</div>";
    console.error("ABCJS render error", e);
  }
}

/* ============================
   √ÅUDIO: tocar nota
   ============================ */
function playNoteScientific(sci, dur="8n"){
  if (!instrument) return false;
  if (Tone.context.state !== 'running') {
     Tone.start().catch(e => console.error("Falha ao iniciar √°udio:", e));
  }
  
  if (!instrument) return false;
  try {
    instrument.triggerAttackRelease(sci, dur);
    return true;
  } catch (error) {
    console.error("Erro ao tocar nota:", sci, error);
    return false;
  }
}

// Toca sequ√™ncia (array de scientific strings), respeitando delayBetween (ms)
function playScientificSequence(scientificNotes) {
  return new Promise(async (resolve) => {
    const delayBetween = parseInt(DOM.delayBetweenNum.value, 10);
    const noteDuration = instrumentType === 'synth' ? "8n" : (delayBetween > 200 ? "4n" : "8n"); 
    
    for(let i = 0; i < scientificNotes.length; i++) {
      if(!state.playing) break;
      const note = scientificNotes[i];
      playNoteScientific(note, noteDuration);
      if(i < scientificNotes.length - 1) {
        await new Promise(r => setTimeout(r, delayBetween));
      }
    }
    resolve();
  });
}

function playHiddenScientific(sci){
  const dur = instrumentType === 'synth' ? "4n" : "2n";
  playNoteScientific(sci, dur); 
}

/* ============================
   UI helpers (placar, bot√µes)
   ============================ */
function updateScoreboard(){
  DOM.correctCount.textContent = state.score.correct;
  DOM.attemptCount.textContent = state.score.attempts;
}

function resetScore(){
  state.score = { correct:0, attempts:0 };
  updateScoreboard();
}

function updateResponseButtons(){
  const opts = Array.from(DOM.notasSelect.selectedOptions).map(o => o.value);
  DOM.noteButtonsDiv.innerHTML = "";
  if(opts.length === 0){
    DOM.statusEl.textContent = "Selecione notas para aparecerem como bot√µes de resposta.";
    return;
  }
  opts.forEach(n => {
    const b = document.createElement("button");
    b.type = "button";
    b.textContent = n;
    b.dataset.note = n;
    b.onclick = onGuess;
    DOM.noteButtonsDiv.appendChild(b);
  });
  updateUIState();
}

function updateUIState(){
  const isInstrumentReady = instrument && (instrumentType === 'synth' || instrument.loaded);
  DOM.btnStart.disabled = state.playing || !isInstrumentReady;
  DOM.btnStop.disabled = !state.playing;
  DOM.btnRepeat.disabled = !(state.playing && state.awaitingGuess);
  
  const configDisabled = state.playing && !state.awaitingGuess;
  DOM.notasSelect.disabled = configDisabled;
  DOM.tomSelect.disabled = configDisabled;
  DOM.modoSelect.disabled = configDisabled;
  DOM.direcaoSelect.disabled = configDisabled;
  DOM.oitavaSelect.disabled = configDisabled || state.currentSecretNote === 'C(6)';
  DOM.playTonicBefore.disabled = configDisabled;
  DOM.autoAdvance.disabled = configDisabled;
  
  DOM.randomizeInitialRoot.disabled = configDisabled;
  const isRandom = DOM.randomizeInitialRoot.checked;
  DOM.initialRootNoteSelect.disabled = configDisabled || isRandom;
  DOM.initialRootNoteSource.disabled = configDisabled || !isRandom;
  
  // O seletor de instrumento √© desabilitado apenas quando o treino est√° em andamento (tocando uma nota ou sequ√™ncia)
  DOM.instrumentSelector.disabled = configDisabled; 

  const answerButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  answerButtons.forEach(b => {
    b.disabled = !state.awaitingGuess;
    if (state.awaitingGuess) {
      b.classList.remove("correct", "wrong");
    }
  });
}

/* ============================
   Fluxo principal
   ============================ */

async function startRound(){
  const isInstrumentReady = instrument && (instrumentType === 'synth' || instrument.loaded);
  if(state.playing || !isInstrumentReady) return;
  
  const selOpts = Array.from(DOM.notasSelect.selectedOptions);
  if(selOpts.length === 0){
    alert("Selecione pelo menos uma nota!");
    return;
  }

  try {
    await Tone.start();
  } catch(e){
    console.warn("Falha ao iniciar √°udio:", e);
  }

  state.playing = true;
  state.selectedNotes = selOpts.map(o => o.value);
  state.keyRoot = DOM.tomSelect.value;
  state.randomizeInitialRoot = DOM.randomizeInitialRoot.checked;
  state.initialRootSource = DOM.initialRootNoteSource.value;
  state.modoAtual = DOM.modoSelect.value;
  state.direction = DOM.direcaoSelect.value;
  state.secretNoteOctave = parseInt(DOM.oitavaSelect.value, 10);
  state.playTonic = DOM.playTonicBefore.checked;

  DOM.paperEl.innerHTML = "";
  DOM.statusEl.textContent = "Treino ativo ‚Äî tocando notas...";
  DOM.statusEl.className = "status-awaiting";
  updateUIState();

  await playNextNote();
}

function stopAll(){
  state.playing = false;
  state.awaitingGuess = false;
  state.currentSecretNote = null;
  if(state.pendingTimeout) {
    clearTimeout(state.pendingTimeout);
    state.pendingTimeout = null;
  }
  DOM.paperEl.innerHTML = "";
  DOM.statusEl.textContent = "Parado.";
  DOM.statusEl.className = "status-default";
  updateUIState();
}

async function playNextNote() {
  if(!state.playing) return;

  state.currentSecretNote = state.selectedNotes[Math.floor(Math.random() * state.selectedNotes.length)];
  const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
  
  if (state.randomizeInitialRoot) {
    let possibleRoots = [];
    if (state.initialRootSource === 'chromatic') {
        possibleRoots = NOTE_NAMES_BASE;
    } else { 
        possibleRoots = getNotesFromMode(state.keyRoot, state.modoAtual, 4);
        if (possibleRoots.length === 0) possibleRoots = NOTE_NAMES_BASE;
    }
    state.initialRoot = possibleRoots[Math.floor(Math.random() * possibleRoots.length)];
  } else {
    state.initialRoot = DOM.initialRootNoteSelect.value; 
  }
  const initialRootSci = letterToScientific(state.initialRoot, state.secretNoteOctave); 

  state.awaitingGuess = true;
  state.lastGuess = null;

  DOM.oitavaSelect.disabled = state.currentSecretNote === "C(6)";

  if (DOM.autoAdvance.checked) {
    DOM.statusEl.textContent = "üéß Modo Autom√°tico: Tocando nota oculta. Aguarde a sequ√™ncia...";
  } else {
    DOM.statusEl.textContent = "üéß Modo Manual: Ou√ßa a nota oculta. Clique na nota que acha que foi.";
  }
  DOM.statusEl.className = "status-awaiting";
  DOM.paperEl.innerHTML = "";

  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  allButtons.forEach(btn => {
    btn.classList.remove("correct", "wrong");
  });

  await new Promise(r => setTimeout(r, 100));
  
  if(state.playTonic){
    playHiddenScientific(initialRootSci);
    await new Promise(r => setTimeout(r, 1000));
  }

  playHiddenScientific(secretSci);

  updateUIState();

  if (DOM.autoAdvance.checked) {
    const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
    const waitTime = instrumentType === 'synth' ? 500 : 1000;
    await new Promise(r => setTimeout(r, waitTime + delayBefore));
    if (state.playing) {
      DOM.statusEl.textContent = "üéµ Modo Autom√°tico: Tocando sequ√™ncia...";
      autoAdvanceSequence();
    }
  }
}

/* Avan√ßa automaticamente (simula acerto) */
async function autoAdvanceSequence() {
  if(!state.playing) return;

  state.awaitingGuess = false;
  state.lastGuess = state.currentSecretNote;
  state.score.attempts++;
  state.score.correct++;
  updateScoreboard();
  updateUIState();

  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

  let modeToGenerate = state.modoAtual;
  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, state.secretNoteOctave);
  const seqMidis = buildSequenceForSecret(state.currentSecretNote, scaleData, state.direction, state.secretNoteOctave);
  const scientificSeq = seqMidis.map(m => midiToScientific(m));
  const abcTokens = midisToABCTokens(seqMidis);

  DOM.paperEl.innerHTML = "";
  renderABC(abcTokens, state.keyRoot, state.initialRoot);

  DOM.statusEl.textContent = "üéµ Modo Autom√°tico: Tocando sequ√™ncia...";
  DOM.statusEl.className = "status-correct";
  
  await playScientificSequence(scientificSeq);

  if(state.playing) {
    state.pendingTimeout = setTimeout(async () => {
      state.pendingTimeout = null;
      if(state.playing) {
        await playNextNote();
      }
    }, delayAfter);
  }
}

/* repetir nota oculta */
function repeatNote(){
  if(!state.awaitingGuess || !state.currentSecretNote){
    DOM.statusEl.textContent = "Nenhuma nota ativa para repetir.";
    return;
  }
  
  const initialRootSci = letterToScientific(state.initialRoot, state.secretNoteOctave); 
  const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
  const waitTime = instrumentType === 'synth' ? 500 : 1000;

  if(state.playTonic){
    playHiddenScientific(initialRootSci);
    setTimeout(() => {
        if(state.playing) playHiddenScientific(secretSci);
    }, waitTime);
  } else {
    playHiddenScientific(secretSci);
  }
}

/* quando usu√°rio clica em uma nota (tenta adivinhar) - SOMENTE MODO MANUAL */
async function onGuess(e){
  if(!state.awaitingGuess || !state.playing || DOM.autoAdvance.checked) return;

  const guessed = e.currentTarget.dataset.note;
  state.awaitingGuess = false;
  state.lastGuess = guessed;
  state.score.attempts++;
  updateScoreboard();
  updateUIState();

  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  allButtons.forEach(btn => {
    if(btn.dataset.note === guessed) {
      btn.classList.add(guessed === state.currentSecretNote ? "correct" : "wrong");
    }
    if(btn.dataset.note === state.currentSecretNote && guessed !== state.currentSecretNote) {
      btn.classList.add("correct");
    }
  });

  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

  let modeToGenerate = state.modoAtual;
  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, state.secretNoteOctave);
  const seqMidis = buildSequenceForSecret(state.currentSecretNote, scaleData, state.direction, state.secretNoteOctave);
  const scientificSeq = seqMidis.map(m => midiToScientific(m));
  const abcTokens = midisToABCTokens(seqMidis);

  DOM.paperEl.innerHTML = "";
  renderABC(abcTokens, state.keyRoot, state.initialRoot);

  if(guessed === state.currentSecretNote){
    state.score.correct++;
    updateScoreboard();
    DOM.statusEl.textContent = "‚úÖ Acertou! Preparando para tocar a sequ√™ncia...";
    DOM.statusEl.className = "status-correct";

    if(delayBefore > 0) {
      await new Promise(r => setTimeout(r, delayBefore));
    }

    if(state.playing) {
      DOM.statusEl.textContent = "üéµ Tocando sequ√™ncia...";
      await playScientificSequence(scientificSeq);
    }

    if(state.pendingTimeout) {
      clearTimeout(state.pendingTimeout);
      state.pendingTimeout = null;
    }

    if(state.playing) {
      state.pendingTimeout = setTimeout(async () => {
        state.pendingTimeout = null;
        if(state.playing) {
          await playNextNote();
        }
      }, delayAfter);
    }

  } else {
    DOM.statusEl.textContent = `‚ùå Errado ‚Äî a nota correta era ${state.currentSecretNote}.`;
    DOM.statusEl.className = "status-wrong";

    if(state.pendingTimeout) {
      clearTimeout(state.pendingTimeout);
      state.pendingTimeout = null;
    }

    if(state.playing) {
      state.pendingTimeout = setTimeout(async () => {
        state.pendingTimeout = null;
        if(state.playing) {
          await playNextNote();
        }
      }, 3000);
    }
  }
}

/* ============================
   Eventos
   ============================ */

DOM.btnStart.addEventListener("click", startRound);
DOM.btnStop.addEventListener("click", stopAll);
DOM.btnRepeat.addEventListener("click", repeatNote);

document.getElementById("selAllBtn").addEventListener("click", () => {
  Array.from(DOM.notasSelect.options).forEach(o => o.selected = true);
  updateResponseButtons();
});
document.getElementById("clearAllBtn").addEventListener("click", () => {
  Array.from(DOM.notasSelect.options).forEach(o => o.selected = false);
  updateResponseButtons();
});

DOM.notasSelect.addEventListener("change", updateResponseButtons);

// Handler para o checkbox de randomiza√ß√£o da T√¥nica do Intervalo
DOM.randomizeInitialRoot.addEventListener("change", () => {
    state.randomizeInitialRoot = DOM.randomizeInitialRoot.checked;
    DOM.initialRootNoteSelect.disabled = DOM.randomizeInitialRoot.checked;
    DOM.initialRootNoteSource.disabled = !DOM.randomizeInitialRoot.checked;
    updateUIState();
});

// Handler para o select de origem (atualiza o estado)
DOM.initialRootNoteSource.addEventListener("change", () => {
    state.initialRootSource = DOM.initialRootNoteSource.value;
});

DOM.initialRootNoteSelect.addEventListener("change", () => {
    if (!state.randomizeInitialRoot) {
        state.initialRoot = DOM.initialRootNoteSelect.value;
    }
});

DOM.autoAdvance.addEventListener("change", () => {
  if (DOM.autoAdvance.checked && state.playing && state.awaitingGuess) {
    const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
    allButtons.forEach(btn => {
      if(btn.dataset.note === state.currentSecretNote) {
        btn.classList.add("correct");
      }
    });
    autoAdvanceSequence();
  }
  updateUIState();
});

// NOVO: Handler para o seletor r√°pido (agora carrega automaticamente)
DOM.instrumentSelector.addEventListener("change", (e) => {
    const programNum = parseInt(e.target.value, 10);
    // Removemos a necessidade do bot√£o, chamando o carregamento diretamente
    loadInstrumentFromMIDIProgram(programNum);
});

function syncRangeAndNum(rangeEl, numEl){
  rangeEl.addEventListener("input", () => {
    numEl.value = rangeEl.value;
  });
  numEl.addEventListener("input", () => {
    let v = parseInt(numEl.value, 10);
    if(isNaN(v)) v = parseInt(rangeEl.min,10);
    v = Math.max(parseInt(rangeEl.min,10), Math.min(parseInt(rangeEl.max,10), v));
    numEl.value = v;
    rangeEl.value = v;
  });
}

syncRangeAndNum(DOM.delayBeforeRange, DOM.delayBeforeNum);
syncRangeAndNum(DOM.delayBetweenRange, DOM.delayBetweenNum);
syncRangeAndNum(DOM.delayAfterRange, DOM.delayAfterNum);

document.addEventListener("DOMContentLoaded", () => {
  populateInitialRootNoteSelect();
  // Inicializa o instrumento padr√£o (MIDI Program 0)
  loadInstrumentFromMIDIProgram(0); 
  updateResponseButtons();
  updateScoreboard();
  updateUIState();
});
</script>
</body>
</html>
