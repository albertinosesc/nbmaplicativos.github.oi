<!DOCTYPE html>
<html lang="pt-BR">
<head>
Â  <meta charset="utf-8" />
Â  <meta name="viewport" content="width=device-width,initial-scale=1" />
Â  <title>PercepÃ§Ã£o Auditiva â€” Modos e Escalas (Synth)</title>

Â  Â  <script src="https://cdn.jsdelivr.net/npm/abcjs@6.4.2/dist/abcjs-basic-min.js"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>

Â  <style>
/* Bloco CSS Completo */
body { font-family: Arial, Helvetica, sans-serif; background:#f7f9fb; padding:18px; max-width:1200px; margin:auto; }
h1 { text-align:center; color:#222; margin-bottom:6px; }
.controls { display:flex; gap:16px; flex-wrap:wrap; justify-content:center; margin-bottom:14px; }
.control { background:#fff; padding:14px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-width:240px; }
label strong { display:block; margin-bottom:6px; color:#333; }
select, button, input[type="number"], input[type="range"] { width:100%; padding:8px; border-radius:8px; border:1px solid #ccc; font-size:14px; box-sizing:border-box; }
button { cursor:pointer; }
#paper { margin:16px auto; width:100%; max-width:900px; background:#fff; padding:16px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-height:80px; }
#status { text-align:center; margin-top:12px; padding:8px; border-radius:8px; font-weight:700; }
.status-default { color:#444; background: none; }
.status-awaiting { color:#0d47a1; background:#e3f2fd; }
.status-correct { color:#fff; background:#2e7d32; }
.status-wrong { color:#fff; background:#c62828; }
.note-buttons { display:flex; gap:10px; justify-content:center; margin-top:16px; flex-wrap:wrap; }
.note-buttons button { padding:10px 14px; border-radius:8px; border:none; background:#1976d2; color:white; font-weight:700; min-width:56px; }
.note-buttons button:disabled { background:#cfd8dc; color:#666; cursor:not-allowed; }
.note-buttons button.correct { background:#2e7d32; }
.note-buttons button.wrong { background:#c62828; }
.small { font-size:13px; color:#555; margin-top:8px; }
.row { display:flex; gap:8px; align-items:center; }
.row > input[type="number"] { width:120px; flex:0 0 120px; }
.val { font-weight:700; margin-left:6px; }
#scoreboard { text-align:center; margin-bottom:10px; font-weight:700; color:#333; }
#scoreboard span { color:#1976d2; margin:0 6px; }
.select-actions { display:flex; gap:6px; margin-top:8px; }
.select-actions button { padding:6px 8px; font-size:13px; background:#efefef; border:1px solid #d0d0d0; cursor:pointer; }
.checkbox-row { display: flex; align-items: center; margin-top: 8px; }
.checkbox-row input[type="checkbox"] { margin-right: 8px; width: auto; }
@media (max-width:900px) { 
Â  .controls { flex-direction:column; } 
Â  .control { min-width:auto; } 
}
Â  </style>
</head>
<body>
Â  <h1>ğŸ§ Treino de PercepÃ§Ã£o Auditiva â€” Modos e Escalas (Synth)</h1>

Â  <div id="scoreboard">Acertos: <span id="correctCount">0</span> / Tentativas: <span id="attemptCount">0</span>
Â  Â  <button onclick="resetScore()" style="margin-left:8px;padding:6px 10px;background:#c62828;color:white;border:none;border-radius:6px;cursor:pointer;">Limpar Placar</button>
Â  </div>

Â  <div class="controls">
Â  Â  Â  Â  <div class="control">
Â  Â  Â  <label><strong>Notas possÃ­veis (respostas)</strong></label>
Â  Â  Â  <select id="notas" multiple size="13">
Â  Â  Â  Â  <option value="C" selected>C</option><option value="C#" selected>C#</option><option value="D" selected>D</option><option value="D#" selected>D#</option>
Â  Â  Â  Â  <option value="E" selected>E</option><option value="F" selected>F</option><option value="F#" selected>F#"</option><option value="G" selected>G</option>
Â  Â  Â  Â  <option value="G#" selected>G#</option><option value="A" selected>A</option><option value="A#" selected>A#</option><option value="B" selected>B</option>
Â  Â  Â  Â  <option value="C(5)" selected>C (Oitava Acima)</option> 
Â  Â  Â  </select>
Â  Â  Â  <div class="select-actions">
Â  Â  Â  Â  <button id="selAllBtn">Selecionar Todas</button>
Â  Â  Â  Â  <button id="clearAllBtn">Limpar SeleÃ§Ã£o</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="small">Somente notas selecionadas aparecem nos botÃµes de resposta (modo manual).</div>
Â  Â  </div>

Â  Â  Â  Â  <div class="control">
Â  Â  Â  <label><strong>Tom (tÃ´nica)</strong></label>
Â  Â  Â  <select id="tom">
Â  Â  Â  Â  <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
Â  Â  Â  Â  <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
Â  Â  Â  Â  <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
Â  Â  Â  </select>

Â  Â  Â  <label style="margin-top:8px"><strong>Oitava da nota secreta</strong></label>
Â  Â  Â  <select id="oitava">
Â  Â  Â  Â  <option value="3">3</option>
Â  Â  Â  Â  <option value="4" selected>4</option>
Â  Â  Â  Â  <option value="5">5</option>
Â  Â  Â  </select>

Â  Â  Â  <label style="margin-top:8px"><strong>Modo / Escala</strong></label>
Â  Â  Â  <select id="modo">
Â  Â  Â  Â  <option value="ionian">JÃ´nio (Maior)</option>
Â  Â  Â  Â  <option value="dorian">DÃ³rico</option>
Â  Â  Â  Â  <option value="phrygian">FrÃ­gio</option>
Â  Â  Â  Â  <option value="lydian">LÃ­dio</option>
Â  Â  Â  Â  <option value="mixolydian">MixolÃ­dio</option>
Â  Â  Â  Â  <option value="aeolian">Menor Natural (EÃ³lio)</option>
Â  Â  Â  Â  <option value="harmonic_minor">Menor HarmÃ´nica</option>
Â  Â  Â  Â  <option value="melodic_minor">Menor MelÃ³dica (asc)</option>
Â  Â  Â  Â  <option value="locrian">LÃ³crio</option>
Â  Â  Â  Â  <option value="chromatic">CromÃ¡tica</option>
Â  Â  Â  </select>

Â  Â  Â  <label style="margin-top:8px"><strong>DireÃ§Ã£o</strong></label>
Â  Â  Â  <select id="direcao">
Â  Â  Â  Â  <option value="asc">Ascendente</option>
Â  Â  Â  Â  <option value="desc">Descendente</option>
Â  Â  Â  </select>

Â  Â  </div>

Â  Â  Â  Â  <div class="control">
Â  Â  Â  <label><strong>Controles</strong></label>
Â  Â  Â  <button id="btnStart" style="background:#2e7d32;color:white;margin-bottom:8px;">â–¶ Iniciar Treino</button>
Â  Â  Â  <button id="btnStop" style="background:#e53935;color:white;margin-bottom:8px;">â¹ Parar</button>
Â  Â  Â  <button id="btnRepeat" style="background:#6a1b9a;color:white;margin-bottom:8px;" disabled>ğŸ” Ouvir Nota Novamente</button>
Â  Â  Â  
Â  Â  Â  <label style="margin-top:8px"><strong>Tocar tÃ´nica antes da nota oculta</strong></label>
Â  Â  Â  <div class="checkbox-row">
Â  Â  Â  Â  <input type="checkbox" id="playTonicBefore" checked>
Â  Â  Â  Â  <label for="playTonicBefore" style="margin:0; font-weight:normal;">Ativado</label>
Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <label style="margin-top:8px"><strong>AvanÃ§ar Automaticamente</strong></label>
Â  Â  Â  <div class="checkbox-row">
Â  Â  Â  Â  <input type="checkbox" id="autoAdvance">
Â  Â  Â  Â  <label for="autoAdvance" style="margin:0; font-weight:normal;">AvanÃ§ar p/ prÃ³xima nota apÃ³s sequÃªncia (sem palpite)</label>
Â  Â  Â  </div>

Â  Â  Â  <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">

Â  Â  Â  Â  Â  Â  <label><strong>Tempo (Nota â†’ SequÃªncia)</strong></label>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <input id="delayBeforeRange" type="range" min="0" max="3000" step="50" value="750">
Â  Â  Â  Â  <input id="delayBeforeNum" type="number" min="0" max="3000" step="50" value="750">
Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <label style="margin-top:8px"><strong>Tempo (entre notas da sequÃªncia)</strong></label>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <input id="delayBetweenRange" type="range" min="25" max="1500" step="25" value="570">
Â  Â  Â  Â  <input id="delayBetweenNum" type="number" min="25" max="1500" step="25" value="570">
Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  <label style="margin-top:8px"><strong>Tempo (SequÃªncia â†’ PrÃ³xima Nota)</strong></label>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <input id="delayAfterRange" type="range" min="0" max="5000" step="50" value="1100">
Â  Â  Â  Â  <input id="delayAfterNum" type="number" min="0" max="5000" step="50" value="1100">
Â  Â  Â  </div>
Â  Â  Â  <div class="small">VocÃª pode arrastar o slider ou digitar o valor numÃ©rico â€” ambos sincronizados. O Ãºltimo slider controla o avanÃ§o automÃ¡tico.</div>
Â  Â  </div>
Â  </div>

Â  <div id="paper"></div>
Â  <div id="status" class="status-default">Ãudio Sintetizado (MIDI) pronto. Clique em "Iniciar Treino" para comeÃ§ar.</div>
Â  <div class="note-buttons" id="noteButtons"></div>

<script>
/* ============================
Â  Â Dados e ConfiguraÃ§Ãµes
Â  Â ============================ */
// Base para cÃ¡lculos musicais (12 notas)
const NOTE_NAMES_BASE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
// Nomes de notas para a UI (13 notas, incluindo C(5))
const NOTE_NAMES = [...NOTE_NAMES_BASE, "C(5)"]; 
const MODOS = {
Â  ionian:Â  Â  Â  Â  [0,2,4,5,7,9,11],
Â  dorian:Â  Â  Â  Â  [0,2,3,5,7,9,10],
Â  phrygian:Â  Â  Â  [0,1,3,5,7,8,10],
Â  lydian:Â  Â  Â  Â  [0,2,4,6,7,9,11],
Â  mixolydian:Â  Â  [0,2,4,5,7,9,10],
Â  aeolian:Â  Â  Â  Â [0,2,3,5,7,8,10],
Â  harmonic_minor:[0,2,3,5,7,8,11],
Â  melodic_minor: [0,2,3,5,7,9,11], // ascendente
Â  locrian:Â  Â  Â  Â [0,1,3,5,6,8,10],
Â  chromatic:Â  Â  Â [0,1,2,3,4,5,6,7,8,9,10,11]
};

// USANDO SYNTH SIMPLES E ROBUSTO (para garantir que o som funcione)
const synth = new Tone.Synth({
Â  // Um timbre simples de onda seno, ideal para testes de percepÃ§Ã£o e confiÃ¡vel
Â  oscillator: { type: "sine" }, 
Â  // Envelope mais percussivo para clareza
Â  envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
}).toDestination();


// Inicializar o Ã¡udio
Tone.start();

/* Estado central */
const state = {
Â  playing: false,
Â  awaitingGuess: false,
Â  currentSecretNote: null,
Â  secretNoteOctave: 4, // Oitava padrÃ£o
Â  selectedNotes: [],
Â  keyRoot: "C",
Â  modoAtual: "ionian",
Â  direction: "asc",
Â  playTonic: true,
Â  score: { correct:0, attempts:0 },
Â  pendingTimeout: null,
Â  lastGuess: null,
Â  pianoLoaded: true // Marcado como true para o synth estar sempre pronto
};

/* DOM refs */
const DOM = {
Â  btnStart: document.getElementById("btnStart"),
Â  btnStop: document.getElementById("btnStop"),
Â  btnRepeat: document.getElementById("btnRepeat"),
Â  autoAdvance: document.getElementById("autoAdvance"),
Â  statusEl: document.getElementById("status"),
Â  noteButtonsDiv: document.getElementById("noteButtons"),
Â  paperEl: document.getElementById("paper"),
Â  notasSelect: document.getElementById("notas"),
Â  tomSelect: document.getElementById("tom"),
Â  modoSelect: document.getElementById("modo"),
Â  direcaoSelect: document.getElementById("direcao"),
Â  oitavaSelect: document.getElementById("oitava"),
Â  playTonicBefore: document.getElementById("playTonicBefore"),
Â  correctCount: document.getElementById("correctCount"),
Â  attemptCount: document.getElementById("attemptCount"),
Â  // sliders + numeric inputs
Â  delayBeforeRange: document.getElementById("delayBeforeRange"),
Â  delayBeforeNum: document.getElementById("delayBeforeNum"),
Â  delayBetweenRange: document.getElementById("delayBetweenRange"),
Â  delayBetweenNum: document.getElementById("delayBetweenNum"),
Â  delayAfterRange: document.getElementById("delayAfterRange"),
Â  delayAfterNum: document.getElementById("delayAfterNum")
};

/* ============================
Â  Â ConversÃµes e utilitÃ¡rios musicais
Â  Â ============================ */
// CONVERSÃƒO C(5) -> C5 e C(3), C(4) tambÃ©m sÃ£o tratados
function letterToScientific(letter, octave){
Â  if (letter.match(/^C\(\d\)$/)) {
Â  Â  // CORREÃ‡ÃƒO: O C(5) deve ser UMA OITAVA ACIMA da oitava base selecionada, 
Â  Â  // exceto se a oitava base for 5 (mantemos 5 como limite superior).
Â  Â  const targetOctave = (octave < 5) ? (octave + 1) : 5;
Â  Â  return "C" + targetOctave;
Â  }
Â  
Â  if (letter === "C") {
Â  Â  // O C puro (tÃ´nica) sempre usa a oitava base selecionada
Â  Â  return "C" + octave;
Â  }

Â  // Para as outras notas (C# a B), usa a oitava selecionada
Â  return letter + octave; 
}

function midiToScientific(m){Â 
Â  const idx = ((m%12)+12)%12;Â 
Â  const oct = Math.floor(m/12)-1;Â 
Â  return NOTE_NAMES_BASE[idx] + oct;Â 
}

function scientificToABC(sci){
Â  const m = sci.match(/^([A-G])(#|b)?(-?\d+)$/);
Â  if(!m) return sci;
Â  const letter=m[1], acc=m[2]||"", oct=parseInt(m[3],10);
Â  const accToken = acc==="#" ? "^" : (acc==="b" ? "_" : "");
Â  let base;
Â  if(oct>4){Â 
Â  Â  base = letter.toLowerCase();Â 
Â  Â  if(oct>5) base += "'".repeat(oct-5);Â 
Â  } else if(oct<4){Â 
Â  Â  base = letter.toUpperCase() + ",".repeat(4-oct);Â 
Â  } else base = letter.toUpperCase();
Â  return accToken + base;
}

/** Gera a escala em midis com base na tÃ´nica + modo, usando a oitava de referÃªncia */
function generateModeScaleMidi(root, modo, octave){
Â  const rootIdx = NOTE_NAMES_BASE.indexOf(root);
Â  const tonicMidi = 12*(octave + 1) + rootIdx;
Â  const pattern = MODOS[modo] || [];
Â  const midis = pattern.map(i => tonicMidi + i);
Â  return { midis, tonicMidi };
}

/** * Constroi a sequÃªncia COMPLETA (TÃ´nica -> Escala -> Nota Secreta -> Escala -> TÃ´nica) 
 * A tÃ´nica de inÃ­cio/fim define a oitava da escala.
 */
function buildFullSequence(selectedNoteName, scaleData, dir, baseOctave){
Â  const { midis, tonicMidi } = scaleData;
Â  
Â  let targetMidi;
Â  
Â  // 1. Encontra o MIDI da nota secreta (na oitava correta)
Â  if (selectedNoteName.match(/^C\(\d\)$/)) {
Â  Â  const explicitOctave = parseInt(selectedNoteName.match(/\((\d)\)/)[1], 10);
Â  Â  targetMidi = 12 * (explicitOctave + 1) + NOTE_NAMES_BASE.indexOf('C');
Â  } else {
Â  Â  // Aplica a mesma lÃ³gica de oitava que em letterToScientific para C
Â  Â  let effectiveOctave = baseOctave;
Â  Â  if (selectedNoteName === "C" && baseOctave === 5) {
Â  Â  Â  effectiveOctave = 4;
Â  Â  }

Â  Â  const rootIdx = NOTE_NAMES_BASE.indexOf(selectedNoteName);
Â  Â  targetMidi = 12 * (effectiveOctave + 1) + rootIdx;
Â  }

Â  // 2. Estende a escala para a prÃ³xima oitava (para o fim da sequÃªncia ascendente)
Â  let fullScaleMidis = [...midis];
Â  const tonicAbove = tonicMidi + 12;
Â  
Â  // Adiciona a prÃ³xima oitava da escala para ter cobertura
Â  fullScaleMidis = fullScaleMidis.concat(midis.map(m => m + 12));
Â  
Â  // 3. Adiciona a Nota Secreta (Target) e a TÃ´nica Superior na lista e ordena
Â  if(!fullScaleMidis.includes(targetMidi)) {
Â  Â  fullScaleMidis.push(targetMidi);
Â  }
Â  if(!fullScaleMidis.includes(tonicAbove)) {
Â  Â  fullScaleMidis.push(tonicAbove);
Â  }
Â  
Â  // Remove duplicatas e ordena
Â  fullScaleMidis = [...new Set(fullScaleMidis)].sort((a, b) => a - b);
Â  
Â  // 4. ConstrÃ³i a sequÃªncia com inÃ­cio e fim definidos (TÃ”NICA)
Â  const startTonic = tonicMidi;
Â  const endTonic = tonicAbove;

Â  // Filtra as notas da escala estendida que estÃ£o no range [startTonic, endTonic]
Â  let notesInRange = fullScaleMidis.filter(m => m >= startTonic && m <= endTonic);
Â  
Â  // GARANTE QUE A NOTA SECRETA ESTÃ NO RANGE, MESMO QUE FORA DA OITAVA DE REFERÃŠNCIA
Â  if (!notesInRange.includes(targetMidi)) {
Â  Â  if (targetMidi < startTonic) {
Â  Â  Â  // Se a nota secreta for mais grave que a tÃ´nica de inÃ­cio (ex: C(3) e tÃ´nica C4)
Â  Â  Â  notesInRange = fullScaleMidis.filter(m => m >= targetMidi && m <= endTonic);
Â  Â  Â  notesInRange.unshift(startTonic); 
Â  Â  } else if (targetMidi > endTonic) {
Â  Â  Â  // Se a nota secreta for mais aguda que a tÃ´nica de fim (ex: C(6) e tÃ´nica C5)
Â  Â  Â  notesInRange = fullScaleMidis.filter(m => m >= startTonic && m <= targetMidi);
Â  Â  Â  notesInRange.push(endTonic); 
Â  Â  }
Â  Â  notesInRange = [...new Set(notesInRange)].sort((a, b) => a - b);
Â  }

Â  // Remove notas da escala se a nota secreta for a mesma classe de pitch em oitava diferente
Â  let finalSeq = [...notesInRange]; 
Â  if (targetMidi !== startTonic && targetMidi !== endTonic) {
Â  Â  const targetPitch = targetMidi % 12;
Â  Â  const noteToRemove = notesInRange.find(m => m !== targetMidi && m % 12 === targetPitch);
Â  Â  if (noteToRemove) {
Â  Â  Â  finalSeq = finalSeq.filter(m => m !== noteToRemove);
Â  Â  Â  finalSeq.push(targetMidi);
Â  Â  Â  finalSeq.sort((a, b) => a - b);
Â  Â  }
Â  }


Â  if(dir === "asc"){
Â  Â  // Ordem: TÃ´nica Base (C4) -> ... -> TÃ´nica Oitava Acima (C5)
Â  Â  let resultAsc = finalSeq.filter(m => m >= startTonic && m <= endTonic);
Â  Â  if(resultAsc[0] !== startTonic) resultAsc.unshift(startTonic);
Â  Â  if(resultAsc[resultAsc.length-1] !== endTonic) resultAsc.push(endTonic);
Â  Â  
Â  Â  // Adicionar Target se foi perdido (ex: C(5) Ã© o target e C5 Ã© o endTonic)
Â  Â  if (!resultAsc.includes(targetMidi) && targetMidi >= startTonic && targetMidi <= endTonic) {
Â  Â  Â  resultAsc.push(targetMidi);
Â  Â  }
Â  Â  
Â  Â  return [...new Set(resultAsc)].sort((a,b) => a-b);

Â  } else { // "desc"
Â  Â  // Ordem: TÃ´nica Oitava Acima (C5) -> ... -> TÃ´nica Base (C4)
Â  Â  let resultDesc = finalSeq.filter(m => m >= startTonic && m <= endTonic);
Â  Â  if(resultDesc[0] !== startTonic) resultDesc.unshift(startTonic);
Â  Â  if(resultDesc[resultDesc.length-1] !== endTonic) resultDesc.push(endTonic);
Â  Â  
Â  Â  // Adicionar Target se foi perdido
Â  Â  if (!resultDesc.includes(targetMidi) && targetMidi >= startTonic && targetMidi <= endTonic) {
Â  Â  Â  resultDesc.push(targetMidi);
Â  Â  }
Â  Â  
Â  Â  return [...new Set(resultDesc)].sort((a,b) => b-a);
Â  }
}


/* Convert midis -> ABC string tokens */
function midisToABCTokens(midis){
Â  return midis.map(m => scientificToABC(midiToScientific(m))).join(" ");
}

function renderABC(tokens, key){
Â  if(!tokens || tokens.length === 0){ DOM.paperEl.innerHTML = ""; return; }
Â  const abc = `X:1\nL:1/4\nK:${key}\n${tokens}`;
Â  ABCJS.renderAbc("paper", abc);
}

/* ============================
Â  Â ÃUDIO: tocar nota
Â  Â ============================ */
function playNoteScientific(sci, dur="8n"){
Â  try {
Â  Â  // Usa o synth simples (som tipo MIDI / Acordeon)
Â  Â  synth.triggerAttackRelease(sci, dur);
Â  Â  return true;
Â  } catch (error) {
Â  Â  console.error("Erro ao tocar nota:", sci, error);
Â  Â  return false;
Â  }
}

/* Toca sequÃªncia (array de scientific strings), respeitando delayBetween (ms) */
function playScientificSequence(scientificNotes) {
Â  return new Promise(async (resolve) => {
Â  Â  const delayBetween = parseInt(DOM.delayBetweenNum.value, 10);
Â  Â Â 
Â  Â  for(let i = 0; i < scientificNotes.length; i++) {
Â  Â  Â  if(!state.playing) break;
Â  Â  Â Â 
Â  Â  Â  const note = scientificNotes[i];
Â  Â  Â  // Tocar a nota
Â  Â  Â  playNoteScientific(note, "8n");
Â  Â  Â Â 
Â  Â  Â  // Esperar o intervalo entre notas (exceto para a Ãºltima nota)
Â  Â  Â  if(i < scientificNotes.length - 1) {
Â  Â  Â  Â  await new Promise(r => setTimeout(r, delayBetween));
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  resolve();
Â  });
}

/* Toca nota oculta */
function playHiddenScientific(sci){
Â  playNoteScientific(sci, "4n");
}

/* ============================
Â  Â UI helpers (placar, botÃµes)
Â  Â ============================ */
function updateScoreboard(){
Â  DOM.correctCount.textContent = state.score.correct;
Â  DOM.attemptCount.textContent = state.score.attempts;
}

function resetScore(){
Â  state.score = { correct:0, attempts:0 };
Â  updateScoreboard();
}

/* Atualiza botÃµes de resposta com apenas notas selecionadas */
function updateResponseButtons(){
Â  const opts = Array.from(DOM.notasSelect.selectedOptions).map(o => o.value);
Â  DOM.noteButtonsDiv.innerHTML = "";
Â  if(opts.length === 0){
Â  Â  DOM.statusEl.textContent = "Selecione notas para aparecerem como botÃµes de resposta.";
Â  Â  return;
Â  }
Â  opts.forEach(n => {
Â  Â  const b = document.createElement("button");
Â  Â  b.textContent = n;
Â  Â  b.dataset.note = n;
Â  Â  b.onclick = onGuess;
Â  Â  DOM.noteButtonsDiv.appendChild(b);
Â  });
Â  updateUIState();
}

/* Habilita / desabilita elementos conforme estado */
function updateUIState(){
Â  // O botÃ£o de iniciar estÃ¡ sempre habilitado agora que nÃ£o hÃ¡ carregamento de piano
Â  DOM.btnStart.disabled = state.playing; 
Â  DOM.btnStop.disabled = !state.playing;
Â  // No modo automÃ¡tico, o botÃ£o de repetir nota sÃ³ deve estar disponÃ­vel enquanto o usuÃ¡rio estÃ¡ aguardando (antes da sequÃªncia)
Â  DOM.btnRepeat.disabled = !(state.playing && state.awaitingGuess);
Â Â 
Â  const configDisabled = state.playing && !state.awaitingGuess; // Permite alterar configuraÃ§Ãµes se estiver aguardando (Modo Manual)
Â  DOM.notasSelect.disabled = configDisabled;
Â  DOM.tomSelect.disabled = configDisabled;
Â  DOM.modoSelect.disabled = configDisabled;
Â  DOM.direcaoSelect.disabled = configDisabled;
Â  // A oitava sÃ³ deve ser desabilitada se a nota secreta for C(x) fixo.
Â  DOM.oitavaSelect.disabled = configDisabled || (state.currentSecretNote && state.currentSecretNote.match(/^C\(\d\)$/)); 
Â  DOM.playTonicBefore.disabled = configDisabled;
Â  DOM.autoAdvance.disabled = configDisabled; 
Â Â 
Â  const answerButtons = DOM.noteButtonsDiv.querySelectorAll("button");
Â  // BotÃµes de resposta desabilitados se nÃ£o estiver esperando palpite
Â  answerButtons.forEach(b => {Â 
Â  Â  b.disabled = !state.awaitingGuess;
Â  Â  if (state.awaitingGuess) {
Â  Â  Â  b.classList.remove("correct", "wrong");
Â  Â  }
Â  });
}

/* ============================
Â  Â Fluxo principal
Â  Â ============================ */

async function startRound(){
Â  if(state.playing) return;
Â  const selOpts = Array.from(DOM.notasSelect.selectedOptions);
Â  if(selOpts.length === 0){Â 
Â  Â  alert("Selecione pelo menos uma nota!");Â 
Â  Â  return;Â 
Â  }
Â Â 
Â  state.playing = true;
Â  state.selectedNotes = selOpts.map(o => o.value);
Â  state.keyRoot = DOM.tomSelect.value;
Â  state.modoAtual = DOM.modoSelect.value;
Â  state.direction = DOM.direcaoSelect.value;
Â  state.secretNoteOctave = parseInt(DOM.oitavaSelect.value, 10);
Â  state.playTonic = DOM.playTonicBefore.checked;
Â Â 
Â  DOM.paperEl.innerHTML = "";
Â  DOM.statusEl.textContent = "Treino ativo â€” tocando nota oculta...";
Â  DOM.statusEl.className = "status-awaiting";
Â  updateUIState();

Â  // Toca a primeira nota
Â  await playNextNote();
}

function stopAll(){
Â  state.playing = false;
Â  state.awaitingGuess = false;
Â  state.currentSecretNote = null;
Â  if(state.pendingTimeout) {Â 
Â  Â  clearTimeout(state.pendingTimeout);Â 
Â  Â  state.pendingTimeout = null;Â 
Â  }
Â  DOM.paperEl.innerHTML = "";
Â  DOM.statusEl.textContent = "Parado.";
Â  DOM.statusEl.className = "status-default";
Â  updateUIState();
}

async function playNextNote() {
Â  if(!state.playing) return;
Â Â 
Â  // Seleciona a nota e determina a oitava cientÃ­fica
Â  state.currentSecretNote = state.selectedNotes[Math.floor(Math.random() * state.selectedNotes.length)];
Â  const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);

Â  state.awaitingGuess = true;
Â  state.lastGuess = null;
Â Â 
Â  // Desabilita a seleÃ§Ã£o de oitava se a nota for C(x), pois a oitava Ã© fixa
Â  DOM.oitavaSelect.disabled = state.currentSecretNote.match(/^C\(\d\)$/);

Â  // Verifica o modo automÃ¡tico para atualizar o status/UI
Â  if (DOM.autoAdvance.checked) {
Â  Â  DOM.statusEl.textContent = "ğŸ§ Modo AutomÃ¡tico: Tocando nota oculta. Aguarde a sequÃªncia...";
Â  } else {
Â  Â  DOM.statusEl.textContent = "ğŸ§ Modo Manual: OuÃ§a a nota oculta. Clique na nota que acha que foi.";
Â  }
Â  DOM.statusEl.className = "status-awaiting";
Â  DOM.paperEl.innerHTML = "";

Â  // Limpar cores dos botÃµes
Â  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
Â  allButtons.forEach(btn => {
Â  Â  btn.classList.remove("correct", "wrong");
Â  });

Â  // Pequeno delay antes de tocar
Â  await new Promise(r => setTimeout(r, 100));

Â  // tocar tÃ´nica antes se ativado
Â  if(state.playTonic){
Â  Â  // TÃ´nica sempre baseada na OITAVA SELECIONADA.
Â  Â  const tonicOctave = state.secretNoteOctave; 
Â  Â  const tonicMidi = 12 * (tonicOctave + 1) + NOTE_NAMES_BASE.indexOf(state.keyRoot);
Â  Â  const keyRootSci = midiToScientific(tonicMidi);
Â  Â  playNoteScientific(keyRootSci, "4n");
Â  Â  await new Promise(r => setTimeout(r, 800)); // Delay maior apÃ³s a tÃ´nica
Â  }

Â  // tocar a nota secreta
Â  playHiddenScientific(secretSci);

Â  updateUIState();

Â  // Dispara a sequÃªncia automaticamente se autoAdvance estiver marcado
Â  if (DOM.autoAdvance.checked) {
Â  Â  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
Â  Â  await new Promise(r => setTimeout(r, 800 + delayBefore)); // Aguarda nota secreta + delay

Â  Â  if (state.playing) {
Â  Â  Â  DOM.statusEl.textContent = "ğŸµ Modo AutomÃ¡tico: Tocando sequÃªncia...";
Â  Â  Â  // Chama a lÃ³gica de acerto para tocar a sequÃªncia e avanÃ§ar
Â  Â  Â  autoAdvanceSequence();
Â  Â  }
Â  }
}

/* Funcao para avanÃ§ar no modo automÃ¡tico, simulando um acerto imediato */
async function autoAdvanceSequence() {
Â  if(!state.playing) return;
Â Â 
Â  state.awaitingGuess = false;
Â  // Simula um palpite correto
Â  state.lastGuess = state.currentSecretNote;
Â  state.score.attempts++;
Â  state.score.correct++;
Â  updateScoreboard();

Â  // Desabilitar botÃµes enquanto toca sequÃªncia
Â  updateUIState();
Â Â 
Â  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
Â  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

Â  // determinar comportamento melodic_minor descendente -> usar aeolian para descida:
Â  let modeToGenerate = state.modoAtual;
Â  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

Â  // A oitava base para a escala Ã© SEMPRE a oitava selecionada.
Â  const baseOctaveForScale = state.secretNoteOctave;
Â  // gerar escala na oitava base (a oitava da maioria das notas)
Â  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, baseOctaveForScale);
Â  
Â  // CHAMA A NOVA FUNÃ‡ÃƒO buildFullSequence
Â  const seqMidis = buildFullSequence(state.currentSecretNote, scaleData, state.direction, baseOctaveForScale);
Â  const scientificSeq = seqMidis.map(m => midiToScientific(m));
Â  const abcTokens = midisToABCTokens(seqMidis);

Â  DOM.paperEl.innerHTML = "";
Â  renderABC(abcTokens, state.keyRoot);

Â  DOM.statusEl.textContent = "ğŸµ Modo AutomÃ¡tico: Tocando sequÃªncia...";
Â  DOM.statusEl.className = "status-correct";

Â  // Toca a sequÃªncia
Â  await playScientificSequence(scientificSeq);
Â Â 
Â  // AvanÃ§ar para prÃ³xima nota apÃ³s delay (USA O SLIDER delayAfter)
Â  if(state.playing) {
Â  Â  state.pendingTimeout = setTimeout(async () => {
Â  Â  Â  state.pendingTimeout = null;
Â  Â  Â  if(state.playing) {
Â  Â  Â  Â  await playNextNote();
Â  Â  Â  }
Â  Â  }, delayAfter);
Â  }
}

/* repetir nota oculta */
function repeatNote(){
Â  if(!state.awaitingGuess || !state.currentSecretNote){Â 
Â  Â  DOM.statusEl.textContent = "Nenhuma nota ativa para repetir.";Â 
Â  Â  return;Â 
Â  }
Â  const sci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
Â  playHiddenScientific(sci);
}

/* quando usuÃ¡rio clica em uma nota (tenta adivinhar) - SOMENTE MODO MANUAL */
async function onGuess(e){
Â  // Bloqueia palpite se nÃ£o estiver esperando ou se estiver em modo automÃ¡tico
Â  if(!state.awaitingGuess || !state.playing || DOM.autoAdvance.checked) return;
Â Â 
Â  const guessed = e.currentTarget.dataset.note;
Â  state.awaitingGuess = false;
Â  state.lastGuess = guessed;
Â  state.score.attempts++;
Â  updateScoreboard();
Â  updateUIState();

Â  // Destacar o botÃ£o clicado e a resposta correta
Â  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
Â  allButtons.forEach(btn => {
Â  Â  if(btn.dataset.note === guessed) {
Â  Â  Â  btn.classList.add(guessed === state.currentSecretNote ? "correct" : "wrong");
Â  Â  }
Â  Â  if(btn.dataset.note === state.currentSecretNote && guessed !== state.currentSecretNote) {
Â  Â  Â  btn.classList.add("correct");
Â  Â  }
Â  });

Â  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
Â  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

Â  // determinar comportamento melodic_minor descendente -> usar aeolian para descida:
Â  let modeToGenerate = state.modoAtual;
Â  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

Â  // A oitava base para a escala Ã© SEMPRE a oitava selecionada.
Â  const baseOctaveForScale = state.secretNoteOctave;
Â  // gerar escala
Â  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, baseOctaveForScale);
Â  
Â  // CHAMA A NOVA FUNÃ‡ÃƒO buildFullSequence
Â  const seqMidis = buildFullSequence(state.currentSecretNote, scaleData, state.direction, baseOctaveForScale);
Â  const scientificSeq = seqMidis.map(m => midiToScientific(m));
Â  const abcTokens = midisToABCTokens(seqMidis);

Â  DOM.paperEl.innerHTML = "";
Â  renderABC(abcTokens, state.keyRoot);

Â  if(guessed === state.currentSecretNote){
Â  Â  // acerto
Â  Â  state.score.correct++;
Â  Â  updateScoreboard();
Â  Â  DOM.statusEl.textContent = "âœ… Acertou! Preparando para tocar a sequÃªncia...";
Â  Â  DOM.statusEl.className = "status-correct";
Â  Â Â 
Â  Â  // Espera antes da sequÃªncia
Â  Â  if(delayBefore > 0) {
Â  Â  Â  await new Promise(r => setTimeout(r, delayBefore));
Â  Â  }
Â  Â Â 
Â  Â  // Toca a sequÃªncia
Â  Â  if(state.playing) {
Â  Â  Â  DOM.statusEl.textContent = "ğŸµ Tocando sequÃªncia...";
Â  Â  Â  await playScientificSequence(scientificSeq);
Â  Â  }
Â  Â Â 
Â  Â  if(state.pendingTimeout) {Â 
Â  Â  Â  clearTimeout(state.pendingTimeout);Â 
Â  Â  Â  state.pendingTimeout = null;Â 
Â  Â  }
Â  Â Â 
Â  Â  // AvanÃ§ar para prÃ³xima nota apÃ³s delay
Â  Â  if(state.playing) {
Â  Â  Â  state.pendingTimeout = setTimeout(async () => {
Â  Â  Â  Â  state.pendingTimeout = null;
Â  Â  Â  Â  if(state.playing) {
Â  Â  Â  Â  Â  await playNextNote();
Â  Â  Â  Â  }
Â  Â  Â  }, delayAfter);
Â  Â  }
Â  Â Â 
Â  } else {
Â  Â  // erro
Â  Â  DOM.statusEl.textContent = `âŒ Errado â€” a nota correta era ${state.currentSecretNote}.`;
Â  Â  DOM.statusEl.className = "status-wrong";
Â  Â Â 
Â  Â  if(state.pendingTimeout) {Â 
Â  Â  Â  clearTimeout(state.pendingTimeout);Â 
Â  Â  Â  state.pendingTimeout = null;Â 
Â  Â  }
Â  Â Â 
Â  Â  // No caso de erro, avanÃ§ar para a prÃ³xima nota apÃ³s delay (3 segundos fixos)
Â  Â  if(state.playing) {
Â  Â  Â  state.pendingTimeout = setTimeout(async () => {
Â  Â  Â  Â  state.pendingTimeout = null;
Â  Â  Â  Â  if(state.playing) {
Â  Â  Â  Â  Â  await playNextNote();
Â  Â  Â  Â  }
Â  Â  Â  }, 3000); // 3 segundos para ler a resposta
Â  Â  }
Â  }
}

/* ============================
Â  Â Eventos
Â  Â ============================ */

/* BotÃµes principais */
DOM.btnStart.addEventListener("click", startRound);
DOM.btnStop.addEventListener("click", stopAll);
DOM.btnRepeat.addEventListener("click", repeatNote);

/* Select all / clear all notes */
document.getElementById("selAllBtn").addEventListener("click", () => {
Â  Array.from(DOM.notasSelect.options).forEach(o => o.selected = true);
Â  updateResponseButtons();
});
document.getElementById("clearAllBtn").addEventListener("click", () => {
Â  Array.from(DOM.notasSelect.options).forEach(o => o.selected = false);
Â  updateResponseButtons();
});

/* Update response buttons when selection changes */
DOM.notasSelect.addEventListener("change", updateResponseButtons);

/* LÃ³gica para quando o modo automÃ¡tico Ã© ativado */
DOM.autoAdvance.addEventListener("change", () => {
Â  // Se ativar o autoAdvance e estiver esperando um palpite, avanÃ§a para a sequÃªncia
Â  if (DOM.autoAdvance.checked && state.playing && state.awaitingGuess) {
Â  Â  // Simula o avanÃ§o automÃ¡tico imediatamente
Â  Â  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
Â  Â  allButtons.forEach(btn => {
Â  Â  Â  if(btn.dataset.note === state.currentSecretNote) {
Â  Â  Â  Â  btn.classList.add("correct");
Â  Â  Â  }
Â  Â  });
Â  Â  autoAdvanceSequence();
Â  } else if (DOM.autoAdvance.checked && state.playing && !state.awaitingGuess) {
Â  Â  // Se a sequÃªncia jÃ¡ tocou/estÃ¡ tocando, o prÃ³ximo round serÃ¡ automÃ¡tico
Â  Â  // A lÃ³gica de avanÃ§o jÃ¡ estÃ¡ no setTimeout apÃ³s a sequÃªncia
Â  }
Â  updateUIState();
});

/* Sliders + Numeric inputs sync */
function syncRangeAndNum(rangeEl, numEl){
Â  rangeEl.addEventListener("input", () => {
Â  Â  numEl.value = rangeEl.value;
Â  });
Â  numEl.addEventListener("input", () => {
Â  Â  let v = parseInt(numEl.value, 10);
Â  Â  if(isNaN(v)) v = parseInt(rangeEl.min,10);
Â  Â  v = Math.max(parseInt(rangeEl.min,10), Math.min(parseInt(rangeEl.max,10), v));
Â  Â  numEl.value = v;
Â  Â  rangeEl.value = v;
Â  });
}

syncRangeAndNum(DOM.delayBeforeRange, DOM.delayBeforeNum);
syncRangeAndNum(DOM.delayBetweenRange, DOM.delayBetweenNum);
syncRangeAndNum(DOM.delayAfterRange, DOM.delayAfterNum); // O slider do avanÃ§o automÃ¡tico

/* InicializaÃ§Ã£o */
document.addEventListener("DOMContentLoaded", () => {
Â  updateResponseButtons();
Â  updateScoreboard();
Â  updateUIState(); 
});

</script>
</body>
</html>
