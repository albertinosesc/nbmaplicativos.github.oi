<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Percepção Auditiva — Modos e Escalas (Synth)</title>

    <script src="https://cdn.jsdelivr.net/npm/abcjs@6.4.2/dist/abcjs-basic-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.js"></script>

  <style>
/* Bloco CSS Completo */
body { font-family: Arial, Helvetica, sans-serif; background:#f7f9fb; padding:18px; max-width:1200px; margin:auto; }
h1 { text-align:center; color:#222; margin-bottom:6px; }
.controls { display:flex; gap:16px; flex-wrap:wrap; justify-content:center; margin-bottom:14px; }
.control { background:#fff; padding:14px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-width:240px; }
label strong { display:block; margin-bottom:6px; color:#333; }
select, button, input[type="number"], input[type="range"] { width:100%; padding:8px; border-radius:8px; border:1px solid #ccc; font-size:14px; box-sizing:border-box; }
button { cursor:pointer; }
#paper { margin:16px auto; width:100%; max-width:900px; background:#fff; padding:16px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,0.06); min-height:80px; }
#status { text-align:center; margin-top:12px; padding:8px; border-radius:8px; font-weight:700; }
.status-default { color:#444; background: none; }
.status-awaiting { color:#0d47a1; background:#e3f2fd; }
.status-correct { color:#fff; background:#2e7d32; }
.status-wrong { color:#fff; background:#c62828; }
.note-buttons { display:flex; gap:10px; justify-content:center; margin-top:16px; flex-wrap:wrap; }
.note-buttons button { padding:10px 14px; border-radius:8px; border:none; background:#1976d2; color:white; font-weight:700; min-width:56px; }
.note-buttons button:disabled { background:#cfd8dc; color:#666; cursor:not-allowed; }
.note-buttons button.correct { background:#2e7d32; }
.note-buttons button.wrong { background:#c62828; }
.small { font-size:13px; color:#555; margin-top:8px; }
.row { display:flex; gap:8px; align-items:center; }
.row > input[type="number"] { width:120px; flex:0 0 120px; }
.val { font-weight:700; margin-left:6px; }
#scoreboard { text-align:center; margin-bottom:10px; font-weight:700; color:#333; }
#scoreboard span { color:#1976d2; margin:0 6px; }
.select-actions { display:flex; gap:6px; margin-top:8px; }
.select-actions button { padding:6px 8px; font-size:13px; background:#efefef; border:1px solid #d0d0d0; cursor:pointer; }
.checkbox-row { display: flex; align-items: center; margin-top: 8px; }
.checkbox-row input[type="checkbox"] { margin-right: 8px; width: auto; }
@media (max-width:900px) { 
  .controls { flex-direction:column; } 
  .control { min-width:auto; } 
}
  </style>
</head>
<body>
  <h1>🎧 Treino de Percepção Auditiva — Modos e Escalas (Synth)</h1>

  <div id="scoreboard">Acertos: <span id="correctCount">0</span> / Tentativas: <span id="attemptCount">0</span>
    <button onclick="resetScore()" style="margin-left:8px;padding:6px 10px;background:#c62828;color:white;border:none;border-radius:6px;cursor:pointer;">Limpar Placar</button>
  </div>

  <div class="controls">
        <div class="control">
      <label><strong>Notas possíveis (respostas)</strong></label>
      <select id="notas" multiple size="13">
        <option value="C" selected>C</option><option value="C#" selected>C#</option><option value="D" selected>D</option><option value="D#" selected>D#</option>
        <option value="E" selected>E</option><option value="F" selected>F</option><option value="F#" selected>F#"</option><option value="G" selected>G</option>
        <option value="G#" selected>G#</option><option value="A" selected>A</option><option value="A#" selected>A#</option><option value="B" selected>B</option>
        <option value="C(5)" selected>C (Oitava Acima)</option> 
      </select>
      <div class="select-actions">
        <button id="selAllBtn">Selecionar Todas</button>
        <button id="clearAllBtn">Limpar Seleção</button>
      </div>
      <div class="small">Somente notas selecionadas aparecem nos botões de resposta (modo manual).</div>
    </div>

        <div class="control">
      <label><strong>Tom (tônica)</strong></label>
      <select id="tom">
        <option value="C">C</option><option value="C#">C#</option><option value="D">D</option><option value="D#">D#</option>
        <option value="E">E</option><option value="F">F</option><option value="F#">F#</option><option value="G">G</option>
        <option value="G#">G#</option><option value="A">A</option><option value="A#">A#</option><option value="B">B</option>
      </select>

      <label style="margin-top:8px"><strong>Oitava da nota secreta</strong></label>
      <select id="oitava">
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
      </select>

      <label style="margin-top:8px"><strong>Modo / Escala</strong></label>
      <select id="modo">
        <option value="ionian">Jônio (Maior)</option>
        <option value="dorian">Dórico</option>
        <option value="phrygian">Frígio</option>
        <option value="lydian">Lídio</option>
        <option value="mixolydian">Mixolídio</option>
        <option value="aeolian">Menor Natural (Eólio)</option>
        <option value="harmonic_minor">Menor Harmônica</option>
        <option value="melodic_minor">Menor Melódica (asc)</option>
        <option value="locrian">Lócrio</option>
        <option value="chromatic">Cromática</option>
      </select>

      <label style="margin-top:8px"><strong>Direção</strong></label>
      <select id="direcao">
        <option value="asc">Ascendente</option>
        <option value="desc">Descendente</option>
      </select>

    </div>

        <div class="control">
      <label><strong>Controles</strong></label>
      <button id="btnStart" style="background:#2e7d32;color:white;margin-bottom:8px;">▶ Iniciar Treino</button>
      <button id="btnStop" style="background:#e53935;color:white;margin-bottom:8px;">⏹ Parar</button>
      <button id="btnRepeat" style="background:#6a1b9a;color:white;margin-bottom:8px;" disabled>🔁 Ouvir Nota Novamente</button>
      
      <label style="margin-top:8px"><strong>Tocar tônica antes da nota oculta</strong></label>
      <div class="checkbox-row">
        <input type="checkbox" id="playTonicBefore" checked>
        <label for="playTonicBefore" style="margin:0; font-weight:normal;">Ativado</label>
      </div>

            <label style="margin-top:8px"><strong>Avançar Automaticamente</strong></label>
      <div class="checkbox-row">
        <input type="checkbox" id="autoAdvance">
        <label for="autoAdvance" style="margin:0; font-weight:normal;">Avançar p/ próxima nota após sequência (sem palpite)</label>
      </div>

      <hr style="margin:10px 0; border:none; border-top:1px solid #eee;">

            <label><strong>Tempo (Nota → Sequência)</strong></label>
      <div class="row">
        <input id="delayBeforeRange" type="range" min="0" max="3000" step="50" value="750">
        <input id="delayBeforeNum" type="number" min="0" max="3000" step="50" value="750">
      </div>

            <label style="margin-top:8px"><strong>Tempo (entre notas da sequência)</strong></label>
      <div class="row">
        <input id="delayBetweenRange" type="range" min="25" max="1500" step="25" value="570">
        <input id="delayBetweenNum" type="number" min="25" max="1500" step="25" value="570">
      </div>

            <label style="margin-top:8px"><strong>Tempo (Sequência → Próxima Nota)</strong></label>
      <div class="row">
        <input id="delayAfterRange" type="range" min="0" max="5000" step="50" value="1100">
        <input id="delayAfterNum" type="number" min="0" max="5000" step="50" value="1100">
      </div>
      <div class="small">Você pode arrastar o slider ou digitar o valor numérico — ambos sincronizados. O último slider controla o avanço automático.</div>
    </div>
  </div>

  <div id="paper"></div>
  <div id="status" class="status-default">Áudio Sintetizado (MIDI) pronto. Clique em "Iniciar Treino" para começar.</div>
  <div class="note-buttons" id="noteButtons"></div>

<script>
/* ============================
   Dados e Configurações
   ============================ */
// Base para cálculos musicais (12 notas)
const NOTE_NAMES_BASE = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
// Nomes de notas para a UI (13 notas, incluindo C(5))
const NOTE_NAMES = [...NOTE_NAMES_BASE, "C(5)"]; 
const MODOS = {
  ionian:        [0,2,4,5,7,9,11],
  dorian:        [0,2,3,5,7,9,10],
  phrygian:      [0,1,3,5,7,8,10],
  lydian:        [0,2,4,6,7,9,11],
  mixolydian:    [0,2,4,5,7,9,10],
  aeolian:       [0,2,3,5,7,8,10],
  harmonic_minor:[0,2,3,5,7,8,11],
  melodic_minor: [0,2,3,5,7,9,11], // ascendente
  locrian:       [0,1,3,5,6,8,10],
  chromatic:     [0,1,2,3,4,5,6,7,8,9,10,11]
};

// USANDO SYNTH SIMPLES E ROBUSTO (para garantir que o som funcione)
const synth = new Tone.Synth({
  // Um timbre simples de onda seno, ideal para testes de percepção e confiável
  oscillator: { type: "sine" }, 
  // Envelope mais percussivo para clareza
  envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
}).toDestination();


// Inicializar o áudio
Tone.start();

/* Estado central */
const state = {
  playing: false,
  awaitingGuess: false,
  currentSecretNote: null,
  secretNoteOctave: 4, // Oitava padrão
  selectedNotes: [],
  keyRoot: "C",
  modoAtual: "ionian",
  direction: "asc",
  playTonic: true,
  score: { correct:0, attempts:0 },
  pendingTimeout: null,
  lastGuess: null,
  pianoLoaded: true // Marcado como true para o synth estar sempre pronto
};

/* DOM refs */
const DOM = {
  btnStart: document.getElementById("btnStart"),
  btnStop: document.getElementById("btnStop"),
  btnRepeat: document.getElementById("btnRepeat"),
  autoAdvance: document.getElementById("autoAdvance"),
  statusEl: document.getElementById("status"),
  noteButtonsDiv: document.getElementById("noteButtons"),
  paperEl: document.getElementById("paper"),
  notasSelect: document.getElementById("notas"),
  tomSelect: document.getElementById("tom"),
  modoSelect: document.getElementById("modo"),
  direcaoSelect: document.getElementById("direcao"),
  oitavaSelect: document.getElementById("oitava"),
  playTonicBefore: document.getElementById("playTonicBefore"),
  correctCount: document.getElementById("correctCount"),
  attemptCount: document.getElementById("attemptCount"),
  // sliders + numeric inputs
  delayBeforeRange: document.getElementById("delayBeforeRange"),
  delayBeforeNum: document.getElementById("delayBeforeNum"),
  delayBetweenRange: document.getElementById("delayBetweenRange"),
  delayBetweenNum: document.getElementById("delayBetweenNum"),
  delayAfterRange: document.getElementById("delayAfterRange"),
  delayAfterNum: document.getElementById("delayAfterNum")
};

/* ============================
   Conversões e utilitários musicais
   ============================ */
// CONVERSÃO C(5) -> C5 e C(3), C(4) também são tratados
function letterToScientific(letter, octave){
  if (letter.match(/^C\(\d\)$/)) {
    // CORREÇÃO: O C(5) deve ser UMA OITAVA ACIMA da oitava base selecionada, 
    // exceto se a oitava base for 5 (mantemos 5 como limite superior).
    const targetOctave = (octave < 5) ? (octave + 1) : 5;
    return "C" + targetOctave;
  }
  
  if (letter === "C") {
    // O C puro (tônica) sempre usa a oitava base selecionada
    return "C" + octave;
  }

  // Para as outras notas (C# a B), usa a oitava selecionada
  return letter + octave; 
}

function midiToScientific(m){ 
  const idx = ((m%12)+12)%12; 
  const oct = Math.floor(m/12)-1; 
  return NOTE_NAMES_BASE[idx] + oct; 
}

function scientificToABC(sci){
  const m = sci.match(/^([A-G])(#|b)?(-?\d+)$/);
  if(!m) return sci;
  const letter=m[1], acc=m[2]||"", oct=parseInt(m[3],10);
  const accToken = acc==="#" ? "^" : (acc==="b" ? "_" : "");
  let base;
  if(oct>4){ 
    base = letter.toLowerCase(); 
    if(oct>5) base += "'".repeat(oct-5); 
  } else if(oct<4){ 
    base = letter.toUpperCase() + ",".repeat(4-oct); 
  } else base = letter.toUpperCase();
  return accToken + base;
}

/** Gera a escala em midis com base na tônica + modo, usando a oitava de referência */
function generateModeScaleMidi(root, modo, octave){
  const rootIdx = NOTE_NAMES_BASE.indexOf(root);
  const tonicMidi = 12*(octave + 1) + rootIdx;
  const pattern = MODOS[modo] || [];
  const midis = pattern.map(i => tonicMidi + i);
  return { midis, tonicMidi };
}

/** * Constroi a sequência COMPLETA (Tônica -> Escala -> Nota Secreta -> Escala -> Tônica) 
 * A tônica de início/fim define a oitava da escala.
 */
function buildFullSequence(selectedNoteName, scaleData, dir, baseOctave){
  const { midis, tonicMidi } = scaleData;
  
  let targetMidi;
  
  // 1. Encontra o MIDI da nota secreta (na oitava correta)
  if (selectedNoteName.match(/^C\(\d\)$/)) {
    const explicitOctave = parseInt(selectedNoteName.match(/\((\d)\)/)[1], 10);
    targetMidi = 12 * (explicitOctave + 1) + NOTE_NAMES_BASE.indexOf('C');
  } else {
    // Aplica a mesma lógica de oitava que em letterToScientific para C
    let effectiveOctave = baseOctave;
    if (selectedNoteName === "C" && baseOctave === 5) {
      effectiveOctave = 4;
    }

    const rootIdx = NOTE_NAMES_BASE.indexOf(selectedNoteName);
    targetMidi = 12 * (effectiveOctave + 1) + rootIdx;
  }

  // 2. Estende a escala para a próxima oitava (para o fim da sequência ascendente)
  let fullScaleMidis = [...midis];
  const tonicAbove = tonicMidi + 12;
  
  // Adiciona a próxima oitava da escala para ter cobertura
  fullScaleMidis = fullScaleMidis.concat(midis.map(m => m + 12));
  
  // 3. Adiciona a Nota Secreta (Target) e a Tônica Superior na lista e ordena
  if(!fullScaleMidis.includes(targetMidi)) {
    fullScaleMidis.push(targetMidi);
  }
  if(!fullScaleMidis.includes(tonicAbove)) {
    fullScaleMidis.push(tonicAbove);
  }
  
  // Remove duplicatas e ordena
  fullScaleMidis = [...new Set(fullScaleMidis)].sort((a, b) => a - b);
  
  // 4. Constrói a sequência com início e fim definidos (TÔNICA)
  const startTonic = tonicMidi;
  const endTonic = tonicAbove;

  // Filtra as notas da escala estendida que estão no range [startTonic, endTonic]
  let notesInRange = fullScaleMidis.filter(m => m >= startTonic && m <= endTonic);
  
  // GARANTE QUE A NOTA SECRETA ESTÁ NO RANGE, MESMO QUE FORA DA OITAVA DE REFERÊNCIA
  if (!notesInRange.includes(targetMidi)) {
    if (targetMidi < startTonic) {
      // Se a nota secreta for mais grave que a tônica de início (ex: C(3) e tônica C4)
      notesInRange = fullScaleMidis.filter(m => m >= targetMidi && m <= endTonic);
      notesInRange.unshift(startTonic); 
    } else if (targetMidi > endTonic) {
      // Se a nota secreta for mais aguda que a tônica de fim (ex: C(6) e tônica C5)
      notesInRange = fullScaleMidis.filter(m => m >= startTonic && m <= targetMidi);
      notesInRange.push(endTonic); 
    }
    notesInRange = [...new Set(notesInRange)].sort((a, b) => a - b);
  }

  // Remove notas da escala se a nota secreta for a mesma classe de pitch em oitava diferente
  let finalSeq = [...notesInRange]; 
  if (targetMidi !== startTonic && targetMidi !== endTonic) {
    const targetPitch = targetMidi % 12;
    const noteToRemove = notesInRange.find(m => m !== targetMidi && m % 12 === targetPitch);
    if (noteToRemove) {
      finalSeq = finalSeq.filter(m => m !== noteToRemove);
      finalSeq.push(targetMidi);
      finalSeq.sort((a, b) => a - b);
    }
  }


  if(dir === "asc"){
    // Ordem: Tônica Base (C4) -> ... -> Tônica Oitava Acima (C5)
    let resultAsc = finalSeq.filter(m => m >= startTonic && m <= endTonic);
    if(resultAsc[0] !== startTonic) resultAsc.unshift(startTonic);
    if(resultAsc[resultAsc.length-1] !== endTonic) resultAsc.push(endTonic);
    
    // Adicionar Target se foi perdido (ex: C(5) é o target e C5 é o endTonic)
    if (!resultAsc.includes(targetMidi) && targetMidi >= startTonic && targetMidi <= endTonic) {
      resultAsc.push(targetMidi);
    }
    
    return [...new Set(resultAsc)].sort((a,b) => a-b);

  } else { // "desc"
    // Ordem: Tônica Oitava Acima (C5) -> ... -> Tônica Base (C4)
    let resultDesc = finalSeq.filter(m => m >= startTonic && m <= endTonic);
    if(resultDesc[0] !== startTonic) resultDesc.unshift(startTonic);
    if(resultDesc[resultDesc.length-1] !== endTonic) resultDesc.push(endTonic);
    
    // Adicionar Target se foi perdido
    if (!resultDesc.includes(targetMidi) && targetMidi >= startTonic && targetMidi <= endTonic) {
      resultDesc.push(targetMidi);
    }
    
    return [...new Set(resultDesc)].sort((a,b) => b-a);
  }
}


/* Convert midis -> ABC string tokens */
function midisToABCTokens(midis){
  return midis.map(m => scientificToABC(midiToScientific(m))).join(" ");
}

function renderABC(tokens, key){
  if(!tokens || tokens.length === 0){ DOM.paperEl.innerHTML = ""; return; }
  const abc = `X:1\nL:1/4\nK:${key}\n${tokens}`;
  ABCJS.renderAbc("paper", abc);
}

/* ============================
   ÁUDIO: tocar nota
   ============================ */
function playNoteScientific(sci, dur="8n"){
  try {
    // Usa o synth simples (som tipo MIDI / Acordeon)
    synth.triggerAttackRelease(sci, dur);
    return true;
  } catch (error) {
    console.error("Erro ao tocar nota:", sci, error);
    return false;
  }
}

/* Toca sequência (array de scientific strings), respeitando delayBetween (ms) */
function playScientificSequence(scientificNotes) {
  return new Promise(async (resolve) => {
    const delayBetween = parseInt(DOM.delayBetweenNum.value, 10);
    
    for(let i = 0; i < scientificNotes.length; i++) {
      if(!state.playing) break;
      
      const note = scientificNotes[i];
      // Tocar a nota
      playNoteScientific(note, "8n");
      
      // Esperar o intervalo entre notas (exceto para a última nota)
      if(i < scientificNotes.length - 1) {
        await new Promise(r => setTimeout(r, delayBetween));
      }
    }
    
    resolve();
  });
}

/* Toca nota oculta */
function playHiddenScientific(sci){
  playNoteScientific(sci, "4n");
}

/* ============================
   UI helpers (placar, botões)
   ============================ */
function updateScoreboard(){
  DOM.correctCount.textContent = state.score.correct;
  DOM.attemptCount.textContent = state.score.attempts;
}

function resetScore(){
  state.score = { correct:0, attempts:0 };
  updateScoreboard();
}

/* Atualiza botões de resposta com apenas notas selecionadas */
function updateResponseButtons(){
  const opts = Array.from(DOM.notasSelect.selectedOptions).map(o => o.value);
  DOM.noteButtonsDiv.innerHTML = "";
  if(opts.length === 0){
    DOM.statusEl.textContent = "Selecione notas para aparecerem como botões de resposta.";
    return;
  }
  opts.forEach(n => {
    const b = document.createElement("button");
    b.textContent = n;
    b.dataset.note = n;
    b.onclick = onGuess;
    DOM.noteButtonsDiv.appendChild(b);
  });
  updateUIState();
}

/* Habilita / desabilita elementos conforme estado */
function updateUIState(){
  // O botão de iniciar está sempre habilitado agora que não há carregamento de piano
  DOM.btnStart.disabled = state.playing; 
  DOM.btnStop.disabled = !state.playing;
  // No modo automático, o botão de repetir nota só deve estar disponível enquanto o usuário está aguardando (antes da sequência)
  DOM.btnRepeat.disabled = !(state.playing && state.awaitingGuess);
  
  const configDisabled = state.playing && !state.awaitingGuess; // Permite alterar configurações se estiver aguardando (Modo Manual)
  DOM.notasSelect.disabled = configDisabled;
  DOM.tomSelect.disabled = configDisabled;
  DOM.modoSelect.disabled = configDisabled;
  DOM.direcaoSelect.disabled = configDisabled;
  // A oitava só deve ser desabilitada se a nota secreta for C(x) fixo.
  DOM.oitavaSelect.disabled = configDisabled || (state.currentSecretNote && state.currentSecretNote.match(/^C\(\d\)$/)); 
  DOM.playTonicBefore.disabled = configDisabled;
  DOM.autoAdvance.disabled = configDisabled; 
  
  const answerButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  // Botões de resposta desabilitados se não estiver esperando palpite
  answerButtons.forEach(b => { 
    b.disabled = !state.awaitingGuess;
    if (state.awaitingGuess) {
      b.classList.remove("correct", "wrong");
    }
  });
}

/* ============================
   Fluxo principal
   ============================ */

async function startRound(){
  if(state.playing) return;
  const selOpts = Array.from(DOM.notasSelect.selectedOptions);
  if(selOpts.length === 0){ 
    alert("Selecione pelo menos uma nota!"); 
    return; 
  }
  
  state.playing = true;
  state.selectedNotes = selOpts.map(o => o.value);
  state.keyRoot = DOM.tomSelect.value;
  state.modoAtual = DOM.modoSelect.value;
  state.direction = DOM.direcaoSelect.value;
  state.secretNoteOctave = parseInt(DOM.oitavaSelect.value, 10);
  state.playTonic = DOM.playTonicBefore.checked;
  
  DOM.paperEl.innerHTML = "";
  DOM.statusEl.textContent = "Treino ativo — tocando nota oculta...";
  DOM.statusEl.className = "status-awaiting";
  updateUIState();

  // Toca a primeira nota
  await playNextNote();
}

function stopAll(){
  state.playing = false;
  state.awaitingGuess = false;
  state.currentSecretNote = null;
  if(state.pendingTimeout) { 
    clearTimeout(state.pendingTimeout); 
    state.pendingTimeout = null; 
  }
  DOM.paperEl.innerHTML = "";
  DOM.statusEl.textContent = "Parado.";
  DOM.statusEl.className = "status-default";
  updateUIState();
}

async function playNextNote() {
  if(!state.playing) return;
  
  // Seleciona a nota e determina a oitava científica
  state.currentSecretNote = state.selectedNotes[Math.floor(Math.random() * state.selectedNotes.length)];
  const secretSci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);

  state.awaitingGuess = true;
  state.lastGuess = null;
  
  // Desabilita a seleção de oitava se a nota for C(x), pois a oitava é fixa
  DOM.oitavaSelect.disabled = state.currentSecretNote.match(/^C\(\d\)$/);

  // Verifica o modo automático para atualizar o status/UI
  if (DOM.autoAdvance.checked) {
    DOM.statusEl.textContent = "🎧 Modo Automático: Tocando nota oculta. Aguarde a sequência...";
  } else {
    DOM.statusEl.textContent = "🎧 Modo Manual: Ouça a nota oculta. Clique na nota que acha que foi.";
  }
  DOM.statusEl.className = "status-awaiting";
  DOM.paperEl.innerHTML = "";

  // Limpar cores dos botões
  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  allButtons.forEach(btn => {
    btn.classList.remove("correct", "wrong");
  });

  // Pequeno delay antes de tocar
  await new Promise(r => setTimeout(r, 100));

  // tocar tônica antes se ativado
  if(state.playTonic){
    // Tônica sempre baseada na OITAVA SELECIONADA.
    const tonicOctave = state.secretNoteOctave; 
    const tonicMidi = 12 * (tonicOctave + 1) + NOTE_NAMES_BASE.indexOf(state.keyRoot);
    const keyRootSci = midiToScientific(tonicMidi);
    playNoteScientific(keyRootSci, "4n");
    await new Promise(r => setTimeout(r, 800)); // Delay maior após a tônica
  }

  // tocar a nota secreta
  playHiddenScientific(secretSci);

  updateUIState();

  // Dispara a sequência automaticamente se autoAdvance estiver marcado
  if (DOM.autoAdvance.checked) {
    const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
    await new Promise(r => setTimeout(r, 800 + delayBefore)); // Aguarda nota secreta + delay

    if (state.playing) {
      DOM.statusEl.textContent = "🎵 Modo Automático: Tocando sequência...";
      // Chama a lógica de acerto para tocar a sequência e avançar
      autoAdvanceSequence();
    }
  }
}

/* Funcao para avançar no modo automático, simulando um acerto imediato */
async function autoAdvanceSequence() {
  if(!state.playing) return;
  
  state.awaitingGuess = false;
  // Simula um palpite correto
  state.lastGuess = state.currentSecretNote;
  state.score.attempts++;
  state.score.correct++;
  updateScoreboard();

  // Desabilitar botões enquanto toca sequência
  updateUIState();
  
  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

  // determinar comportamento melodic_minor descendente -> usar aeolian para descida:
  let modeToGenerate = state.modoAtual;
  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

  // A oitava base para a escala é SEMPRE a oitava selecionada.
  const baseOctaveForScale = state.secretNoteOctave;
  // gerar escala na oitava base (a oitava da maioria das notas)
  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, baseOctaveForScale);
  
  // CHAMA A NOVA FUNÇÃO buildFullSequence
  const seqMidis = buildFullSequence(state.currentSecretNote, scaleData, state.direction, baseOctaveForScale);
  const scientificSeq = seqMidis.map(m => midiToScientific(m));
  const abcTokens = midisToABCTokens(seqMidis);

  DOM.paperEl.innerHTML = "";
  renderABC(abcTokens, state.keyRoot);

  DOM.statusEl.textContent = "🎵 Modo Automático: Tocando sequência...";
  DOM.statusEl.className = "status-correct";

  // Toca a sequência
  await playScientificSequence(scientificSeq);
  
  // Avançar para próxima nota após delay (USA O SLIDER delayAfter)
  if(state.playing) {
    state.pendingTimeout = setTimeout(async () => {
      state.pendingTimeout = null;
      if(state.playing) {
        await playNextNote();
      }
    }, delayAfter);
  }
}

/* repetir nota oculta */
function repeatNote(){
  if(!state.awaitingGuess || !state.currentSecretNote){ 
    DOM.statusEl.textContent = "Nenhuma nota ativa para repetir."; 
    return; 
  }
  const sci = letterToScientific(state.currentSecretNote, state.secretNoteOctave);
  playHiddenScientific(sci);
}

/* quando usuário clica em uma nota (tenta adivinhar) - SOMENTE MODO MANUAL */
async function onGuess(e){
  // Bloqueia palpite se não estiver esperando ou se estiver em modo automático
  if(!state.awaitingGuess || !state.playing || DOM.autoAdvance.checked) return;
  
  const guessed = e.currentTarget.dataset.note;
  state.awaitingGuess = false;
  state.lastGuess = guessed;
  state.score.attempts++;
  updateScoreboard();
  updateUIState();

  // Destacar o botão clicado e a resposta correta
  const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
  allButtons.forEach(btn => {
    if(btn.dataset.note === guessed) {
      btn.classList.add(guessed === state.currentSecretNote ? "correct" : "wrong");
    }
    if(btn.dataset.note === state.currentSecretNote && guessed !== state.currentSecretNote) {
      btn.classList.add("correct");
    }
  });

  const delayBefore = parseInt(DOM.delayBeforeNum.value, 10) || 0;
  const delayAfter = parseInt(DOM.delayAfterNum.value, 10) || 0;

  // determinar comportamento melodic_minor descendente -> usar aeolian para descida:
  let modeToGenerate = state.modoAtual;
  if(state.modoAtual === "melodic_minor" && state.direction === "desc") modeToGenerate = "aeolian";

  // A oitava base para a escala é SEMPRE a oitava selecionada.
  const baseOctaveForScale = state.secretNoteOctave;
  // gerar escala
  const scaleData = generateModeScaleMidi(state.keyRoot, modeToGenerate, baseOctaveForScale);
  
  // CHAMA A NOVA FUNÇÃO buildFullSequence
  const seqMidis = buildFullSequence(state.currentSecretNote, scaleData, state.direction, baseOctaveForScale);
  const scientificSeq = seqMidis.map(m => midiToScientific(m));
  const abcTokens = midisToABCTokens(seqMidis);

  DOM.paperEl.innerHTML = "";
  renderABC(abcTokens, state.keyRoot);

  if(guessed === state.currentSecretNote){
    // acerto
    state.score.correct++;
    updateScoreboard();
    DOM.statusEl.textContent = "✅ Acertou! Preparando para tocar a sequência...";
    DOM.statusEl.className = "status-correct";
    
    // Espera antes da sequência
    if(delayBefore > 0) {
      await new Promise(r => setTimeout(r, delayBefore));
    }
    
    // Toca a sequência
    if(state.playing) {
      DOM.statusEl.textContent = "🎵 Tocando sequência...";
      await playScientificSequence(scientificSeq);
    }
    
    if(state.pendingTimeout) { 
      clearTimeout(state.pendingTimeout); 
      state.pendingTimeout = null; 
    }
    
    // Avançar para próxima nota após delay
    if(state.playing) {
      state.pendingTimeout = setTimeout(async () => {
        state.pendingTimeout = null;
        if(state.playing) {
          await playNextNote();
        }
      }, delayAfter);
    }
    
  } else {
    // erro
    DOM.statusEl.textContent = `❌ Errado — a nota correta era ${state.currentSecretNote}.`;
    DOM.statusEl.className = "status-wrong";
    
    if(state.pendingTimeout) { 
      clearTimeout(state.pendingTimeout); 
      state.pendingTimeout = null; 
    }
    
    // No caso de erro, avançar para a próxima nota após delay (3 segundos fixos)
    if(state.playing) {
      state.pendingTimeout = setTimeout(async () => {
        state.pendingTimeout = null;
        if(state.playing) {
          await playNextNote();
        }
      }, 3000); // 3 segundos para ler a resposta
    }
  }
}

/* ============================
   Eventos
   ============================ */

/* Botões principais */
DOM.btnStart.addEventListener("click", startRound);
DOM.btnStop.addEventListener("click", stopAll);
DOM.btnRepeat.addEventListener("click", repeatNote);

/* Select all / clear all notes */
document.getElementById("selAllBtn").addEventListener("click", () => {
  Array.from(DOM.notasSelect.options).forEach(o => o.selected = true);
  updateResponseButtons();
});
document.getElementById("clearAllBtn").addEventListener("click", () => {
  Array.from(DOM.notasSelect.options).forEach(o => o.selected = false);
  updateResponseButtons();
});

/* Update response buttons when selection changes */
DOM.notasSelect.addEventListener("change", updateResponseButtons);

/* Lógica para quando o modo automático é ativado */
DOM.autoAdvance.addEventListener("change", () => {
  // Se ativar o autoAdvance e estiver esperando um palpite, avança para a sequência
  if (DOM.autoAdvance.checked && state.playing && state.awaitingGuess) {
    // Simula o avanço automático imediatamente
    const allButtons = DOM.noteButtonsDiv.querySelectorAll("button");
    allButtons.forEach(btn => {
      if(btn.dataset.note === state.currentSecretNote) {
        btn.classList.add("correct");
      }
    });
    autoAdvanceSequence();
  } else if (DOM.autoAdvance.checked && state.playing && !state.awaitingGuess) {
    // Se a sequência já tocou/está tocando, o próximo round será automático
    // A lógica de avanço já está no setTimeout após a sequência
  }
  updateUIState();
});

/* Sliders + Numeric inputs sync */
function syncRangeAndNum(rangeEl, numEl){
  rangeEl.addEventListener("input", () => {
    numEl.value = rangeEl.value;
  });
  numEl.addEventListener("input", () => {
    let v = parseInt(numEl.value, 10);
    if(isNaN(v)) v = parseInt(rangeEl.min,10);
    v = Math.max(parseInt(rangeEl.min,10), Math.min(parseInt(rangeEl.max,10), v));
    numEl.value = v;
    rangeEl.value = v;
  });
}

syncRangeAndNum(DOM.delayBeforeRange, DOM.delayBeforeNum);
syncRangeAndNum(DOM.delayBetweenRange, DOM.delayBetweenNum);
syncRangeAndNum(DOM.delayAfterRange, DOM.delayAfterNum); // O slider do avanço automático

/* Inicialização */
document.addEventListener("DOMContentLoaded", () => {
  updateResponseButtons();
  updateScoreboard();
  updateUIState(); 
});

</script>
</body>
</html>
