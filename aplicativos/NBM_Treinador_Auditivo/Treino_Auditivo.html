<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>üéµ Treino Auditivo com Timbres</title>
  <style>
    body { font-family: sans-serif; background: #f0f0f0; padding: 20px; }
    h1 { color: #333; }
    select, button { margin: 5px; padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; }
    select:focus, button:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); }
    button { background-color: #007bff; color: white; transition: background-color 0.2s ease; }
    button:hover { background-color: #0056b3; }
    .result { margin-top: 15px; font-size: 20px; font-weight: bold; padding: 10px; border-radius: 5px; }
    #stats { margin-top: 10px; font-size: 18px; background-color: #e9ecef; padding: 10px; border-radius: 5px; }
    #buttons { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px; }
    #buttons button { flex: 1 1 auto; min-width: 120px; max-width: 180px; background-color: #6c757d; }
    #buttons button:hover { background-color: #5a6268; }

    /* Estilo para o bot√£o de ativar/desativar autom√°tico */
    #toggleAutoPlayNextNoteButton.active {
        background-color: #28a745; /* Verde quando ativo */
        color: white;
    }
    #toggleAutoPlayNextNoteButton.inactive {
        background-color: #dc3545; /* Vermelho quando inativo */
        color: white;
    }

    /* Estilos para o tutorial */
    .tutorial-section {
        background: #fff;
        border-radius: 8px;
        padding: 20px;
        margin-top: 30px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tutorial-section h2 {
        color: #007bff;
        margin-top: 0;
    }
    .tutorial-section h3 {
        color: #555;
    }
    .tutorial-section ul {
        list-style-type: disc;
        margin-left: 20px;
        padding-left: 0;
    }
    .tutorial-section li {
        margin-bottom: 8px;
    }

    /* Estilos para a sele√ß√£o de notas */
    #noteSelection {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e2e6ea;
    }
    #noteSelection label {
        display: inline-block;
        margin-right: 15px;
        margin-bottom: 8px;
        font-size: 16px;
        cursor: pointer;
    }
    #noteSelection input[type="checkbox"] {
        margin-right: 5px;
        transform: scale(1.2); /* Aumenta o tamanho do checkbox */
    }
    #noteSelection button {
        margin-left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        background-color: #6c757d;
        border: none;
        border-radius: 4px;
        color: white;
        cursor: pointer;
    }
    #noteSelection button:hover {
        background-color: #5a6268;
    }

    /* Estilos para o registro de tempo */
    #trainingTimer {
        margin-top: 10px;
        font-size: 1.1em;
        font-weight: bold;
        color: #0056b3;
    }
    #trainingTimer .active-session {
        color: #28a745;
    }
    #trainingControls {
        margin-top: 10px;
    }
    #trainingControls button {
        background-color: #28a745;
    }
    #trainingControls button:hover {
        background-color: #218838;
    }
    #trainingControls button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    #trainingControls button.stop {
        background-color: #dc3545;
    }
    #trainingControls button.stop:hover {
        background-color: #c82333;
    }

    /* Estilos para as estat√≠sticas por nota */
    #noteStatsSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #noteStatsSection h3 {
        color: #007bff;
        margin-top: 0;
        margin-bottom: 15px;
    }
    .note-stat-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        font-size: 1em;
    }
    .note-stat-item strong {
        min-width: 60px;
        margin-right: 10px;
        text-align: right;
    }
    .progress-bar-container {
        flex-grow: 1;
        background-color: #e9ecef;
        border-radius: 5px;
        overflow: hidden; /* Garante que a barra interna n√£o vaze */
        height: 20px;
        position: relative;
    }
    .progress-bar-fill {
        height: 100%;
        background-color: #28a745; /* Verde para acertos */
        width: 0%; /* Ser√° preenchido por JS */
        position: absolute;
        left: 0;
        top: 0;
        transition: width 0.3s ease-out;
    }
    .progress-bar-error {
        height: 100%;
        background-color: #dc3545; /* Vermelho para erros */
        width: 0%; /* Ser√° preenchido por JS */
        position: absolute;
        right: 0;
        top: 0;
        transition: width 0.3s ease-out;
    }
    .progress-bar-text {
        position: absolute;
        width: 100%;
        text-align: center;
        line-height: 20px;
        color: #333;
        font-size: 0.85em;
        font-weight: bold;
        text-shadow: 0 0 2px rgba(255,255,255,0.7);
        z-index: 1;
    }
    #notesToImprove {
        margin-top: 20px;
        padding: 10px;
        background-color: #fff3cd; /* Amarelo claro para sugest√µes */
        border: 1px solid #ffeeba;
        border-radius: 5px;
        color: #856404;
    }
    #notesToImprove strong {
        color: #6a5303;
    }

    /* Estilos para o modo de foco */
    #focusModeControls {
        margin-top: 20px;
        padding: 15px;
        background-color: #eaf7ff; /* Azul claro */
        border-radius: 8px;
        border: 1px solid #cce5ff;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }
    #focusModeControls button {
        background-color: #6f42c1; /* Roxo */
    }
    #focusModeControls button:hover {
        background-color: #563198;
    }
    #focusModeControls button.active {
        background-color: #20c997; /* Verde-√°gua quando ativo */
    }
    #focusModeControls button.active:hover {
        background-color: #17a27b;
    }
    #focusModeStatus {
        font-weight: bold;
        color: #0056b3;
    }

    /* Estilos para o hist√≥rico de sess√µes */
    #sessionHistorySection {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #sessionHistorySection h3 {
        color: #007bff;
        margin-top: 0;
        margin-bottom: 15px;
    }
    #sessionHistoryList {
        list-style: none;
        padding: 0;
    }
    .session-item {
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        padding: 15px;
        font-size: 0.95em;
        line-height: 1.5;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .session-item strong {
        color: #333;
    }
    .session-item span {
        display: block;
        margin-bottom: 3px;
    }
    .session-item .focus-notes {
        font-style: italic;
        color: #6f42c1; /* Roxo para as notas focadas */
    }

    /* Estilos para a se√ß√£o de metas */
    #goalsSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #e6ffe6; /* Verde claro */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border: 1px solid #c0ebc0;
    }
    #goalsSection h3 {
        color: #28a745; /* Verde escuro */
        margin-top: 0;
        margin-bottom: 15px;
    }
    #goalsSection label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    #goalsSection input[type="number"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        width: 80px;
        margin-right: 10px;
    }
    #goalsSection button {
        background-color: #28a745;
        margin-top: 10px;
        padding: 10px 15px;
    }
    #goalsSection button:hover {
        background-color: #218838;
    }
    .goal-status {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        font-weight: bold;
        background-color: #d4edda; /* Sucesso */
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    .goal-status.warning {
        background-color: #fff3cd; /* Aviso */
        color: #856404;
        border: 1px solid #ffeeba;
    }
    
    /* Novos estilos para as op√ß√µes de som e feedback visual */
    #audioFeedbackOptions, #autoPlayOptions {
        margin-top: 20px;
        padding: 15px;
        background-color: #f0f8ff; /* Azul clarinho */
        border-radius: 8px;
        border: 1px solid #b0d8f7;
    }
    #audioFeedbackOptions label, #autoPlayOptions label {
        margin-right: 15px;
        font-size: 16px;
        cursor: pointer;
    }
    #audioFeedbackOptions input[type="checkbox"], #autoPlayOptions input[type="checkbox"] {
        margin-right: 5px;
        transform: scale(1.2);
    }
    #autoPlayOptions select {
        width: auto;
    }

    /* Estilos para o ranking */
    #topScoresSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #fefbe6; /* Amarelo muito claro */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border: 1px solid #fce883;
    }
    #topScoresSection h3 {
        color: #d4ac00; /* Dourado */
        margin-top: 0;
        margin-bottom: 15px;
    }
    #topScoresList {
        list-style: none;
        padding: 0;
    }
    .top-score-item {
        background-color: #fff;
        border: 1px solid #ffe99b;
        border-radius: 5px;
        margin-bottom: 8px;
        padding: 12px;
        font-size: 0.9em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .top-score-item span {
        font-weight: bold;
        color: #333;
    }
    .top-score-item .score-details {
        font-weight: normal;
        color: #666;
        font-size: 0.85em;
    }

    /* Estilos para o controle de volume */
    #feedbackVolumeControl {
        margin-top: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    #feedbackVolumeControl input[type="range"] {
        flex-grow: 1;
        width: 100%;
        -webkit-appearance: none;
        height: 8px;
        border-radius: 5px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }
    #feedbackVolumeControl input[type="range"]:hover {
        opacity: 1;
    }
    #feedbackVolumeControl input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
    }
    #feedbackVolumeControl input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
    }
    #feedbackVolumeControl #feedbackVolumeValue {
        font-weight: bold;
        min-width: 40px;
        text-align: right;
    }
  </style>
</head>
<body>
  <h1>üéµ Treino Auditivo com Timbres</h1>

  <label for="instrument">üéº Timbre:</label>
  <select id="instrument" onchange="changeInstrument()">
    <option value="acoustic_grand_piano-mp3">üéπ Piano (Acoustic Grand)</option>
    <option value="acoustic_guitar_nylon-mp3">üé∏ Guitar (Acoustic Nylon)</option>
    <option value="cello-mp3">üéª Cello</option>
    <option value="flute-mp3">üé∂ Flauta</option>
    <option value="church_organ-mp3">‚õ™ √ìrg√£o de Igreja</option>
    <option value="trumpet-mp3">üé∫ Trompete</option>
    <option value="tenor_sax-mp3">üé∑ Saxofone Tenor</option>
  </select>

  <label for="octave">üé∂ Oitava:</label>
  <select id="octave" onchange="changeOctave()">
    <option value="3">3</option>
    <option value="4" selected>4</option>
    <option value="5">5</option>
  </select>

  <label for="sequenceType">üîÑ Sequ√™ncia de Notas:</label>
  <select id="sequenceType" onchange="changeSequenceType()">
    <option value="random">Aleat√≥ria</option>
    <option value="fourths">Intervalo de Quartas</option>
    <option value="fifths">Intervalo de Quintas</option>
    <option value="chromaticAsc">Crom√°tica Ascendente</option>
    <option value="chromaticDesc">Crom√°tica Descendente</option>
  </select>

  <button onclick="playNote()">üîä Tocar Nota</button>
  <button onclick="resetCounters()">üîÑ Reiniciar Contadores</button>
  
  <div id="autoPlayOptions">
      <h3>Op√ß√µes de Reprodu√ß√£o Autom√°tica:</h3>
      <button id="toggleAutoPlayNextNoteButton" onclick="toggleAutoPlayNextNote()" class="inactive">
          ‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Desativado)
      </button>
      <label for="autoPlayDelay">Atraso (segundos):</label>
      <select id="autoPlayDelay" onchange="saveSetting('autoPlayDelay', this.value)">
          <option value="1">1</option>
          <option value="1.5" selected>1.5</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
      </select>
      <br><br>
      <label>
          <input type="checkbox" id="hideVisualFeedback" onchange="saveSetting('hideVisualFeedback', this.checked)">
          Ocultar feedback visual (Modo Auto)
      </label>
  </div>

  <div id="audioFeedbackOptions">
      <h3>Op√ß√µes de Feedback Sonoro:</h3>
      <label>
          <input type="checkbox" id="playCorrectSound" onchange="saveSetting('playCorrectSound', this.checked)">
          Tocar som de acerto
      </label>
      <label>
          <input type="checkbox" id="playWrongSound" onchange="saveSetting('playWrongSound', this.checked)">
          Tocar som de erro
      </label>
      <div id="feedbackVolumeControl">
          <label for="feedbackVolume">Volume dos Sons de Feedback:</label>
          <input type="range" id="feedbackVolume" min="0" max="1" step="0.05" value="0.5" oninput="updateFeedbackVolume(this.value)">
          <span id="feedbackVolumeValue">50%</span>
      </div>
  </div>

  <div id="noteSelection">
    <h3>üéØ Selecionar Notas para Estudo:</h3>
    <div id="noteCheckboxes">
      </div>
    <button onclick="selectAllNotes()">Selecionar Todas</button>
    <button onclick="clearAllNotes()">Limpar Sele√ß√£o</button>
  </div>

  <div id="trainingControls">
      <button id="startSessionBtn" onclick="startTrainingSession()">‚ñ∂Ô∏è Iniciar Sess√£o</button>
      <button id="endSessionBtn" onclick="endTrainingSession()" class="stop" disabled>‚èπÔ∏è Finalizar Sess√£o</button>
      <div id="trainingTimer">Tempo total de treino: 00h 00m 00s</div>
  </div>

  <div id="buttons"></div>
  <div class="result" id="result"></div>
  <div id="stats"></div>

  <div id="noteStatsSection">
    <h3>üìà Desempenho por Nota</h3>
    <div id="notePerformanceChart">
      </div>
    <div id="notesToImprove">
      <strong>Sugest√£o para Focar:</strong> <span id="notesToImproveList">Nenhuma nota para sugerir ainda.</span>
    </div>
    <button onclick="resetNoteStats()">Limpar Estat√≠sticas por Nota</button>
  </div>

  <div id="focusModeControls">
      <button id="toggleFocusModeButton" onclick="toggleFocusMode()">
        üéØ Ativar Modo Foco nas Notas Fracas (Desativado)
      </button>
      <span id="focusModeStatus"></span>
  </div>

  <div id="goalsSection">
    <h3>üèÖ Minhas Metas de Treino</h3>
    <div>
        <label for="minSessionTime">Tempo m√≠nimo por sess√£o (minutos):</label>
        <input type="number" id="minSessionTime" value="10" min="1">
    </div>
    <div>
        <label for="minAccuracy">Precis√£o m√≠nima geral (%):</label>
        <input type="number" id="minAccuracy" value="80" min="0" max="100">
    </div>
    <button onclick="saveGoals()">Definir Metas</button>
    <div id="currentGoalsStatus" class="goal-status">
        </div>
  </div>

  <div id="sessionHistorySection">
    <h3>üìä Hist√≥rico de Sess√µes de Treino</h3>
    <ul id="sessionHistoryList">
      </ul>
    <button onclick="clearSessionHistory()">Limpar Hist√≥rico de Sess√µes</button>
  </div>

  <div id="topScoresSection">
    <h3>üèÜ Melhores Pontua√ß√µes (Ranking de Precis√£o)</h3>
    <ul id="topScoresList">
      </ul>
    <button onclick="clearTopScores()">Limpar Ranking</button>
  </div>

  <div class="tutorial-section">
    <h2>üéµ Treino Auditivo com Timbres: Guia Completo</h2>
    <p>Boas-vindas! Este aplicativo foi desenvolvido para aprimorar sua percep√ß√£o auditiva de notas musicais em diversos timbres. Pratique diariamente e acompanhe seu progresso!</p>

    <h3>üöÄ Come√ßando a Treinar</h3>
    <ul>
      <li><strong>üéº Timbre:</strong> Escolha o instrumento que deseja para o treino (Piano, Viol√£o, Cello, Flauta, etc.).</li>
      <li><strong>üé∂ Oitava:</strong> Selecione a oitava das notas que ser√£o tocadas.</li>
      <li><strong>üîÑ Sequ√™ncia de Notas:</strong>
        <ul>
          <li><strong>Aleat√≥ria:</strong> Notas s√£o tocadas em ordem aleat√≥ria, usando a sequ√™ncia que voc√™ j√° conhece (D√≥, F√°‚ôØ, L√°, etc.).</li>
          <li><strong>Intervalo de Quartas/Quintas:</strong> As notas seguem a sequ√™ncia de quartas ou quintas perfeitas (C-F-Bb, C-G-D, etc.).</li>
          <li><strong>Crom√°tica Ascendente/Descendente:</strong> As notas s√£o tocadas em ordem sequencial da escala crom√°tica, para cima ou para baixo.</li>
        </ul>
      </li>
      <li><strong>üîä Tocar Nota:</strong> Clique neste bot√£o (ou pressione a <kbd>Barra de Espa√ßo</kbd>) para ouvir uma nova nota.</li>
      <li><strong>‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico:</strong> Ative este modo para que uma nova nota seja tocada automaticamente ap√≥s cada tentativa (certa ou errada). Desative para controle manual.</li>
      <li><strong>üîÑ Reiniciar Contadores:</strong> Zera todas as suas estat√≠sticas de acertos e erros.</li>
    </ul>

    <h3>‚å®Ô∏è Fun√ß√µes das Teclas do Teclado</h3>
    <p>Para agilizar seu treino, voc√™ pode usar as seguintes teclas:</p>
    <ul>
      <li><kbd>Barra de Espa√ßo</kbd> (<kbd>Spacebar</kbd>): Toca uma **nova nota**.</li>
      <li><kbd>Enter</kbd>: **Repete** a nota tocada no momento e **mostra qual √© a nota**. √ötil se voc√™ n√£o tem certeza e quer uma segunda chance para identificar. Esta repeti√ß√£o **n√£o afeta** seus contadores de estat√≠sticas.</li>
      <li><kbd>Backspace</kbd>: Apenas **repete** a nota tocada no momento, **sem revelar** qual √© e **sem afetar** seus contadores. Perfeito para uma audi√ß√£o extra.</li>
      <li><strong>Teclas de Notas</strong> (<kbd>C</kbd>, <kbd>J</kbd>, <kbd>A</kbd>, <kbd>E</kbd>, <kbd>D</kbd>, <kbd>K</kbd>, <kbd>B</kbd>, <kbd>I</kbd>, <kbd>G</kbd>, <kbd>U</kbd>, <kbd>F</kbd>, <kbd>L</kbd>): Use essas teclas para **responder** qual nota voc√™ ouviu. O mapeamento √© fixo e segue a sua prefer√™ncia:
        <ul>
          <li><kbd>C</kbd> = D√≥</li>
          <li><kbd>J</kbd> = F√°‚ôØ</li>
          <li><kbd>A</kbd> = L√°</li>
          <li><kbd>E</kbd> = Mi</li>
          <li><kbd>D</kbd> = R√©</li>
          <li><kbd>K</kbd> = Sol‚ôØ</li>
          <li><kbd>B</kbd> = Si</li>
          <li><kbd>I</kbd> = R√©‚ôØ</li>
          <li><kbd>G</kbd> = Sol</li>
          <li><kbd>U</kbd> = D√≥‚ôØ</li>
          <li><kbd>F</kbd> = F√°</li>
          <li><kbd>L</kbd> = L√°‚ôØ</li>
        </ul>
      </li>
    </ul>

    <h3>üìä Seu Desempenho e Metas</h3>
    <ul>
      <li><strong>üéØ Estat√≠sticas Gerais:</strong> Acompanhe o total de notas tocadas, seus acertos, erros e precis√£o percentual em tempo real.</li>
      <li><strong>üìà Gr√°fico de Acertos/Erros por Nota:</strong> Uma nova se√ß√£o abaixo dos bot√µes de resposta mostra seu desempenho individual para cada nota, com barras coloridas e porcentagens.</li>
      <li><strong>Sugest√£o de Notas para Melhorar:</strong> Abaixo do gr√°fico, o aplicativo poder√° sugerir as 3 notas com menor taxa de acerto (com pelo menos 5 tentativas) para focar seus estudos.</li>
      <li>**NOVO! Dificuldade Din√¢mica:** O n√≠vel do treino (n√∫mero de notas dispon√≠veis) agora se ajusta automaticamente. Acerte 3 notas seguidas para aumentar o n√≠vel e introduzir uma nova nota; erre 2 seguidas para diminuir o n√≠vel e focar nas notas anteriores.</li>
    </ul>

    <h3>üóìÔ∏è Registro de Tempo de Treino (Modo Ofensivo)</h3>
    <p>Use os bot√µes "Iniciar Sess√£o" e "Finalizar Sess√£o" para registrar o tempo que voc√™ dedica ao treino. Seu tempo total acumulado ser√° exibido.</p>

    <h3>üéØ Sele√ß√£o de Notas para Estudo</h3>
    <p>Use a se√ß√£o "Selecionar Notas para Estudo" acima para escolher as notas espec√≠ficas que deseja praticar. Se nenhuma nota for selecionada, todas as notas do tipo de sequ√™ncia escolhido ser√£o usadas no treino.</p>

    <h3>üö® Modo Foco nas Notas Fracas (NOVO!)</h3>
    <p>Ative este modo para que o aplicativo priorize as notas em que voc√™ tem menos acertos, garantindo um treino mais direcionado e eficaz. As notas para foco s√£o automaticamente determinadas pelas suas estat√≠sticas de desempenho.</p>

    <h3>üìú Hist√≥rico de Sess√µes de Treino (NOVO!)</h3>
    <p>Visualize um registro detalhado de todas as suas sess√µes de treino passadas, incluindo data, dura√ß√£o, acertos, erros e se o modo de foco estava ativo. Acompanhe sua evolu√ß√£o ao longo do tempo!</p>

    <h3>üèÖ Metas de Treino (NOVO!)</h3>
    <p>Defina metas personalizadas para seu tempo de treino por sess√£o e sua precis√£o geral. O aplicativo ir√° te ajudar a acompanhar seu progresso em rela√ß√£o a esses objetivos!</p>

    <h3>üèÜ Ranking Local (Top Scores) (NOVO!)</h3>
    <p>Veja suas melhores sess√µes registradas no ranking local, ordenadas pela precis√£o! Tente superar suas pr√≥prias marcas!</p>
  </div>
  <script>
    // Todas as 12 notas crom√°ticas em ordem padr√£o (para c√°lculos de intervalos)
    const allNotesChromatic = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

    // SEUS ARRAYS ORIGINAIS para mapeamento fixo de nota-tecla
    const originalBaseNotesOrder = ["C", "Gb", "A", "E", "D", "Ab", "B", "Eb", "G", "Db", "F", "Bb"];
    const originalKeyBindingsOrder = ['c','j','a','e','d','k','b','i','g','u','f','l'];

    // Mapeamentos diretos de Nota Base para Tecla e de Tecla para Nota Base
    const noteToKeyMap = {};
    const keyToNoteMap = {};
    for (let i = 0; i < originalBaseNotesOrder.length; i++) {
        const note = originalBaseNotesOrder[i];
        const key = originalKeyBindingsOrder[i];
        noteToKeyMap[note] = key;
        keyToNoteMap[key] = note;
    }

    const baseDisplayNames = {
      "C": "D√≥", "Db": "D√≥‚ôØ", "D": "R√©", "Eb": "R√©‚ôØ", "E": "Mi", "F": "F√°",
      "Gb": "F√°‚ôØ", "G": "Sol", "Ab": "Sol‚ôØ", "A": "L√°", "Bb": "L√°‚ôØ", "B": "Si"
    };

    let audioBase = "./acoustic_grand_piano-mp3/";
    let currentLevel = 2; // Come√ßa com 2 notas dispon√≠veis
    let streak = 0; // Acertos consecutivos
    let errorStreak = 0; // Erros consecutivos
    const STREAK_TO_ADVANCE = 3; // Quantos acertos para aumentar o n√≠vel
    const ERRORS_TO_REDUCE_LEVEL = 2; // Quantos erros para diminuir o n√≠vel (m√≠nimo de 2 notas)
    let currentNote = ""; // A nota que est√° tocando atualmente (ex: "C4")
    let currentOctave = 4;
    let currentSequenceType = "random"; // Tipo de sequ√™ncia de notas (aleat√≥ria, quartas, etc.)

    let total = 0;
    let acertos = 0;
    erros = 0;

    // --- Vari√°veis para estat√≠sticas por nota ---
    let noteStats = {}; // Ex: {"C": {acertos: 0, erros: 0}, "Db": {acertos: 0, erros: 0}, ...}
    const NOTE_STATS_KEY = 'trainingAppNoteStats'; // Chave para o localStorage de estat√≠sticas

    let currentPlayingAudio = null;
    let autoPlayNextNote = false;
    let autoPlayTimeout = null;
    let autoPlayDelaySeconds = 1.5; // Padr√£o 1.5 segundos
    let hideVisualFeedback = false; // Padr√£o: mostrar feedback visual

    // noteSequenceForLevel conter√° APENAS as NOTAS BASE (ex: "C", "F", "Bb") que s√£o relevantes para o n√≠vel atual
    // A oitava √© adicionada na hora de tocar ou verificar.
    let noteSequenceForLevel = [];
    let displayNames = {}; // Mapeia "C4" para "D√≥", etc.

    // Mapeia notas crom√°ticas para seus √≠ndices em allNotesChromatic para c√°lculo de intervalos
    const noteToIndexChromatic = Object.fromEntries(allNotesChromatic.map((note, index) => [note, index]));

    // Array para armazenar as notas base selecionadas pelo usu√°rio
    let selectedNotesForStudy = [];

    // --- Vari√°veis para o registro de tempo ---
    let sessionStartTime = null; // Timestamp quando a sess√£o come√ßou
    let currentSessionAcertos = 0; // Acertos na sess√£o atual
    let currentSessionErros = 0;   // Erros na sess√£o atual
    let totalTrainingDuration = 0; // Dura√ß√£o total acumulada em milissegundos
    let trainingIntervalId = null; // ID do setInterval para atualizar o timer
    const LOCAL_STORAGE_KEY_TOTAL_TIME = 'trainingAppTotalTime'; // Chave para o localStorage do tempo total

    // --- Vari√°vel para o modo de foco ---
    let focusModeActive = false;
    const FOCUS_MODE_MIN_ATTEMPTS = 5; // M√≠nimo de tentativas para uma nota ser considerada no modo foco
    const FOCUS_MODE_NUM_NOTES = 3; // N√∫mero de notas para focar

    // --- Nova vari√°vel para o hist√≥rico de sess√µes ---
    let sessionHistory = []; // Array de objetos de sess√£o
    const SESSION_HISTORY_KEY = 'trainingAppSessionHistory'; // Chave para o localStorage do hist√≥rico

    // --- Novas vari√°veis para metas ---
    let trainingGoals = {
        minSessionTimeMinutes: 10, // Meta padr√£o: 10 minutos por sess√£o
        minAccuracyPercentage: 80  // Meta padr√£o: 80% de precis√£o geral
    };
    const GOALS_KEY = 'trainingAppGoals'; // Chave para o localStorage das metas

    // --- Vari√°veis de som de feedback ---
    let playCorrectSound = true; // Padr√£o: tocar som de acerto
    let playWrongSound = true;  // Padr√£o: tocar som de erro
    let feedbackVolume = 0.5; // Volume padr√£o para sons de acerto/erro (0.0 a 1.0)
    const CORRECT_SOUND_PATH = './son/correct.mp3';
    const WRONG_SOUND_PATH = './son/wrong.mp3';
    //const AUDIO_FEEDBACK_SETTINGS_KEY = 'trainingAppAudioFeedbackSettings'; // Esta chave pode ser removida se tudo for para SETTINGS_KEY

    // --- Chaves para localStorage do N√≠vel e Configura√ß√µes ---
    const TRAINING_LEVEL_KEY = 'trainingAppLevel';
    const SETTINGS_KEY = 'trainingAppSettings';

    // --- Vari√°veis para Ranking Local ---
    let topScores = []; // Array de objetos de melhores pontua√ß√µes
    const TOP_SCORES_KEY = 'trainingAppTopScores'; // Chave para o localStorage do ranking
    const MAX_TOP_SCORES = 5; // Limite de entradas no ranking


    // --- Fun√ß√µes de Salvar/Carregar Configura√ß√µes ---
    function saveSetting(key, value) {
        let settings = JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {};
        settings[key] = value;
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        
        // Atualiza a vari√°vel global correspondente
        if (key === 'autoPlayDelay') autoPlayDelaySeconds = parseFloat(value);
        if (key === 'hideVisualFeedback') hideVisualFeedback = value;
        if (key === 'playCorrectSound') playCorrectSound = value;
        if (key === 'playWrongSound') playWrongSound = value;
        if (key === 'feedbackVolume') feedbackVolume = parseFloat(value); // Salva o volume
    }

    function loadSettings() {
        const settings = JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {};

        // Carrega instrumento
        const savedInstrument = settings.instrument || 'acoustic_grand_piano-mp3';
        document.getElementById('instrument').value = savedInstrument;
        audioBase = `./${savedInstrument}/`;

        // Carrega oitava
        const savedOctave = settings.octave || '4';
        document.getElementById('octave').value = savedOctave;
        currentOctave = parseInt(savedOctave, 10);
        
        // Carrega tipo de sequ√™ncia
        const savedSequenceType = settings.sequenceType || 'random';
        document.getElementById('sequenceType').value = savedSequenceType;
        currentSequenceType = savedSequenceType;

        // Carrega delay do autoplay
        const savedAutoPlayDelay = settings.autoPlayDelay || '1.5';
        document.getElementById('autoPlayDelay').value = savedAutoPlayDelay;
        autoPlayDelaySeconds = parseFloat(savedAutoPlayDelay);

        // Carrega hideVisualFeedback
        hideVisualFeedback = settings.hideVisualFeedback !== undefined ? settings.hideVisualFeedback : false;
        document.getElementById('hideVisualFeedback').checked = hideVisualFeedback;

        // Carrega playCorrectSound
        playCorrectSound = settings.playCorrectSound !== undefined ? settings.playCorrectSound : true;
        document.getElementById('playCorrectSound').checked = playCorrectSound;

        // Carrega playWrongSound
        playWrongSound = settings.playWrongSound !== undefined ? settings.playWrongSound : true;
        document.getElementById('playWrongSound').checked = playWrongSound;

        // Carrega feedbackVolume
        feedbackVolume = settings.feedbackVolume !== undefined ? parseFloat(settings.feedbackVolume) : 0.5;
        document.getElementById('feedbackVolume').value = feedbackVolume;
        document.getElementById('feedbackVolumeValue').textContent = `${(feedbackVolume * 100).toFixed(0)}%`;

        // Notas selecionadas para estudo
        const savedSelectedNotes = settings.selectedNotesForStudy;
        if (savedSelectedNotes && Array.isArray(savedSelectedNotes)) {
            selectedNotesForStudy = savedSelectedNotes;
            // Marca os checkboxes correspondentes (ser√° feito em generateNoteSelectionCheckboxes)
        }
    }


    // --- Fun√ß√µes de Estat√≠sticas por Nota ---

    // Inicializa o objeto noteStats com todas as notas
    function initializeNoteStats() {
        allNotesChromatic.forEach(noteBase => {
            if (!noteStats[noteBase]) {
                noteStats[noteBase] = { acertos: 0, erros: 0 };
            }
        });
    }

    // Carrega as estat√≠sticas por nota salvas
    function loadNoteStats() {
        const savedStats = localStorage.getItem(NOTE_STATS_KEY);
        if (savedStats) {
            noteStats = JSON.parse(savedStats);
        }
        initializeNoteStats(); // Garante que todas as notas estejam no objeto, mesmo se n√£o salvas
        updateNoteStatsDisplay();
    }

    // Salva as estat√≠sticas por nota
    function saveNoteStats() {
        localStorage.setItem(NOTE_STATS_KEY, JSON.stringify(noteStats));
    }

    // Reseta as estat√≠sticas por nota
    function resetNoteStats() {
        if (confirm("Tem certeza que deseja zerar todas as estat√≠sticas de acertos/erros por nota? Esta a√ß√£o n√£o pode ser desfeita.")) {
            noteStats = {};
            initializeNoteStats(); // Reinicializa com zeros
            saveNoteStats();
            updateNoteStatsDisplay();
            document.getElementById("result").textContent = "Estat√≠sticas por nota reiniciadas.";
            document.getElementById("result").style.color = "blue";
        }
    }

    // Atualiza a exibi√ß√£o do gr√°fico e sugest√µes
    function updateNoteStatsDisplay() {
        const chartDiv = document.getElementById("notePerformanceChart");
        const notesToImproveList = document.getElementById("notesToImproveList");
        chartDiv.innerHTML = "";
        
        let notesPerformance = [];

        // Coleta os dados e calcula porcentagens
        allNotesChromatic.forEach(noteBase => {
            const stats = noteStats[noteBase] || { acertos: 0, erros: 0 };
            const totalAttempts = stats.acertos + stats.erros;
            const accuracy = totalAttempts > 0 ? (stats.acertos / totalAttempts) * 100 : 0;
            const errorRate = totalAttempts > 0 ? (stats.erros / totalAttempts) * 100 : 0;

            notesPerformance.push({
                noteBase: noteBase,
                displayName: baseDisplayNames[noteBase],
                acertos: stats.acertos,
                erros: stats.erros,
                totalAttempts: totalAttempts,
                accuracy: accuracy,
                errorRate: errorRate
            });

            // Cria a barra para cada nota
            const itemDiv = document.createElement("div");
            itemDiv.classList.add("note-stat-item");

            const strong = document.createElement("strong");
            strong.textContent = baseDisplayNames[noteBase];
            itemDiv.appendChild(strong);

            const barContainer = document.createElement("div");
            barContainer.classList.add("progress-bar-container");

            const fillAcertos = document.createElement("div");
            fillAcertos.classList.add("progress-bar-fill");
            fillAcertos.style.width = `${accuracy}%`;

            const fillErros = document.createElement("div");
            fillErros.classList.add("progress-bar-error");
            fillErros.style.width = `${errorRate}%`;
            fillErros.style.right = '0%'; // Garante que a barra de erro cres√ßa da direita para a esquerda

            const textSpan = document.createElement("span");
            textSpan.classList.add("progress-bar-text");
            textSpan.textContent = totalAttempts > 0 ? `${accuracy.toFixed(0)}% (${totalAttempts})` : '0% (0)';

            barContainer.appendChild(fillAcertos);
            barContainer.appendChild(fillErros);
            barContainer.appendChild(textSpan);
            itemDiv.appendChild(barContainer);
            chartDiv.appendChild(itemDiv);
        });

        // Sugest√£o de notas para melhorar
        const notesToFocusForDisplay = getNotesToFocus();
        if (notesToFocusForDisplay.length > 0) {
            notesToImproveList.textContent = notesToFocusForDisplay.map(note => `${note.displayName} (${note.accuracy.toFixed(0)}%)`).join(', ');
        } else {
            notesToImproveList.textContent = "Continue praticando para coletar dados!";
        }
    }

    // --- Fun√ß√µes do Modo de Foco ---
    
    // Retorna as notas com menor % de acerto, com no m√≠nimo FOCUS_MODE_MIN_ATTEMPTS tentativas
    function getNotesToFocus() {
        let notesPerformance = [];
        allNotesChromatic.forEach(noteBase => {
            const stats = noteStats[noteBase] || { acertos: 0, erros: 0 };
            const totalAttempts = stats.acertos + stats.erros;
            const accuracy = totalAttempts > 0 ? (stats.acertos / totalAttempts) * 100 : 0;

            if (totalAttempts >= FOCUS_MODE_MIN_ATTEMPTS) {
                notesPerformance.push({
                    noteBase: noteBase,
                    displayName: baseDisplayNames[noteBase],
                    accuracy: accuracy,
                    totalAttempts: totalAttempts
                });
            }
        });

        notesPerformance.sort((a, b) => a.accuracy - b.accuracy); // Ordena pela menor precis√£o (do pior para o melhor)
        return notesPerformance.slice(0, FOCUS_MODE_NUM_NOTES); // Retorna as X piores notas
    }

    function toggleFocusMode() {
        focusModeActive = !focusModeActive;
        const toggleButton = document.getElementById("toggleFocusModeButton");
        const statusSpan = document.getElementById("focusModeStatus");
        
        if (focusModeActive) {
            const notesToFocus = getNotesToFocus();
            if (notesToFocus.length === 0) {
                alert(`N√£o h√° notas suficientes com ${FOCUS_MODE_MIN_ATTEMPTS} ou mais tentativas para ativar o Modo Foco. Continue praticando no modo normal primeiro!`);
                focusModeActive = false; // Desativa se n√£o h√° notas para focar
                toggleButton.classList.remove('active');
                toggleButton.textContent = "üéØ Ativar Modo Foco nas Notas Fracas (Desativado)";
                statusSpan.textContent = "Modo Foco desativado.";
                statusSpan.style.color = "#0056b3";
                return;
            }
            toggleButton.classList.add('active');
            toggleButton.textContent = "üéØ Modo Foco nas Notas Fracas (Ativado)";
            statusSpan.textContent = `Focando em: ${notesToFocus.map(n => n.displayName).join(', ')}`;
            statusSpan.style.color = "#20c997"; // Cor de ativo
            document.getElementById("result").textContent = "Modo Foco ATIVADO!";
            document.getElementById("result").style.color = "darkblue";
            playNote(); // Toca a primeira nota no modo foco
        } else {
            toggleButton.classList.remove('active');
            toggleButton.textContent = "üéØ Ativar Modo Foco nas Notas Fracas (Desativado)";
            statusSpan.textContent = "Modo Foco desativado.";
            statusSpan.style.color = "#0056b3"; // Cor padr√£o
            document.getElementById("result").textContent = "Modo Foco DESATIVADO.";
            document.getElementById("result").style.color = "darkblue";
        }
    }

    // --- Fun√ß√µes de Registro de Tempo e Hist√≥rico de Sess√µes ---

    // Fun√ß√£o para carregar o tempo total salvo
    function loadTotalTrainingDuration() {
        const savedTime = localStorage.getItem(LOCAL_STORAGE_KEY_TOTAL_TIME);
        if (savedTime) {
            totalTrainingDuration = parseInt(savedTime, 10);
        } else {
            totalTrainingDuration = 0;
        }
        updateTrainingTimerDisplay();
    }

    // Fun√ß√£o para salvar o tempo total
    function saveTotalTrainingDuration() {
        localStorage.setItem(LOCAL_STORAGE_KEY_TOTAL_TIME, totalTrainingDuration);
    }

    // Fun√ß√£o para formatar o tempo para exibi√ß√£o
    function formatDuration(ms) {
        if (ms < 0) ms = 0; // Garante que n√£o exiba tempo negativo
        const seconds = Math.floor((ms / 1000) % 60);
        const minutes = Math.floor((ms / (1000 * 60)) % 60);
        const hours = Math.floor((ms / (1000 * 60 * 60)));

        const pad = (num) => num.toString().padStart(2, '0');
        return `${pad(hours)}h ${pad(minutes)}m ${pad(seconds)}s`;
    }

    // Fun√ß√£o para atualizar a exibi√ß√£o do timer
    function updateTrainingTimerDisplay() {
        const timerDiv = document.getElementById("trainingTimer");
        let currentSessionDuration = 0;
        if (sessionStartTime) {
            currentSessionDuration = Date.now() - sessionStartTime;
        }
        timerDiv.textContent = `Tempo total de treino: ${formatDuration(totalTrainingDuration + currentSessionDuration)}`;
        
        if (sessionStartTime) {
            timerDiv.classList.add('active-session');
        } else {
            timerDiv.classList.remove('active-session');
        }
    }

    // Fun√ß√£o para iniciar a sess√£o de treino
    function startTrainingSession() {
        if (!sessionStartTime) { // Apenas se uma sess√£o n√£o estiver ativa
            sessionStartTime = Date.now();
            currentSessionAcertos = 0; // Zera contadores da sess√£o
            currentSessionErros = 0;
            document.getElementById("startSessionBtn").disabled = true;
            document.getElementById("endSessionBtn").disabled = false;
            document.getElementById("result").textContent = "Sess√£o de treino iniciada!";
            document.getElementById("result").style.color = "green";
            // Atualiza o timer a cada segundo
            trainingIntervalId = setInterval(updateTrainingTimerDisplay, 1000);
            updateTrainingTimerDisplay(); // Atualiza imediatamente
        }
    }

    // Fun√ß√£o para finalizar a sess√£o de treino
    function endTrainingSession() {
        if (sessionStartTime) { // Apenas se uma sess√£o estiver ativa
            const sessionDuration = Date.now() - sessionStartTime;
            totalTrainingDuration += sessionDuration;

            // Registra a sess√£o no hist√≥rico
            const sessionData = {
                timestamp: new Date().toISOString(),
                durationMs: sessionDuration,
                sessionAcertos: currentSessionAcertos,
                sessionErros: currentSessionErros,
                focusMode: focusModeActive,
                focusedNotes: focusModeActive ? getNotesToFocus().map(n => n.noteBase) : [],
                accuracyAtSessionEnd: total > 0 ? ((acertos / total) * 100) : 0 // Precis√£o geral no fim da sess√£o
            };
            sessionHistory.push(sessionData);
            saveSessionHistory(); // Salva o hist√≥rico atualizado
            displaySessionHistory(); // Atualiza a exibi√ß√£o

            // Adiciona a sess√£o ao ranking
            addSessionToTopScores(sessionData);

            sessionStartTime = null; // Reseta o tempo de in√≠cio
            currentSessionAcertos = 0; // Zera contadores da sess√£o
            currentSessionErros = 0;
            saveTotalTrainingDuration(); // Salva o novo total
            clearInterval(trainingIntervalId); // Para o timer
            trainingIntervalId = null;
            document.getElementById("startSessionBtn").disabled = false;
            document.getElementById("endSessionBtn").disabled = true;
            document.getElementById("result").textContent = `Sess√£o finalizada. Dura√ß√£o: ${formatDuration(sessionDuration)}`;
            document.getElementById("result").style.color = "red";
            updateTrainingTimerDisplay(); // Atualiza a exibi√ß√£o final
            updateGoalStatus(); // Verifica e atualiza o status das metas ap√≥s a sess√£o
        }
    }

    // Carrega o hist√≥rico de sess√µes do localStorage
    function loadSessionHistory() {
        const savedHistory = localStorage.getItem(SESSION_HISTORY_KEY);
        if (savedHistory) {
            sessionHistory = JSON.parse(savedHistory);
        } else {
            sessionHistory = [];
        }
        displaySessionHistory();
    }

    // Salva o hist√≥rico de sess√µes no localStorage
    function saveSessionHistory() {
        localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(sessionHistory));
    }

    // Exibe o hist√≥rico de sess√µes na interface
    function displaySessionHistory() {
        const list = document.getElementById("sessionHistoryList");
        list.innerHTML = ""; // Limpa a lista existente

        if (sessionHistory.length === 0) {
            const listItem = document.createElement("li");
            listItem.textContent = "Nenhuma sess√£o registrada ainda.";
            list.appendChild(listItem);
            return;
        }

        // Exibe as sess√µes mais recentes primeiro
        [...sessionHistory].reverse().forEach(session => {
            const listItem = document.createElement("li");
            listItem.classList.add("session-item");

            const date = new Date(session.timestamp);
            const dateString = date.toLocaleDateString('pt-BR', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });

            const sessionAccuracy = session.sessionAcertos + session.sessionErros > 0 ?
                ((session.sessionAcertos / (session.sessionAcertos + session.sessionErros)) * 100).toFixed(1) : "0.0";

            listItem.innerHTML = `
                <span><strong>Data:</strong> ${dateString}</span>
                <span><strong>Dura√ß√£o:</strong> ${formatDuration(session.durationMs)}</span>
                <span><strong>Acertos:</strong> ${session.sessionAcertos} | <strong>Erros:</strong> ${session.sessionErros} | <strong>Precis√£o da sess√£o:</strong> ${sessionAccuracy}%</span>
                <span><strong>Modo Foco:</strong> ${session.focusMode ? 'Ativo' : 'Inativo'} ${session.focusMode && session.focusedNotes.length > 0 ? `<span class="focus-notes">(Notas: ${session.focusedNotes.map(n => baseDisplayNames[n]).join(', ')})</span>` : ''}</span>
            `;
            list.appendChild(listItem);
        });
    }

    // Fun√ß√£o para limpar todo o hist√≥rico de sess√µes
    function clearSessionHistory() {
        if (confirm("Tem certeza que deseja limpar todo o hist√≥rico de sess√µes? Esta a√ß√£o n√£o pode ser desfeita.")) {
            sessionHistory = [];
            saveSessionHistory();
            displaySessionHistory();
            document.getElementById("result").textContent = "Hist√≥rico de sess√µes limpo.";
            document.getElementById("result").style.color = "blue";
        }
    }

    // --- Fun√ß√µes de Metas ---
    function loadGoals() {
        const savedGoals = localStorage.getItem(GOALS_KEY);
        if (savedGoals) {
            trainingGoals = JSON.parse(savedGoals);
        }
        // Define os valores nos inputs
        document.getElementById("minSessionTime").value = trainingGoals.minSessionTimeMinutes;
        document.getElementById("minAccuracy").value = trainingGoals.minAccuracyPercentage;
        updateGoalStatus(); // Atualiza o status das metas na interface
    }

    function saveGoals() {
        trainingGoals.minSessionTimeMinutes = parseInt(document.getElementById("minSessionTime").value, 10);
        trainingGoals.minAccuracyPercentage = parseInt(document.getElementById("minAccuracy").value, 10);
        localStorage.setItem(GOALS_KEY, JSON.stringify(trainingGoals));
        document.getElementById("result").textContent = "Metas de treino salvas!";
        document.getElementById("result").style.color = "darkgreen";
        updateGoalStatus();
    }

    function updateGoalStatus() {
        const statusDiv = document.getElementById("currentGoalsStatus");
        
        const minTimeGoalMs = trainingGoals.minSessionTimeMinutes * 60 * 1000;
        const currentAccuracy = total > 0 ? ((acertos / total) * 100) : 0;

        let statusHtml = `
            <span><strong>Meta de Tempo por Sess√£o:</strong> ${trainingGoals.minSessionTimeMinutes} minutos</span><br>
            <span><strong>Meta de Precis√£o Geral:</strong> ${trainingGoals.minAccuracyPercentage}%</span><br><br>
        `;

        let allGoalsAchieved = true;
        
        // Verifica a meta de tempo da √öLTIMA sess√£o
        const lastSession = sessionHistory.length > 0 ? sessionHistory[sessionHistory.length - 1] : null;
        if (lastSession) {
            if (lastSession.durationMs >= minTimeGoalMs) {
                statusHtml += `<span>‚úÖ √öltima sess√£o atingiu a meta de tempo (${formatDuration(lastSession.durationMs)}).</span><br>`;
            } else {
                statusHtml += `<span>‚ö†Ô∏è √öltima sess√£o n√£o atingiu a meta de tempo (${formatDuration(lastSession.durationMs)}).</span><br>`;
                allGoalsAchieved = false;
            }
        } else {
            statusHtml += `<span>Comece uma sess√£o de treino para verificar a meta de tempo.</span><br>`;
            allGoalsAchieved = false; // N√£o h√° sess√£o para verificar a meta de tempo
        }

        // Verifica a meta de precis√£o geral (contadores globais)
        if (total > 0) {
            if (currentAccuracy >= trainingGoals.minAccuracyPercentage) {
                statusHtml += `<span>‚úÖ Precis√£o geral atual: ${currentAccuracy.toFixed(1)}% (Meta atingida!).</span>`;
            } else {
                statusHtml += `<span>‚ö†Ô∏è Precis√£o geral atual: ${currentAccuracy.toFixed(1)}% (Abaixo da meta).</span>`;
                allGoalsAchieved = false;
            }
        } else {
            statusHtml += `<span>Comece a treinar para verificar a meta de precis√£o.</span>`;
            allGoalsAchieved = false; // N√£o h√° dados para verificar a precis√£o
        }

        statusDiv.innerHTML = statusHtml;
        statusDiv.classList.remove('warning');
        statusDiv.classList.add(allGoalsAchieved ? '' : 'warning'); // Adiciona classe 'warning' se alguma meta n√£o foi atingida
    }


    // Fun√ß√£o para gerar os checkboxes de sele√ß√£o de notas
    function generateNoteSelectionCheckboxes() {
        const noteCheckboxesDiv = document.getElementById("noteCheckboxes");
        noteCheckboxesDiv.innerHTML = ""; // Limpa os checkboxes existentes

        allNotesChromatic.forEach(noteBase => {
            const label = document.createElement("label");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = noteBase;
            checkbox.id = `note-${noteBase}`;
            // Carrega o estado do checkbox com base em `selectedNotesForStudy` carregado do localStorage
            checkbox.checked = selectedNotesForStudy.includes(noteBase);
            checkbox.onchange = updateSelectedNotes; // Chama a fun√ß√£o ao mudar a sele√ß√£o

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(baseDisplayNames[noteBase]));
            noteCheckboxesDiv.appendChild(label);
        });
    }

    // Fun√ß√£o para atualizar o array selectedNotesForStudy
    function updateSelectedNotes() {
        selectedNotesForStudy = [];
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]:checked');
        checkboxes.forEach(checkbox => {
            selectedNotesForStudy.push(checkbox.value);
        });
        saveSetting('selectedNotesForStudy', selectedNotesForStudy); // Salva a sele√ß√£o
        
        // Sempre que a sele√ß√£o de notas muda, reiniciamos o n√≠vel de treino
        resetTrainingLevel();
        updateButtons(); // Atualiza os bot√µes de resposta
        document.getElementById("result").textContent = "Sele√ß√£o de notas atualizada!";
        document.getElementById("result").style.color = "darkcyan";
    }

    // Fun√ß√£o para selecionar todas as notas
    function selectAllNotes() {
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelectedNotes();
    }

    // Fun√ß√£o para limpar todas as notas selecionadas
    function clearAllNotes() {
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelectedNotes();
    }

    // Fun√ß√£o para reiniciar o n√≠vel de treino (usada ao mudar oitava, sequ√™ncia ou sele√ß√£o de notas)
    function resetTrainingLevel() {
        currentLevel = 2; // Volta ao n√≠vel inicial
        streak = 0; // Zera as streaks
        errorStreak = 0;
        saveTrainingLevel(); // Salva o n√≠vel resetado
        // Regenera a sequ√™ncia base para garantir que a l√≥gica de sele√ß√£o de notas seja aplicada
        noteSequenceForLevel = generateNoteSequenceBase();
    }

    // Fun√ß√£o para salvar o n√≠vel de treino
    function saveTrainingLevel() {
        const levelData = {
            currentLevel: currentLevel,
            streak: streak,
            errorStreak: errorStreak
        };
        localStorage.setItem(TRAINING_LEVEL_KEY, JSON.stringify(levelData));
    }

    // Fun√ß√£o para carregar o n√≠vel de treino
    function loadTrainingLevel() {
        const savedLevel = localStorage.getItem(TRAINING_LEVEL_KEY);
        if (savedLevel) {
            const levelData = JSON.parse(savedLevel);
            currentLevel = levelData.currentLevel || 2;
            streak = levelData.streak || 0;
            errorStreak = levelData.errorStreak || 0;
        }
    }


    // Fun√ß√£o para gerar a sequ√™ncia de notas base (sem a oitava) com base no tipo selecionado
    // AGORA CONSIDERA selectedNotesForStudy
    function generateNoteSequenceBase() {
      let sequence = [];
      let baseSequenceForType = [];

      switch (currentSequenceType) {
        case "random":
          baseSequenceForType = [...originalBaseNotesOrder];
          break;
        case "fourths":
          let currentNoteIndexForth = noteToIndexChromatic["C"];
          for (let i = 0; i < allNotesChromatic.length; i++) {
            baseSequenceForType.push(allNotesChromatic[currentNoteIndexForth]);
            currentNoteIndexForth = (currentNoteIndexForth + 5) % allNotesChromatic.length;
          }
          break;
        case "fifths":
          let currentNoteIndexFifth = noteToIndexChromatic["C"];
          for (let i = 0; i < allNotesChromatic.length; i++) {
            baseSequenceForType.push(allNotesChromatic[currentNoteIndexFifth]);
            currentNoteIndexFifth = (currentNoteIndexFifth + 7) % allNotesChromatic.length;
          }
          break;
        case "chromaticAsc":
          baseSequenceForType = [...allNotesChromatic];
          break;
        case "chromaticDesc":
          baseSequenceForType = [...allNotesChromatic].reverse();
          break;
        default:
          baseSequenceForType = [...originalBaseNotesOrder];
      }

      // Se houver notas selecionadas para estudo, filtra a sequ√™ncia base
      if (selectedNotesForStudy.length > 0) {
          // Garante que as notas na sequ√™ncia final estejam na ordem da baseSequenceForType
          // mas apenas se estiverem em selectedNotesForStudy
          sequence = baseSequenceForType.filter(note => selectedNotesForStudy.includes(note));
          
          // Se a sequ√™ncia filtrada ficar vazia, voltamos a usar todas as notas da baseSequenceForType
          // para evitar um erro e permitir que o treino continue
          if (sequence.length === 0) {
              console.warn("Nenhuma nota selecionada encontrada na sequ√™ncia gerada. Usando todas as notas da sequ√™ncia padr√£o.");
              sequence = baseSequenceForType;
          }
      } else {
          // Se nenhuma nota for selecionada, usa a sequ√™ncia base completa para o tipo
          sequence = baseSequenceForType;
      }
      return sequence;
    }

    // Atualiza os nomes de exibi√ß√£o completos (ex: "C4" -> "D√≥")
    function updateDisplayNames() {
      displayNames = {};
      allNotesChromatic.forEach(noteBase => {
        displayNames[noteBase + currentOctave] = baseDisplayNames[noteBase];
      });
    }

    // Cria/Atualiza os bot√µes na interface
    // AGORA CONSIDERA selectedNotesForStudy
    function updateButtons() {
      const buttonsDiv = document.getElementById("buttons");
      buttonsDiv.innerHTML = "";

      // Pega as notas base que est√£o no n√≠vel atual da sequ√™ncia escolhida
      // E que tamb√©m est√£o entre as notas selecionadas para estudo (se houver)
      let notesToDisplayOnButtons = noteSequenceForLevel.slice(0, currentLevel);
      
      // Se houver notas selecionadas, filtra os bot√µes para mostrar apenas as selecionadas
      if (selectedNotesForStudy.length > 0) {
          notesToDisplayOnButtons = notesToDisplayOnButtons.filter(note => selectedNotesForStudy.includes(note));
      }

      // Se n√£o houver notas para exibir (ex: todas as selecionadas j√° foram dominadas ou nenhuma selecionada e n√≠vel baixo)
      // Usamos todas as notas do n√≠vel atual da sequ√™ncia para evitar bot√µes vazios
      if (notesToDisplayOnButtons.length === 0 && selectedNotesForStudy.length > 0) {
          // Isso pode acontecer se o currentLevel for muito baixo e as notas selecionadas n√£o estiverem no in√≠cio da sequ√™ncia.
          // Para garantir que sempre haja bot√µes, podemos usar todas as notas selecionadas.
          notesToDisplayOnButtons = selectedNotesForStudy;
          // Ou, se preferir, um aviso e n√£o mostrar bot√µes, dependendo da UX desejada.
          // Por enquanto, vou garantir que o playNote ainda consiga tocar algo.
      } else if (notesToDisplayOnButtons.length === 0 && selectedNotesForStudy.length === 0) {
          // Se n√£o h√° sele√ß√£o e o n√≠vel √© 0 (o que n√£o deveria acontecer com currentLevel=2),
          // voltamos a usar as notas iniciais da sequ√™ncia padr√£o.
          notesToDisplayOnButtons = noteSequenceForLevel.slice(0, currentLevel);
      }


      notesToDisplayOnButtons.forEach(noteBase => {
        const btn = document.createElement("button");
        const keyText = noteToKeyMap[noteBase] ? `[${noteToKeyMap[noteBase].toUpperCase()}]` : '';
        btn.textContent = `${baseDisplayNames[noteBase]} ${keyText}`;
        btn.onclick = () => checkAnswer(noteBase + currentOctave);
        buttonsDiv.appendChild(btn);
      });
    }

    function updateStats() {
      const statsDiv = document.getElementById("stats");
      const porcentagem = total > 0 ? ((acertos / total) * 100).toFixed(1) : "0.0";
      statsDiv.innerHTML = `üéØ Notas tocadas: ${total} | ‚úÖ Acertos: ${acertos} | ‚ùå Erros: ${erros} | üìä Precis√£o: ${porcentagem}%`;
      updateGoalStatus(); // Tamb√©m atualiza o status das metas quando as estat√≠sticas gerais mudam
    }

    function resetCounters() {
      if (confirm("Tem certeza que deseja zerar todos os contadores de acertos/erros (gerais)? As estat√≠sticas por nota permanecer√£o.")) {
        total = 0;
        acertos = 0;
        erros = 0;
        streak = 0; // Tamb√©m zera a streak
        errorStreak = 0;
        currentLevel = 2; // Volta ao n√≠vel inicial
        saveTrainingLevel(); // Salva o n√≠vel resetado
        updateStats();
        document.getElementById("result").textContent = "üîÑ Contadores gerais reiniciados.";
        document.getElementById("result").style.color = "blue";
        if (currentPlayingAudio) {
          currentPlayingAudio.pause();
          currentPlayingAudio.currentTime = 0;
          currentPlayingAudio = null;
        }
        currentNote = "";
        if (autoPlayTimeout) {
          clearTimeout(autoPlayTimeout);
          autoPlayTimeout = null;
        }
        if (autoPlayNextNote) {
          toggleAutoPlayNextNote(); // Desativa o modo autom√°tico ao reiniciar
        }
        updateButtons(); // Atualiza os bot√µes para refletir o novo n√≠vel
      }
      // N√£o reinicia o tempo de treino com os outros contadores
    }

    function playRealNote(noteWithOctave) { // Ex: "C4"
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
      }
      const audioPath = `${audioBase}${noteWithOctave}.mp3`;
      const audio = new Audio(audioPath);
      audio.volume = 0.7; // Volume padr√£o das notas
      audio.play().then(() => {
        currentPlayingAudio = audio;
      }).catch(e => {
        console.error(`Erro ao tocar ${audioPath}:`, e);
        document.getElementById("result").textContent = "Erro ao carregar o som. Verifique o console do navegador (F12) e os arquivos MP3.";
        document.getElementById("result").style.color = "red";
      });
    }

    // playNote AGORA CONSIDERA selectedNotesForStudy e o Modo Foco
    function playNote() {
      let availableNotesForPlay = [];

      if (focusModeActive) {
          const notesToFocus = getNotesToFocus();
          if (notesToFocus.length > 0) {
              availableNotesForPlay = notesToFocus.map(n => n.noteBase);
              // Para garantir que notas com zero tentativas que foram "piores" entrem
              // Mas apenas se selectedNotesForStudy n√£o estiver ativo.
              if (selectedNotesForStudy.length > 0) {
                  // Se o usu√°rio selecionou notas, o modo foco s√≥ vai focar entre as selecionadas
                  availableNotesForPlay = availableNotesForPlay.filter(note => selectedNotesForStudy.includes(note));
                  if (availableNotesForPlay.length === 0) { // Se as notas focadas n√£o est√£o nas selecionadas
                      console.warn("Modo Foco: Nenhuma das notas a focar est√° entre as notas selecionadas. Tocando notas aleat√≥rias das selecionadas.");
                      availableNotesForPlay = [...selectedNotesForStudy];
                  }
              }
          } else {
              // Se o modo foco est√° ativo mas n√£o h√° notas com tentativas suficientes,
              // voltamos para o comportamento normal de playNote
              console.warn("Modo Foco ativo mas sem notas para focar. Revertendo para sele√ß√£o normal.");
              focusModeActive = false; // Desativa o modo foco para evitar loop
              toggleFocusMode(); // Atualiza o bot√£o e mensagem
              return; // Tenta tocar novamente com o modo foco desativado
          }
      } else if (selectedNotesForStudy.length > 0) {
          availableNotesForPlay = [...selectedNotesForStudy];
      } else {
          availableNotesForPlay = noteSequenceForLevel.slice(0, currentLevel);
      }

      if (availableNotesForPlay.length === 0) {
          document.getElementById("result").textContent = "Nenhuma nota dispon√≠vel para tocar. Selecione notas ou ajuste o n√≠vel/sequ√™ncia.";
          document.getElementById("result").style.color = "orange";
          currentNote = ""; // Garante que n√£o h√° nota "pendente"
          return;
      }

      // Escolhe uma nota aleat√≥ria entre as dispon√≠veis (focadas ou normais)
      const randomBaseNote = availableNotesForPlay[Math.floor(Math.random() * availableNotesForPlay.length)];
      currentNote = randomBaseNote + currentOctave; // Armazena a nota completa (ex: "C4")

      playRealNote(currentNote);
      if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
        document.getElementById("result").textContent = "Qual nota foi tocada?";
        document.getElementById("result").style.color = "black";
      } else {
        document.getElementById("result").textContent = ""; // Oculta a mensagem no modo autom√°tico
      }
      total++; // Aumenta o contador APENAS ao tocar uma nova nota (n√£o ao repetir)
      updateStats();

      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
    }

    function playFeedbackSound(isCorrect) {
        let soundPath = '';
        let shouldPlay = false;

        if (isCorrect && playCorrectSound) {
            soundPath = CORRECT_SOUND_PATH;
            shouldPlay = true;
        } else if (!isCorrect && playWrongSound) {
            soundPath = WRONG_SOUND_PATH;
            shouldPlay = true;
        }

        if (shouldPlay) {
            const audio = new Audio(soundPath);
            audio.volume = feedbackVolume; // Define o volume usando a vari√°vel global
            audio.play().catch(e => console.error("Erro ao tocar som de feedback:", e));
        }
    }

    function checkAnswer(selectedNoteWithOctave) { // A nota completa que foi clicada/pressionada (ex: "C4")
      const resultDiv = document.getElementById("result");
      if (!currentNote) { // Se nenhuma nota foi tocada ainda
        resultDiv.textContent = "Pressione 'Tocar Nota' ou espa√ßo para come√ßar.";
        resultDiv.style.color = "orange";
        return;
      }

      const playedNoteBase = currentNote.slice(0, -1); // Ex: "C4" -> "C"
      const selectedNoteBase = selectedNoteWithOctave.slice(0, -1); // Ex: "C4" -> "C"

      if (selectedNoteWithOctave === currentNote) {
        acertos++;
        currentSessionAcertos++; // Registra acerto para a sess√£o atual
        streak++;
        errorStreak = 0; // Zera a sequ√™ncia de erros
        noteStats[playedNoteBase].acertos++; // Registra acerto para a nota espec√≠fica
        
        playFeedbackSound(true); // Toca som de acerto
        
        if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
            resultDiv.textContent = `‚úÖ Correto! Era ${displayNames[currentNote]}`;
            resultDiv.style.color = "green";
        } else {
            resultDiv.textContent = "";
        }

        // --- L√≥gica de Aumento de N√≠vel (Dificuldade Din√¢mica) ---
        // O limite agora √© o n√∫mero total de notas na sequ√™ncia gerada
        const maxNotesForLevel = selectedNotesForStudy.length > 0 ? selectedNotesForStudy.length : noteSequenceForLevel.length;
        if (streak >= STREAK_TO_ADVANCE && currentLevel < maxNotesForLevel) {
            currentLevel++;
            streak = 0; // Reseta a streak ao aumentar o n√≠vel
            updateButtons(); // Atualiza os bot√µes para incluir a nova nota
            document.getElementById("result").textContent += ` üéâ Subiu de n√≠vel para ${currentLevel} notas!`;
            document.getElementById("result").style.color = "darkgreen";
        }

      } else { // Resposta Incorreta
        erros++;
        currentSessionErros++; // Registra erro para a sess√£o atual
        streak = 0; // Zera a sequ√™ncia de acertos
        errorStreak++; // Incrementa a sequ√™ncia de erros
        noteStats[playedNoteBase].erros++; // Registra erro para a nota espec√≠fica
        
        playFeedbackSound(false); // Toca som de erro

        if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
            resultDiv.textContent = `‚ùå Errado! Era ${displayNames[currentNote]}`;
            resultDiv.style.color = "red";
        } else {
            resultDiv.textContent = "";
        }

        // --- L√≥gica de Diminui√ß√£o de N√≠vel (Dificuldade Din√¢mica) ---
        // Garante que o n√≠vel m√≠nimo seja 2 (pelo menos 2 notas para escolher)
        if (errorStreak >= ERRORS_TO_REDUCE_LEVEL && currentLevel > 2) {
            currentLevel--;
            errorStreak = 0; // Reseta a sequ√™ncia de erros ao diminuir o n√≠vel
            updateButtons(); // Atualiza os bot√µes para remover a nota mais recente
            document.getElementById("result").textContent += ` üìâ N√≠vel diminu√≠do para ${currentLevel} notas para ajudar no foco.`;
            document.getElementById("result").style.color = "darkred";
        }
      }

      saveTrainingLevel(); // Salva o n√≠vel e streak/errorStreak ap√≥s cada resposta
      currentNote = ""; // Reseta a nota atual para que uma nova seja tocada
      updateStats();
      saveNoteStats(); // Salva as estat√≠sticas por nota a cada resposta
      updateNoteStatsDisplay(); // Atualiza o gr√°fico de desempenho

      if (autoPlayNextNote) {
        autoPlayTimeout = setTimeout(() => {
          playNote();
        }, autoPlayDelaySeconds * 1000); // Usa o atraso configur√°vel
      }
    }

    // Fun√ß√£o repeatNote_Backspace: Apenas toca a nota sem feedback visual extra
    function repeatNote_Backspace() {
      if (currentNote) {
        playRealNote(currentNote);
        // N√£o altera a mensagem no resultDiv nem a cor, apenas toca a nota
        // Mant√©m a mensagem atual se houver uma (e.g., "Qual nota foi tocada?")
        // ou a √∫ltima mensagem de "Correto!"/"Errado!".
      } else {
        document.getElementById("result").textContent = "N√£o h√° nota para repetir. Pressione 'Tocar Nota' ou espa√ßo.";
        document.getElementById("result").style.color = "orange";
      }
    }
    
    // Fun√ß√£o repeatNote_Enter: Toca a nota e mostra o nome
    function repeatNote_Enter() {
      if (currentNote) {
        playRealNote(currentNote);
        document.getElementById("result").textContent = `üîÅ Repetindo: ${displayNames[currentNote]}`;
        document.getElementById("result").style.color = "blue";
      } else {
        document.getElementById("result").textContent = "N√£o h√° nota para repetir. Pressione 'Tocar Nota' ou espa√ßo.";
        document.getElementById("result").style.color = "orange";
      }
    }

    function changeInstrument() {
      const selected = document.getElementById("instrument").value;
      audioBase = `./${selected}/`;
      currentNote = ""; // Limpa a nota atual para evitar que tente tocar com o timbre antigo
      document.getElementById("result").textContent = `üéº Timbre alterado para: ${selected.replace(/_/g, ' ').replace(/-/g, ' ').replace('.mp3', '').trim()}`;
      document.getElementById("result").style.color = "darkgreen";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('instrument', selected); // Salva a prefer√™ncia
    }

    function changeOctave() {
      currentOctave = parseInt(document.getElementById("octave").value, 10);
      updateDisplayNames(); // Atualiza os nomes de exibi√ß√£o com a nova oitava
      resetTrainingLevel(); // Reinicia o n√≠vel ao mudar a oitava
      updateButtons(); // Recria os bot√µes com a nova oitava nos nomes completos para checagem
      currentNote = "";
      document.getElementById("result").textContent = `üé∂ Oitava alterada para ${currentOctave}`;
      document.getElementById("result").style.color = "purple";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('octave', currentOctave.toString()); // Salva a prefer√™ncia
    }

    function changeSequenceType() {
      currentSequenceType = document.getElementById("sequenceType").value;
      resetTrainingLevel(); // Reinicia o n√≠vel ao mudar a sequ√™ncia
      updateButtons(); // Atualiza os bot√µes com as notas da nova sequ√™ncia
      currentNote = "";
      document.getElementById("result").textContent = `üîÑ Sequ√™ncia alterada para: ${document.getElementById("sequenceType").options[document.getElementById("sequenceType").selectedIndex].text}`;
      document.getElementById("result").style.color = "darkblue";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('sequenceType', currentSequenceType); // Salva a prefer√™ncia
    }

    function toggleAutoPlayNextNote() {
      autoPlayNextNote = !autoPlayNextNote;
      const button = document.getElementById("toggleAutoPlayNextNoteButton");
      if (autoPlayNextNote) {
        button.textContent = "‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Ativado)";
        button.classList.remove('inactive');
        button.classList.add('active');
        if (!currentNote) { // Se n√£o houver nota tocando, j√° inicia
            playNote();
        }
      } else {
        button.textContent = "‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Desativado)";
        button.classList.remove('active');
        button.classList.add('inactive');
        if (autoPlayTimeout) {
          clearTimeout(autoPlayTimeout);
          autoPlayTimeout = null;
        }
      }
      document.getElementById("result").textContent = `Modo autom√°tico: ${autoPlayNextNote ? 'ATIVADO' : 'DESATIVADO'}`;
      document.getElementById("result").style.color = autoPlayNextNote ? "green" : "red";
    }

    // Fun√ß√£o para atualizar o volume de feedback e salv√°-lo
    function updateFeedbackVolume(value) {
        feedbackVolume = parseFloat(value);
        document.getElementById('feedbackVolumeValue').textContent = `${(feedbackVolume * 100).toFixed(0)}%`;
        saveSetting('feedbackVolume', feedbackVolume); // Salva o novo volume
    }

    // --- Fun√ß√µes de Ranking Local (Top Scores) ---

    // Carrega o ranking do localStorage
    function loadTopScores() {
        const savedScores = localStorage.getItem(TOP_SCORES_KEY);
        if (savedScores) {
            topScores = JSON.parse(savedScores);
        } else {
            topScores = [];
        }
        displayTopScores();
    }

    // Salva o ranking no localStorage
    function saveTopScores() {
        localStorage.setItem(TOP_SCORES_KEY, JSON.stringify(topScores));
    }

    // Adiciona uma sess√£o ao ranking, se for uma das melhores
    function addSessionToTopScores(sessionData) {
        const sessionAccuracy = sessionData.accuracyAtSessionEnd;
        const totalAttempts = sessionData.sessionAcertos + sessionData.sessionErros;

        // S√≥ considera sess√µes com pelo menos 5 tentativas para entrar no ranking
        if (totalAttempts < 5) {
            console.log("Sess√£o muito curta para ranking.");
            return;
        }

        // Cria um objeto de pontua√ß√£o para o ranking
        const newScore = {
            date: sessionData.timestamp,
            accuracy: parseFloat(sessionAccuracy.toFixed(1)),
            durationMs: sessionData.durationMs,
            totalAttempts: totalAttempts
        };

        // Adiciona a nova pontua√ß√£o e mant√©m o array ordenado e limitado
        topScores.push(newScore);
        topScores.sort((a, b) => b.accuracy - a.accuracy || b.durationMs - a.durationMs); // Ordena por precis√£o (maior primeiro), depois por dura√ß√£o (maior primeiro)
        topScores = topScores.slice(0, MAX_TOP_SCORES); // Mant√©m apenas o top N

        saveTopScores();
        displayTopScores();
        document.getElementById("result").textContent += " (Nova pontua√ß√£o adicionada ao ranking!)";
        document.getElementById("result").style.color = "purple";
    }

    // Exibe o ranking na interface
    function displayTopScores() {
        const list = document.getElementById("topScoresList");
        list.innerHTML = ""; // Limpa a lista existente

        if (topScores.length === 0) {
            const listItem = document.createElement("li");
            listItem.textContent = "Nenhuma pontua√ß√£o no ranking ainda. Fa√ßa uma sess√£o para come√ßar!";
            list.appendChild(listItem);
            return;
        }

        topScores.forEach((score, index) => {
            const listItem = document.createElement("li");
            listItem.classList.add("top-score-item");

            const date = new Date(score.date);
            const dateString = date.toLocaleDateString('pt-BR', {
                year: 'numeric', month: 'numeric', day: 'numeric'
            });
            const timeString = date.toLocaleTimeString('pt-BR', {
                hour: '2-digit', minute: '2-digit'
            });

            listItem.innerHTML = `
                <span>#${index + 1}: ${score.accuracy}%</span>
                <span class="score-details">
                    (${score.totalAttempts} tentativas em ${formatDuration(score.durationMs)}) - ${dateString} ${timeString}
                </span>
            `;
            list.appendChild(listItem);
        });
    }

    // Limpa o ranking local
    function clearTopScores() {
        if (confirm("Tem certeza que deseja limpar todo o ranking de melhores pontua√ß√µes? Esta a√ß√£o n√£o pode ser desfeita.")) {
            topScores = [];
            saveTopScores();
            displayTopScores();
            document.getElementById("result").textContent = "Ranking limpo.";
            document.getElementById("result").style.color = "blue";
        }
    }


    // Listener para as teclas do teclado
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();

      if (e.key === "Enter") {
        e.preventDefault(); // Evita que a tecla Enter ative outros bot√µes
        repeatNote_Enter(); // Chama a fun√ß√£o que mostra o nome da nota
        return;
      }
      if (e.key === " ") {
        e.preventDefault(); // Evita que a barra de espa√ßo role a p√°gina
        playNote();
        return;
      }
      // Tecla Backspace para repetir a nota (n√£o conta no contador, n√£o mostra nome)
      if (e.key === "Backspace") {
        e.preventDefault(); // Evita a navega√ß√£o de volta do navegador
        repeatNote_Backspace(); // Chama a fun√ß√£o que apenas toca a nota
        return;
      }

      // Usa o keyToNoteMap para encontrar a nota base correspondente √† tecla pressionada
      const pressedNoteBase = keyToNoteMap[key];
      if (pressedNoteBase) { // Se a tecla pressionada est√° no nosso mapeamento fixo
        const fullPressedNote = pressedNoteBase + currentOctave; // Cria a nota completa com a oitava atual

        // Verifica se a nota *base* que corresponde √† tecla pressionada
        // est√° entre as notas base dispon√≠veis para o treino (selecionadas ou do n√≠vel atual)
        let availableNotesForInputCheck = [];
        // Se o modo foco est√° ativo, verifica nas notas que est√£o sendo focadas
        if (focusModeActive) {
            const notesToFocus = getNotesToFocus();
            if (notesToFocus.length > 0) {
                availableNotesForInputCheck = notesToFocus.map(n => n.noteBase);
                 if (selectedNotesForStudy.length > 0) { // Se houver sele√ß√£o, foca entre as selecionadas
                    availableNotesForInputCheck = availableNotesForInputCheck.filter(note => selectedNotesForStudy.includes(note));
                    if (availableNotesForInputCheck.length === 0) { // Se n√£o encontrou notas focadas entre as selecionadas, usa todas as selecionadas
                        availableNotesForInputCheck = [...selectedNotesForStudy];
                    }
                }
            } else { // Se n√£o tem notas para focar, volta para o padr√£o
                 if (selectedNotesForStudy.length > 0) {
                    availableNotesForInputCheck = [...selectedNotesForStudy];
                } else {
                    availableNotesForInputCheck = noteSequenceForLevel.slice(0, currentLevel);
                }
            }
        } else {
            if (selectedNotesForStudy.length > 0) {
                availableNotesForInputCheck = [...selectedNotesForStudy];
            } else {
                availableNotesForInputCheck = noteSequenceForLevel.slice(0, currentLevel);
            }
        }
        

        if (availableNotesForInputCheck.includes(pressedNoteBase)) {
            checkAnswer(fullPressedNote); // Passa a nota completa para a checagem
        }
      }
    });

    // --- Inicializa√ß√£o do aplicativo ---
    // A ordem de carregamento √© importante aqui
    loadSettings(); // Carrega todas as configura√ß√µes salvas PRIMEIRO (instrumento, oitava, sequenceType, autoplay, feedback, selectedNotes, volume feedback)
    generateNoteSelectionCheckboxes(); // Gera os checkboxes de sele√ß√£o de notas e os marca com base em selectedNotesForStudy carregado
    updateSelectedNotes(); // Garante que `selectedNotesForStudy` esteja populado e a l√≥gica de n√≠vel seja resetada se necess√°rio
    updateDisplayNames();
    loadTrainingLevel(); // Carrega o n√≠vel de treino salvo
    noteSequenceForLevel = generateNoteSequenceBase(); // Gera a sequ√™ncia inicial de notas base (aleat√≥ria por padr√£o)
    updateButtons();
    updateStats();
    loadTotalTrainingDuration(); // Carrega o tempo total de treino ao iniciar o app
    loadNoteStats(); // Carrega as estat√≠sticas por nota ao iniciar o app
    loadSessionHistory(); // Carrega o hist√≥rico de sess√µes ao iniciar o app
    loadGoals(); // Carrega as metas ao iniciar o app
    loadTopScores(); // Carrega o ranking ao iniciar o app

    // Listener para salvar o tempo e o hist√≥rico ao fechar a p√°gina (garante que o tempo da sess√£o ativa seja salvo)
    window.addEventListener('beforeunload', () => {
        if (sessionStartTime) { // Se houver uma sess√£o ativa
            const sessionDuration = Date.now() - sessionStartTime;
            totalTrainingDuration += sessionDuration;

            // Registra a sess√£o no hist√≥rico antes de fechar
            const sessionData = {
                timestamp: new Date().toISOString(),
                durationMs: sessionDuration,
                sessionAcertos: currentSessionAcertos,
                sessionErros: currentSessionErros,
                focusMode: focusModeActive,
                focusedNotes: focusModeActive ? getNotesToFocus().map(n => n.noteBase) : [],
                accuracyAtSessionEnd: total > 0 ? ((acertos / total) * 100) : 0
            };
            sessionHistory.push(sessionData);
            // Tamb√©m adiciona ao ranking ao fechar a p√°gina, se a sess√£o foi relevante
            addSessionToTopScores(sessionData); // Garante que a sess√£o em andamento seja registrada no ranking
        }
        saveTotalTrainingDuration();
        saveNoteStats(); // Garante que as estat√≠sticas por nota tamb√©m sejam salvas
        saveSessionHistory(); // Garante que o hist√≥rico de sess√µes seja salvo
        saveTrainingLevel(); // Salva o n√≠vel de treino ao fechar
        saveTopScores(); // Garante que o ranking seja salvo ao fechar
        // As metas s√£o salvas ao serem definidas, n√£o ao fechar
    });
  </script>
</body>
</html>
