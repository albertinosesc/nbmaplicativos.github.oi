<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <title>üéµ Treino Auditivo com Timbres</title>
  <style>
    body { font-family: sans-serif; background: #f0f0f0; padding: 20px; }
    h1 { color: #333; }
    select, button { margin: 5px; padding: 10px; font-size: 16px; border-radius: 5px; border: 1px solid #ccc; cursor: pointer; }
    select:focus, button:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); }
    button { background-color: #007bff; color: white; transition: background-color 0.2s ease; }
    button:hover { background-color: #0056b3; }
    .result { margin-top: 15px; font-size: 20px; font-weight: bold; padding: 10px; border-radius: 5px; }
    #stats { margin-top: 10px; font-size: 18px; background-color: #e9ecef; padding: 10px; border-radius: 5px; }
    #buttons { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px; }
    #buttons button { flex: 1 1 auto; min-width: 120px; max-width: 180px; background-color: #6c757d; }
    #buttons button:hover { background-color: #5a6268; }

    /* Estilo para o bot√£o de ativar/desativar autom√°tico */
    #toggleAutoPlayNextNoteButton.active {
        background-color: #28a745; /* Verde quando ativo */
        color: white;
    }
    #toggleAutoPlayNextNoteButton.inactive {
        background-color: #dc3545; /* Vermelho quando inativo */
        color: white;
    }

    /* Estilos para o tutorial */
    .tutorial-section {
        background: #fff;
        border-radius: 8px;
        padding: 20px;
        margin-top: 30px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .tutorial-section h2 {
        color: #007bff;
        margin-top: 0;
    }
    .tutorial-section h3 {
        color: #555;
    }
    .tutorial-section ul {
        list-style-type: disc;
        margin-left: 20px;
        padding-left: 0;
    }
    .tutorial-section li {
        margin-bottom: 8px;
    }

    /* Estilos para a sele√ß√£o de notas */
    #noteSelection {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e2e6ea;
    }
    #noteSelection label {
        display: inline-block;
        margin-right: 15px;
        margin-bottom: 8px;
        font-size: 16px;
        cursor: pointer;
    }
    #noteSelection input[type="checkbox"] {
        margin-right: 5px;
        transform: scale(1.2); /* Aumenta o tamanho do checkbox */
    }
    #noteSelection button {
        margin-left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        background-color: #6c757d;
        border: none;
        border-radius: 4px;
        color: white;
        cursor: pointer;
    }
    #noteSelection button:hover {
        background-color: #5a6268;
    }

    /* Estilos para o registro de tempo */
    #trainingTimer {
        margin-top: 10px;
        font-size: 1.1em;
        font-weight: bold;
        color: #0056b3;
    }
    #trainingTimer .active-session {
        color: #28a745;
    }
    #trainingControls {
        margin-top: 10px;
    }
    #trainingControls button {
        background-color: #28a745;
    }
    #trainingControls button:hover {
        background-color: #218838;
    }
    #trainingControls button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    #trainingControls button.stop {
        background-color: #dc3545;
    }
    #trainingControls button.stop:hover {
        background-color: #c82333;
    }

    /* Estilos para as estat√≠sticas por nota */
    #noteStatsSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #noteStatsSection h3 {
        color: #007bff;
        margin-top: 0;
        margin-bottom: 15px;
    }
    .note-stat-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        font-size: 1em;
    }
    .note-stat-item strong {
        min-width: 60px;
        margin-right: 10px;
        text-align: right;
    }
    .progress-bar-container {
        flex-grow: 1;
        background-color: #e9ecef;
        border-radius: 5px;
        overflow: hidden; /* Garante que a barra interna n√£o vaze */
        height: 20px;
        position: relative;
    }
    .progress-bar-fill {
        height: 100%;
        background-color: #28a745; /* Verde para acertos */
        width: 0%; /* Ser√° preenchido por JS */
        position: absolute;
        left: 0;
        top: 0;
        transition: width 0.3s ease-out;
    }
    .progress-bar-error {
        height: 100%;
        background-color: #dc3545; /* Vermelho para erros */
        width: 0%; /* Ser√° preenchido por JS */
        position: absolute;
        right: 0;
        top: 0;
        transition: width 0.3s ease-out;
    }
    .progress-bar-text {
        position: absolute;
        width: 100%;
        text-align: center;
        line-height: 20px;
        color: #333;
        font-size: 0.85em;
        font-weight: bold;
        text-shadow: 0 0 2px rgba(255,255,255,0.7);
        z-index: 1;
    }
    #notesToImprove {
        margin-top: 20px;
        padding: 10px;
        background-color: #fff3cd; /* Amarelo claro para sugest√µes */
        border: 1px solid #ffeeba;
        border-radius: 5px;
        color: #856404;
    }
    #notesToImprove strong {
        color: #6a5303;
    }

    /* Estilos para o modo de foco */
    #focusModeControls {
        margin-top: 20px;
        padding: 15px;
        background-color: #eaf7ff; /* Azul claro */
        border-radius: 8px;
        border: 1px solid #cce5ff;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
    }
    #focusModeControls button {
        background-color: #6f42c1; /* Roxo */
    }
    #focusModeControls button:hover {
        background-color: #563198;
    }
    #focusModeControls button.active {
        background-color: #20c997; /* Verde-√°gua quando ativo */
    }
    #focusModeControls button.active:hover {
        background-color: #17a27b;
    }
    #focusModeStatus {
        font-weight: bold;
        color: #0056b3;
    }

    /* Estilos para a nova se√ß√£o de sele√ß√£o de notas no modo foco */
    #focusModeNoteSelection {
        margin-top: 20px;
        padding: 15px;
        background-color: #ffe6f2; /* Rosa claro */
        border-radius: 8px;
        border: 1px solid #ffccdd;
    }
    #focusModeNoteSelection h4 {
        color: #c2185b; /* Rosa escuro */
        margin-top: 0;
        margin-bottom: 10px;
    }
    #focusModeNoteSelection label {
        display: inline-block;
        margin-right: 15px;
        margin-bottom: 8px;
        font-size: 16px;
        cursor: pointer;
    }
    #focusModeNoteSelection input[type="checkbox"] {
        margin-right: 5px;
        transform: scale(1.2);
    }
    #focusModeNoteSelection button {
        margin-left: 10px;
        padding: 8px 12px;
        font-size: 14px;
        background-color: #e91e63; /* Rosa mais forte */
        border: none;
        border-radius: 4px;
        color: white;
        cursor: pointer;
    }
    #focusModeNoteSelection button:hover {
        background-color: #c2185b;
    }
    #focusModeNoteSelection input[type="number"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        width: 60px;
        margin-right: 5px;
    }


    /* Estilos para o hist√≥rico de sess√µes */
    #sessionHistorySection {
        margin-top: 30px;
        padding: 20px;
        background-color: #f8f8f8;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #sessionHistorySection h3 {
        color: #007bff;
        margin-top: 0;
        margin-bottom: 15px;
    }
    #sessionHistoryList {
        list-style: none;
        padding: 0;
    }
    .session-item {
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        padding: 15px;
        font-size: 0.95em;
        line-height: 1.5;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .session-item strong {
        color: #333;
    }
    .session-item span {
        display: block;
        margin-bottom: 3px;
    }
    .session-item .focus-notes {
        font-style: italic;
        color: #6f42c1; /* Roxo para as notas focadas */
    }

    /* Estilos para a se√ß√£o de metas */
    #goalsSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #e6ffe6; /* Verde claro */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border: 1px solid #c0ebc0;
    }
    #goalsSection h3 {
        color: #28a745; /* Verde escuro */
        margin-top: 0;
        margin-bottom: 15px;
    }
    #goalsSection label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
    }
    #goalsSection input[type="number"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        width: 80px;
        margin-right: 10px;
    }
    #goalsSection button {
        background-color: #28a745;
        margin-top: 10px;
        padding: 10px 15px;
    }
    #goalsSection button:hover {
        background-color: #218838;
    }
    .goal-status {
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        font-weight: bold;
        background-color: #d4edda; /* Sucesso */
        color: #155724;
        border: 1px solid #c3e6cb;
    }
    .goal-status.warning {
        background-color: #fff3cd; /* Aviso */
        color: #856404;
        border: 1px solid #ffeeba;
    }
    
    /* Novos estilos para as op√ß√µes de som e feedback visual */
    #audioFeedbackOptions, #autoPlayOptions {
        margin-top: 20px;
        padding: 15px;
        background-color: #f0f8ff; /* Azul clarinho */
        border-radius: 8px;
        border: 1px solid #b0d8f7;
    }
    #audioFeedbackOptions label, #autoPlayOptions label {
        margin-right: 15px;
        font-size: 16px;
        cursor: pointer;
    }
    #audioFeedbackOptions input[type="checkbox"], #autoPlayOptions input[type="checkbox"] {
        margin-right: 5px;
        transform: scale(1.2);
    }
    #autoPlayOptions select {
        width: auto;
    }

    /* Estilos para o ranking */
    #topScoresSection {
        margin-top: 30px;
        padding: 20px;
        background-color: #fefbe6; /* Amarelo muito claro */
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        border: 1px solid #fce883;
    }
    #topScoresSection h3 {
        color: #d4ac00; /* Dourado */
        margin-top: 0;
        margin-bottom: 15px;
    }
    #topScoresList {
        list-style: none;
        padding: 0;
    }
    .top-score-item {
        background-color: #fff;
        border: 1px solid #ffe99b;
        border-radius: 5px;
        margin-bottom: 8px;
        padding: 12px;
        font-size: 0.9em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .top-score-item span {
        font-weight: bold;
        color: #333;
    }
    .top-score-item .score-details {
        font-weight: normal;
        color: #666;
        font-size: 0.85em;
    }

    /* Estilos para o controle de volume */
    #feedbackVolumeControl {
        margin-top: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    #feedbackVolumeControl input[type="range"] {
        flex-grow: 1;
        width: 100%;
        -webkit-appearance: none;
        height: 8px;
        border-radius: 5px;
        background: #d3d3d3;
        outline: none;
        opacity: 0.7;
        transition: opacity .2s;
    }
    #feedbackVolumeControl input[type="range"]:hover {
        opacity: 1;
    }
    #feedbackVolumeControl input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
    }
    #feedbackVolumeControl input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
    }
    #feedbackVolumeControl #feedbackVolumeValue {
        font-weight: bold;
        min-width: 40px;
        text-align: right;
    }
  </style>
</head>
<body>
  <h1>üéµ Treino Auditivo com Timbres</h1>

  <label for="instrument">üéº Timbre:</label>
  <select id="instrument" onchange="changeInstrument()">
    <option value="acoustic_grand_piano-mp3">üéπ Piano (Acoustic Grand)</option>
    <option value="acoustic_guitar_nylon-mp3">üé∏ Guitar (Acoustic Nylon)</option>
    <option value="cello-mp3">üéª Cello</option>
    <option value="flute-mp3">üé∂ Flauta</option>
    <option value="church_organ-mp3">‚õ™ √ìrg√£o de Igreja</option>
    <option value="trumpet-mp3">üé∫ Trompete</option>
    <option value="tenor_sax-mp3">üé∑ Saxofone Tenor</option>
  </select>

  <label for="octave">üé∂ Oitava:</label>
  <select id="octave" onchange="changeOctave()">
    <option value="3">3</option>
    <option value="4" selected>4</option>
    <option value="5">5</option>
  </select>

  <label for="sequenceType">üîÑ Sequ√™ncia de Notas:</label>
  <select id="sequenceType" onchange="changeSequenceType()">
    <option value="random">Aleat√≥ria</option>
    <option value="fourths">Intervalo de Quartas</option>
    <option value="fifths">Intervalo de Quintas</option>
    <option value="chromaticAsc">Crom√°tica Ascendente</option>
    <option value="chromaticDesc">Crom√°tica Descendente</option>
  </select>

  <button onclick="playNote()">üîä Tocar Nota</button>
  <button onclick="resetCounters()">üîÑ Reiniciar Contadores</button>
  
  <div id="autoPlayOptions">
      <h3>Op√ß√µes de Reprodu√ß√£o Autom√°tica:</h3>
      <button id="toggleAutoPlayNextNoteButton" onclick="toggleAutoPlayNextNote()" class="inactive">
          ‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Desativado)
      </button>
      <label for="autoPlayDelay">Atraso (segundos):</label>
      <select id="autoPlayDelay" onchange="saveSetting('autoPlayDelay', this.value)">
          <option value="1">1</option>
          <option value="1.5" selected>1.5</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
      </select>
      <br><br>
      <label>
          <input type="checkbox" id="hideVisualFeedback" onchange="saveSetting('hideVisualFeedback', this.checked)">
          Ocultar feedback visual (Modo Auto)
      </label>
  </div>

  <div id="audioFeedbackOptions">
      <h3>Op√ß√µes de Feedback Sonoro:</h3>
      <label>
          <input type="checkbox" id="playCorrectSound" onchange="saveSetting('playCorrectSound', this.checked)">
          Tocar som de acerto
      </label>
      <label>
          <input type="checkbox" id="playWrongSound" onchange="saveSetting('playWrongSound', this.checked)">
          Tocar som de erro
      </label>
      <div id="feedbackVolumeControl">
          <label for="feedbackVolume">Volume dos Sons de Feedback:</label>
          <input type="range" id="feedbackVolume" min="0" max="1" step="0.05" value="0.5" oninput="updateFeedbackVolume(this.value)">
          <span id="feedbackVolumeValue">50%</span>
      </div>
  </div>

  <div id="noteSelection">
    <h3>üéØ Selecionar Notas para Estudo:</h3>
    <div id="noteCheckboxes">
      </div>
    <button onclick="selectAllNotes()">Selecionar Todas</button>
    <button onclick="clearAllNotes()">Limpar Sele√ß√£o</button>
  </div>

  <div id="trainingControls">
      <button id="startSessionBtn" onclick="startTrainingSession()">‚ñ∂Ô∏è Iniciar Sess√£o</button>
      <button id="endSessionBtn" onclick="endTrainingSession()" class="stop" disabled>‚èπÔ∏è Finalizar Sess√£o</button>
      <div id="trainingTimer">Tempo total de treino: 00h 00m 00s</div>
  </div>

  <div id="buttons"></div>
  <div class="result" id="result"></div>
  <div id="stats"></div>

  <div id="noteStatsSection">
    <h3>üìà Desempenho por Nota</h3>
    <div id="notePerformanceChart">
      </div>
    <div id="notesToImprove">
      <strong>Sugest√£o para Focar:</strong> <span id="notesToImproveList">Nenhuma nota para sugerir ainda.</span>
    </div>
    <button onclick="resetNoteStats()">Limpar Estat√≠sticas por Nota</button>
  </div>

  <div id="focusModeControls">
      <button id="toggleFocusModeButton" onclick="toggleFocusMode()">
        üéØ Ativar Modo Foco nas Notas Fracas (Desativado)
      </button>
      <span id="focusModeStatus"></span>
  </div>

  <div id="focusModeNoteSelection">
    <h4>‚öôÔ∏è Sele√ß√£o de Notas no Modo Foco:</h4>
    <div>
        <label for="focusModeErrorThreshold">Notas com erro acima de:</label>
        <input type="number" id="focusModeErrorThreshold" value="20" min="0" max="100" onchange="updateFocusModeNoteSelection()">%
        <button onclick="updateFocusModeNoteSelection()">Atualizar Notas Fracas</button>
    </div>
    <div id="focusModeNotesCheckboxes" style="margin-top: 10px;">
        </div>
    <button onclick="selectAllFocusNotes()">Selecionar Todas as Fracas</button>
    <button onclick="clearAllFocusNotes()">Limpar Sele√ß√£o</button>
  </div>


  <div id="goalsSection">
    <h3>üèÖ Minhas Metas de Treino</h3>
    <div style="margin-bottom: 15px;">
        <label>Selecione os tipos de meta:</label><br>
        <label>
            <input type="checkbox" id="goalTypeNotes" onchange="toggleGoalInput('goalQuantityNotes', this.checked)">
            Por Quantidade de Notas
        </label>
        <label>
            <input type="checkbox" id="goalTypeAccuracy" onchange="toggleGoalInput('minAccuracy', this.checked)">
            Por Porcentagem de Precis√£o
        </label>
        <label>
            <input type="checkbox" id="goalTypeTime" onchange="toggleGoalInput('minSessionTime', this.checked)">
            Por Tempo
        </label>
    </div>
    <div>
        <label for="goalQuantityNotes">Quantidade de notas total por sess√£o:</label>
        <input type="number" id="goalQuantityNotes" value="50" min="1" disabled>
    </div>
    <div>
        <label for="minSessionTime">Tempo m√≠nimo por sess√£o (minutos):</label>
        <input type="number" id="minSessionTime" value="10" min="1" disabled>
    </div>
    <div>
        <label for="minAccuracy">Precis√£o m√≠nima geral (%):</label>
        <input type="number" id="minAccuracy" value="80" min="0" max="100" disabled>
    </div>
    <button onclick="saveGoals()">Definir Metas</button>
    <div id="currentGoalsStatus" class="goal-status">
        </div>
  </div>

  <div id="sessionHistorySection">
    <h3>üìä Hist√≥rico de Sess√µes de Treino</h3>
    <ul id="sessionHistoryList">
      </ul>
    <button onclick="clearSessionHistory()">Limpar Hist√≥rico de Sess√µes</button>
  </div>

  <div id="topScoresSection">
    <h3>üèÜ Melhores Pontua√ß√µes (Ranking de Precis√£o)</h3>
    <ul id="topScoresList">
      </ul>
    <button onclick="clearTopScores()">Limpar Ranking</button>
  </div>

  <div class="tutorial-section">
    <h2>üéµ Treino Auditivo com Timbres: Guia Completo</h2>
    <p>Boas-vindas! Este aplicativo foi desenvolvido para aprimorar sua percep√ß√£o auditiva de notas musicais em diversos timbres. Pratique diariamente e acompanhe seu progresso!</p>

    <h3>üöÄ Come√ßando a Treinar</h3>
    <ul>
      <li><strong>üéº Timbre:</strong> Escolha o instrumento que deseja para o treino (Piano, Viol√£o, Cello, Flauta, etc.).</li>
      <li><strong>üé∂ Oitava:</strong> Selecione a oitava das notas que ser√£o tocadas.</li>
      <li><strong>üîÑ Sequ√™ncia de Notas:</strong>
        <ul>
          <li><strong>Aleat√≥ria:</strong> Notas s√£o tocadas em ordem aleat√≥ria, usando a sequ√™ncia que voc√™ j√° conhece (D√≥, F√°‚ôØ, L√°, etc.).</li>
          <li><strong>Intervalo de Quartas/Quintas:</strong> As notas seguem a sequ√™ncia de quartas ou quintas perfeitas (C-F-Bb, C-G-D, etc.).</li>
          <li><strong>Crom√°tica Ascendente/Descendente:</strong> As notas s√£o tocadas em ordem sequencial da escala crom√°tica, para cima ou para baixo.</li>
        </ul>
      </li>
      <li><strong>üîä Tocar Nota:</strong> Clique neste bot√£o (ou pressione a <kbd>Barra de Espa√ßo</kbd>) para ouvir uma nova nota.</li>
      <li><strong>‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico:</strong> Ative este modo para que uma nova nota seja tocada automaticamente ap√≥s cada tentativa (certa ou errada). Desative para controle manual.</li>
      <li><strong>üîÑ Reiniciar Contadores:</strong> Zera todas as suas estat√≠sticas de acertos e erros.</li>
    </ul>

    <h3>‚å®Ô∏è Fun√ß√µes das Teclas do Teclado</h3>
    <p>Para agilizar seu treino, voc√™ pode usar as seguintes teclas:</p>
    <ul>
      <li><kbd>Barra de Espa√ßo</kbd> (<kbd>Spacebar</kbd>): Toca uma **nova nota**.</li>
      <li><kbd>Enter</kbd>: **Repete** a nota tocada no momento e **mostra qual √© a nota**. √ötil se voc√™ n√£o tem certeza e quer uma segunda chance para identificar. Esta repeti√ß√£o **n√£o afeta** seus contadores de estat√≠sticas.</li>
      <li><kbd>R</kbd>: Apenas **repete** a nota tocada no momento, **sem revelar** qual √© e **sem afetar** seus contadores. Perfeito para uma audi√ß√£o extra.</li>
      <li><strong>Teclas de Notas</strong> (<kbd>C</kbd>, <kbd>J</kbd>, <kbd>A</kbd>, <kbd>E</kbd>, <kbd>D</kbd>, <kbd>K</kbd>, <kbd>B</kbd>, <kbd>I</kbd>, <kbd>G</kbd>, <kbd>U</kbd>, <kbd>F</kbd>, <kbd>L</kbd>): Use essas teclas para **responder** qual nota voc√™ ouviu. O mapeamento √© fixo e segue a sua prefer√™ncia:
        <ul>
          <li><kbd>C</kbd> = D√≥</li>
          <li><kbd>J</kbd> = F√°‚ôØ</li>
          <li><kbd>A</kbd> = L√°</li>
          <li><kbd>E</kbd> = Mi</li>
          <li><kbd>D</kbd> = R√©</li>
          <li><kbd>K</kbd> = Sol‚ôØ</li>
          <li><kbd>B</kbd> = Si</li>
          <li><kbd>I</kbd> = R√©‚ôØ</li>
          <li><kbd>G</kbd> = Sol</li>
          <li><kbd>U</kbd> = D√≥‚ôØ</li>
          <li><kbd>F</kbd> = F√°</li>
          <li><kbd>L</kbd> = L√°‚ôØ</li>
        </ul>
      </li>
    </ul>

    <h3>üìä Seu Desempenho e Metas</h3>
    <ul>
      <li><strong>üéØ Estat√≠sticas Gerais:</strong> Acompanhe o total de notas tocadas, seus acertos, erros e precis√£o percentual em tempo real.</li>
      <li><strong>üìà Gr√°fico de Acertos/Erros por Nota:</strong> Uma nova se√ß√£o abaixo dos bot√µes de resposta mostra seu desempenho individual para cada nota, com barras coloridas e porcentagens.</li>
      <li><strong>Sugest√£o de Notas para Melhorar:</strong> Abaixo do gr√°fico, o aplicativo poder√° sugerir as 3 notas com menor taxa de acerto (com pelo menos 5 tentativas) para focar seus estudos.</li>
      <li>**NOVO! Dificuldade Din√¢mica:** O n√≠vel do treino (n√∫mero de notas dispon√≠veis) agora se ajusta automaticamente. Acerte 3 notas seguidas para aumentar o n√≠vel e introduzir uma nova nota; erre 2 seguidas para diminuir o n√≠vel e focar nas notas anteriores.</li>
    </ul>

    <h3>üóìÔ∏è Registro de Tempo de Treino (Modo Ofensivo)</h3>
    <p>Use os bot√µes "Iniciar Sess√£o" e "Finalizar Sess√£o" para registrar o tempo que voc√™ dedica ao treino. Seu tempo total acumulado ser√° exibido.</p>

    <h3>üéØ Sele√ß√£o de Notas para Estudo</h3>
    <p>Use a se√ß√£o "Selecionar Notas para Estudo" acima para escolher as notas espec√≠ficas que deseja praticar. Se nenhuma nota for selecionada, todas as notas do tipo de sequ√™ncia escolhido ser√£o usadas no treino.</p>

    <h3>üö® Modo Foco nas Notas Fracas (NOVO!)</h3>
    <p>Ative este modo para que o aplicativo priorize as notas em que voc√™ tem menos acertos, garantindo um treino mais direcionado e eficaz. As notas para foco s√£o automaticamente determinadas pelas suas estat√≠sticas de desempenho.</p>

    <h3>üìú Hist√≥rico de Sess√µes de Treino (NOVO!)</h3>
    <p>Visualize um registro detalhado de todas as suas sess√µes de treino passadas, incluindo data, dura√ß√£o, acertos, erros e se o modo de foco estava ativo. Acompanhe sua evolu√ß√£o ao longo do tempo!</p>

    <h3>üèÖ Metas de Treino (NOVO!)</h3>
    <p>Defina metas personalizadas para seu tempo de treino por sess√£o e sua precis√£o geral. O aplicativo ir√° te ajudar a acompanhar seu progresso em rela√ß√£o a esses objetivos!</p>

    <h3>üèÜ Ranking Local (Top Scores) (NOVO!)</h3>
    <p>Veja suas melhores sess√µes registradas no ranking local, ordenadas pela precis√£o! Tente superar suas pr√≥prias marcas!</p>
  </div>
  <script>
    // Todas as 12 notas crom√°ticas em ordem padr√£o (para c√°lculos de intervalos)
    const allNotesChromatic = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

    // SEUS ARRAYS ORIGINAIS para mapeamento fixo de nota-tecla
    const originalBaseNotesOrder = ["C", "Gb", "A", "E", "D", "Ab", "B", "Eb", "G", "Db", "F", "Bb"];
    const originalKeyBindingsOrder = ['c','j','a','e','d','k','b','i','g','u','f','l'];

    // Mapeamentos diretos de Nota Base para Tecla e de Tecla para Nota Base
    const noteToKeyMap = {};
    const keyToNoteMap = {};
    for (let i = 0; i < originalBaseNotesOrder.length; i++) {
        const note = originalBaseNotesOrder[i];
        const key = originalKeyBindingsOrder[i];
        noteToKeyMap[note] = key;
        keyToNoteMap[key] = note;
    }

    const baseDisplayNames = {
      "C": "D√≥", "Db": "D√≥‚ôØ", "D": "R√©", "Eb": "R√©‚ôØ", "E": "Mi", "F": "F√°",
      "Gb": "F√°‚ôØ", "G": "Sol", "Ab": "Sol‚ôØ", "A": "L√°", "Bb": "L√°‚ôØ", "B": "Si"
    };

    let audioBase = "./acoustic_grand_piano-mp3/";
    let currentLevel = 2; // Come√ßa com 2 notas dispon√≠veis
    let streak = 0; // Acertos consecutivos
    let errorStreak = 0; // Erros consecutivos
    const STREAK_TO_ADVANCE = 3; // Quantos acertos para aumentar o n√≠vel
    const ERRORS_TO_REDUCE_LEVEL = 2; // Quantos erros para diminuir o n√≠vel (m√≠nimo de 2 notas)
    let currentNote = ""; // A nota que est√° tocando atualmente (ex: "C4")
    let currentOctave = 4;
    let currentSequenceType = "random"; // Tipo de sequ√™ncia de notas (aleat√≥ria, quartas, etc.)

    let total = 0;
    let acertos = 0;
    erros = 0;

    // --- Vari√°veis para estat√≠sticas por nota ---
    let noteStats = {}; // Ex: {"C": {acertos: 0, erros: 0}, "Db": {acertos: 0, erros: 0}, ...}
    const NOTE_STATS_KEY = 'trainingAppNoteStats'; // Chave para o localStorage de estat√≠sticas

    let currentPlayingAudio = null;
    let autoPlayNextNote = false;
    let autoPlayTimeout = null;
    let autoPlayDelaySeconds = 1.5; // Padr√£o 1.5 segundos
    let hideVisualFeedback = false; // Padr√£o: mostrar feedback visual

    // noteSequenceForLevel conter√° APENAS as NOTAS BASE (ex: "C", "F", "Bb") que s√£o relevantes para o n√≠vel atual
    // A oitava √© adicionada na hora de tocar ou verificar.
    let noteSequenceForLevel = [];
    let displayNames = {}; // Mapeia "C4" para "D√≥", etc.

    // Mapeia notas crom√°ticas para seus √≠ndices em allNotesChromatic para c√°lculo de intervalos
    const noteToIndexChromatic = Object.fromEntries(allNotesChromatic.map((note, index) => [note, index]));

    // Array para armazenar as notas base selecionadas pelo usu√°rio
    let selectedNotesForStudy = [];

    // --- Vari√°veis para o registro de tempo ---
    let sessionStartTime = null; // Timestamp quando a sess√£o come√ßou
    let currentSessionTotalNotes = 0; // Notas tocadas na sess√£o atual
    let currentSessionAcertos = 0; // Acertos na sess√£o atual
    let currentSessionErros = 0;   // Erros na sess√£o atual
    let totalTrainingDuration = 0; // Dura√ß√£o total acumulada em milissegundos
    let trainingIntervalId = null; // ID do setInterval para atualizar o timer
    const LOCAL_STORAGE_KEY_TOTAL_TIME = 'trainingAppTotalTime'; // Chave para o localStorage do tempo total

    // --- Vari√°vel para o modo de foco ---
    let focusModeActive = false;
    const FOCUS_MODE_MIN_ATTEMPTS = 5; // M√≠nimo de tentativas para uma nota ser considerada no modo foco
    // const FOCUS_MODE_NUM_NOTES = 3; // Removido, agora o usu√°rio seleciona
    let focusModeErrorThreshold = 20; // Nova vari√°vel para o limiar de erro do modo foco
    let selectedFocusNotes = []; // Array para armazenar as notas selecionadas no modo foco
    const FOCUS_MODE_SETTINGS_KEY = 'trainingAppFocusModeSettings'; // Chave para o localStorage das configura√ß√µes do modo foco


    // --- Nova vari√°vel para o hist√≥rico de sess√µes ---
    let sessionHistory = []; // Array de objetos de sess√£o
    const SESSION_HISTORY_KEY = 'trainingAppSessionHistory'; // Chave para o localStorage do hist√≥rico

    // --- Novas vari√°veis para metas ---
    let trainingGoals = {
        minSessionTimeMinutes: 10, // Meta padr√£o: 10 minutos por sess√£o
        minAccuracyPercentage: 80,  // Meta padr√£o: 80% de precis√£o geral
        goalQuantityNotes: 50, // Nova meta: Quantidade total de notas tocadas na sess√£o
        goalTypeNotes: false, // Se a meta por quantidade de notas est√° ativa
        goalTypeAccuracy: false, // Se a meta por precis√£o est√° ativa
        goalTypeTime: false // Se a meta por tempo est√° ativa
    };
    const GOALS_KEY = 'trainingAppGoals'; // Chave para o localStorage das metas
    const CELEBRATION_SOUND_PATH = './son/celebration.mp3'; // Som de comemora√ß√£o
    let goalAchievedDuringSession = {
        notes: false,
        accuracy: false,
        time: false
    }; // Para controlar se o som j√° foi tocado para a meta atual

    // --- Vari√°veis de som de feedback ---
    let playCorrectSound = true; // Padr√£o: tocar som de acerto
    let playWrongSound = true;  // Padr√£o: tocar som de erro
    let feedbackVolume = 0.5; // Volume padr√£o para sons de acerto/erro (0.0 a 1.0)
    const CORRECT_SOUND_PATH = './son/correct.mp3';
    const WRONG_SOUND_PATH = './son/wrong.mp3';

    // --- Chaves para localStorage do N√≠vel e Configura√ß√µes ---
    const TRAINING_LEVEL_KEY = 'trainingAppLevel';
    const SETTINGS_KEY = 'trainingAppGeneralSettings'; // Alterado para ser mais geral


    // --- Vari√°veis para Ranking Local ---
    let topScores = []; // Array de objetos de melhores pontua√ß√µes
    const TOP_SCORES_KEY = 'trainingAppTopScores'; // Chave para o localStorage do ranking
    const MAX_TOP_SCORES = 5; // Limite de entradas no ranking


    // --- Fun√ß√µes de Salvar/Carregar Configura√ß√µes ---
    function saveSetting(key, value) {
        let settings = JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {};
        settings[key] = value;
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        
        // Atualiza a vari√°vel global correspondente
        if (key === 'autoPlayDelay') autoPlayDelaySeconds = parseFloat(value);
        if (key === 'hideVisualFeedback') hideVisualFeedback = value;
        if (key === 'playCorrectSound') playCorrectSound = value;
        if (key === 'playWrongSound') playWrongSound = value;
        if (key === 'feedbackVolume') feedbackVolume = parseFloat(value); // Salva o volume
        if (key === 'selectedNotesForStudy') selectedNotesForStudy = value;
        if (key === 'focusModeErrorThreshold') focusModeErrorThreshold = parseInt(value, 10);
        if (key === 'selectedFocusNotes') selectedFocusNotes = value;
    }

    function loadSettings() {
        const settings = JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {};

        // Carrega instrumento
        const savedInstrument = settings.instrument || 'acoustic_grand_piano-mp3';
        document.getElementById('instrument').value = savedInstrument;
        audioBase = `./${savedInstrument}/`;

        // Carrega oitava
        const savedOctave = settings.octave || '4';
        document.getElementById('octave').value = savedOctave;
        currentOctave = parseInt(savedOctave, 10);
        
        // Carrega tipo de sequ√™ncia
        const savedSequenceType = settings.sequenceType || 'random';
        document.getElementById('sequenceType').value = savedSequenceType;
        currentSequenceType = savedSequenceType;

        // Carrega delay do autoplay
        const savedAutoPlayDelay = settings.autoPlayDelay || '1.5';
        document.getElementById('autoPlayDelay').value = savedAutoPlayDelay;
        autoPlayDelaySeconds = parseFloat(savedAutoPlayDelay);

        // Carrega hideVisualFeedback
        hideVisualFeedback = settings.hideVisualFeedback !== undefined ? settings.hideVisualFeedback : false;
        document.getElementById('hideVisualFeedback').checked = hideVisualFeedback;

        // Carrega playCorrectSound
        playCorrectSound = settings.playCorrectSound !== undefined ? settings.playCorrectSound : true;
        document.getElementById('playCorrectSound').checked = playCorrectSound;

        // Carrega playWrongSound
        playWrongSound = settings.playWrongSound !== undefined ? settings.playWrongSound : true;
        document.getElementById('playWrongSound').checked = playWrongSound;

        // Carrega feedbackVolume
        feedbackVolume = settings.feedbackVolume !== undefined ? parseFloat(settings.feedbackVolume) : 0.5;
        document.getElementById('feedbackVolume').value = feedbackVolume;
        document.getElementById('feedbackVolumeValue').textContent = `${(feedbackVolume * 100).toFixed(0)}%`;

        // Notas selecionadas para estudo (geral)
        const savedSelectedNotes = settings.selectedNotesForStudy;
        if (savedSelectedNotes && Array.isArray(savedSelectedNotes)) {
            selectedNotesForStudy = savedSelectedNotes;
            // Marca os checkboxes correspondentes (ser√° feito em generateNoteSelectionCheckboxes)
        }

        // Configura√ß√µes do modo foco
        focusModeErrorThreshold = settings.focusModeErrorThreshold !== undefined ? parseInt(settings.focusModeErrorThreshold, 10) : 20;
        document.getElementById('focusModeErrorThreshold').value = focusModeErrorThreshold;
        
        const savedSelectedFocusNotes = settings.selectedFocusNotes;
        if (savedSelectedFocusNotes && Array.isArray(savedSelectedFocusNotes)) {
            selectedFocusNotes = savedSelectedFocusNotes;
        }
    }


    // --- Fun√ß√µes de Estat√≠sticas por Nota ---

    // Inicializa o objeto noteStats com todas as notas
    function initializeNoteStats() {
        allNotesChromatic.forEach(noteBase => {
            if (!noteStats[noteBase]) {
                noteStats[noteBase] = { acertos: 0, erros: 0 };
            }
        });
    }

    // Carrega as estat√≠sticas por nota salvas
    function loadNoteStats() {
        const savedStats = localStorage.getItem(NOTE_STATS_KEY);
        if (savedStats) {
            noteStats = JSON.parse(savedStats);
        }
        initializeNoteStats(); // Garante que todas as notas estejam no objeto, mesmo se n√£o salvas
        updateNoteStatsDisplay();
    }

    // Salva as estat√≠sticas por nota
    function saveNoteStats() {
        localStorage.setItem(NOTE_STATS_KEY, JSON.stringify(noteStats));
    }

    // Reseta as estat√≠sticas por nota
    function resetNoteStats() {
        if (confirm("Tem certeza que deseja zerar todas as estat√≠sticas de acertos/erros por nota? Esta a√ß√£o n√£o pode ser desfeita.")) {
            noteStats = {};
            initializeNoteStats(); // Reinicializa com zeros
            saveNoteStats();
            updateNoteStatsDisplay();
            updateFocusModeNoteSelection(); // Atualiza a sele√ß√£o de notas fracas
            document.getElementById("result").textContent = "Estat√≠sticas por nota reiniciadas.";
            document.getElementById("result").style.color = "blue";
        }
    }

    // Atualiza a exibi√ß√£o do gr√°fico e sugest√µes
    function updateNoteStatsDisplay() {
        const chartDiv = document.getElementById("notePerformanceChart");
        const notesToImproveList = document.getElementById("notesToImproveList");
        chartDiv.innerHTML = "";
        
        let notesPerformance = [];

        // Coleta os dados e calcula porcentagens
        allNotesChromatic.forEach(noteBase => {
            const stats = noteStats[noteBase] || { acertos: 0, erros: 0 };
            const totalAttempts = stats.acertos + stats.erros;
            const accuracy = totalAttempts > 0 ? (stats.acertos / totalAttempts) * 100 : 0;
            const errorRate = totalAttempts > 0 ? (stats.erros / totalAttempts) * 100 : 0;

            notesPerformance.push({
                noteBase: noteBase,
                displayName: baseDisplayNames[noteBase],
                acertos: stats.acertos,
                erros: stats.erros,
                totalAttempts: totalAttempts,
                accuracy: accuracy,
                errorRate: errorRate
            });

            // Cria a barra para cada nota
            const itemDiv = document.createElement("div");
            itemDiv.classList.add("note-stat-item");

            const strong = document.createElement("strong");
            strong.textContent = baseDisplayNames[noteBase];
            itemDiv.appendChild(strong);

            const barContainer = document.createElement("div");
            barContainer.classList.add("progress-bar-container");

            const fillAcertos = document.createElement("div");
            fillAcertos.classList.add("progress-bar-fill");
            fillAcertos.style.width = `${accuracy}%`;

            const fillErros = document.createElement("div");
            fillErros.classList.add("progress-bar-error");
            fillErros.style.width = `${errorRate}%`;
            fillErros.style.right = '0%'; // Garante que a barra de erro cres√ßa da direita para a esquerda

            const textSpan = document.createElement("span");
            textSpan.classList.add("progress-bar-text");
            textSpan.textContent = totalAttempts > 0 ? `${accuracy.toFixed(0)}% (${totalAttempts})` : '0% (0)';

            barContainer.appendChild(fillAcertos);
            barContainer.appendChild(fillErros);
            barContainer.appendChild(textSpan);
            itemDiv.appendChild(barContainer);
            chartDiv.appendChild(itemDiv);
        });

        // Sugest√£o de notas para melhorar (sempre as 3 piores com min tentativas)
        const notesToFocusForDisplay = getNotesForFocusMode(3); // Obt√©m as 3 piores para exibi√ß√£o
        if (notesToFocusForDisplay.length > 0) {
            notesToImproveList.textContent = notesToFocusForDisplay.map(note => `${note.displayName} (${note.errorRate.toFixed(0)}% erros)`).join(', ');
        } else {
            notesToImproveList.textContent = "Continue praticando para coletar dados e obter sugest√µes!";
        }
    }

    // --- Fun√ß√µes do Modo de Foco (ATUALIZADO) ---
    
    // Retorna as notas que se qualificam para o modo foco, considerando o threshold e min tentativas
    function getNotesForFocusMode(limit = Infinity) {
        let qualifiedNotes = [];
        allNotesChromatic.forEach(noteBase => {
            const stats = noteStats[noteBase] || { acertos: 0, erros: 0 };
            const totalAttempts = stats.acertos + stats.erros;
            const errorRate = totalAttempts > 0 ? (stats.erros / totalAttempts) * 100 : 0;

            if (totalAttempts >= FOCUS_MODE_MIN_ATTEMPTS && errorRate >= focusModeErrorThreshold) {
                qualifiedNotes.push({
                    noteBase: noteBase,
                    displayName: baseDisplayNames[noteBase],
                    errorRate: errorRate,
                    totalAttempts: totalAttempts
                });
            }
        });

        qualifiedNotes.sort((a, b) => b.errorRate - a.errorRate); // Ordena pela maior taxa de erro (do pior para o melhor)
        return qualifiedNotes.slice(0, limit);
    }

    // Gerar checkboxes para as notas no modo foco
    function updateFocusModeNoteSelection() {
        const checkboxesDiv = document.getElementById("focusModeNotesCheckboxes");
        checkboxesDiv.innerHTML = "";
        
        // As notas que se qualificam para o modo foco
        const notesToQualify = getNotesForFocusMode();
        
        if (notesToQualify.length === 0) {
            checkboxesDiv.textContent = "Nenhuma nota atende aos crit√©rios de erro ou tentativas m√≠nimas.";
            return;
        }

        notesToQualify.forEach(note => {
            const label = document.createElement("label");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = note.noteBase;
            checkbox.id = `focus-note-${note.noteBase}`;
            // Marca o checkbox se a nota j√° estava selecionada no modo foco (do localStorage)
            checkbox.checked = selectedFocusNotes.includes(note.noteBase);
            checkbox.onchange = updateSelectedFocusNotes;

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(`${note.displayName} (${note.errorRate.toFixed(0)}% erros - ${note.totalAttempts} tentativas)`));
            checkboxesDiv.appendChild(label);
        });

        // Certifica-se de que o input de threshold esteja com o valor correto
        document.getElementById('focusModeErrorThreshold').value = focusModeErrorThreshold;
        saveSetting('focusModeErrorThreshold', focusModeErrorThreshold);
    }

    // Atualiza o array `selectedFocusNotes` e salva no localStorage
    function updateSelectedFocusNotes() {
        selectedFocusNotes = [];
        const checkboxes = document.querySelectorAll('#focusModeNotesCheckboxes input[type="checkbox"]:checked');
        checkboxes.forEach(checkbox => {
            selectedFocusNotes.push(checkbox.value);
        });
        saveSetting('selectedFocusNotes', selectedFocusNotes);
        // N√£o reseta o n√≠vel aqui, pois o modo foco √© um filtro.
        // A l√≥gica de playNote vai usar selectedFocusNotes se o modo foco estiver ativo.
    }

    // Seleciona todas as notas qualificadas no modo foco
    function selectAllFocusNotes() {
        const checkboxes = document.querySelectorAll('#focusModeNotesCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelectedFocusNotes();
    }

    // Limpa todas as sele√ß√µes de notas no modo foco
    function clearAllFocusNotes() {
        const checkboxes = document.querySelectorAll('#focusModeNotesCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelectedFocusNotes();
    }

    function toggleFocusMode() {
        focusModeActive = !focusModeActive;
        const toggleButton = document.getElementById("toggleFocusModeButton");
        const statusSpan = document.getElementById("focusModeStatus");
        
        if (focusModeActive) {
            // Garante que a lista de notas fracas esteja atualizada antes de ativar o modo foco
            updateFocusModeNoteSelection();
            
            // As notas a serem focadas s√£o as que o usu√°rio SELECIONOU na interface de "Sele√ß√£o de Notas no Modo Foco"
            // E que tamb√©m satisfazem os crit√©rios de erro/tentativas
            const qualifiedAndSelectedFocusNotes = getNotesForFocusMode().filter(note => selectedFocusNotes.includes(note.noteBase));

            if (qualifiedAndSelectedFocusNotes.length === 0) {
                alert(`Para ativar o Modo Foco, selecione pelo menos uma nota com taxa de erro acima de ${focusModeErrorThreshold}% e ${FOCUS_MODE_MIN_ATTEMPTS} ou mais tentativas.`);
                focusModeActive = false; // Desativa se n√£o h√° notas para focar
                toggleButton.classList.remove('active');
                toggleButton.textContent = "üéØ Ativar Modo Foco nas Notas Fracas (Desativado)";
                statusSpan.textContent = "Modo Foco desativado.";
                statusSpan.style.color = "#0056b3";
                return;
            }
            toggleButton.classList.add('active');
            toggleButton.textContent = "üéØ Modo Foco nas Notas Fracas (Ativado)";
            statusSpan.textContent = `Focando em: ${qualifiedAndSelectedFocusNotes.map(n => n.displayName).join(', ')}`;
            statusSpan.style.color = "#20c997"; // Cor de ativo
            document.getElementById("result").textContent = "Modo Foco ATIVADO! Tocando notas fracas selecionadas.";
            document.getElementById("result").style.color = "darkblue";
            playNote(); // Toca a primeira nota no modo foco
        } else {
            toggleButton.classList.remove('active');
            toggleButton.textContent = "üéØ Ativar Modo Foco nas Notas Fracas (Desativado)";
            statusSpan.textContent = "Modo Foco desativado.";
            statusSpan.style.color = "#0056b3"; // Cor padr√£o
            document.getElementById("result").textContent = "Modo Foco DESATIVADO.";
            document.getElementById("result").style.color = "darkblue";
        }
    }

    // --- Fun√ß√µes de Registro de Tempo e Hist√≥rico de Sess√µes ---

    // Fun√ß√£o para carregar o tempo total salvo
    function loadTotalTrainingDuration() {
        const savedTime = localStorage.getItem(LOCAL_STORAGE_KEY_TOTAL_TIME);
        if (savedTime) {
            totalTrainingDuration = parseInt(savedTime, 10);
        } else {
            totalTrainingDuration = 0;
        }
        updateTrainingTimerDisplay();
    }

    // Fun√ß√£o para salvar o tempo total
    function saveTotalTrainingDuration() {
        localStorage.setItem(LOCAL_STORAGE_KEY_TOTAL_TIME, totalTrainingDuration);
    }

    // Fun√ß√£o para formatar o tempo para exibi√ß√£o
    function formatDuration(ms) {
        if (ms < 0) ms = 0; // Garante que n√£o exiba tempo negativo
        const seconds = Math.floor((ms / 1000) % 60);
        const minutes = Math.floor((ms / (1000 * 60)) % 60);
        const hours = Math.floor((ms / (1000 * 60 * 60)));

        const pad = (num) => num.toString().padStart(2, '0');
        return `${pad(hours)}h ${pad(minutes)}m ${pad(seconds)}s`;
    }

    // Fun√ß√£o para atualizar a exibi√ß√£o do timer
    function updateTrainingTimerDisplay() {
        const timerDiv = document.getElementById("trainingTimer");
        let currentSessionDuration = 0;
        if (sessionStartTime) {
            currentSessionDuration = Date.now() - sessionStartTime;
        }
        timerDiv.textContent = `Tempo total de treino: ${formatDuration(totalTrainingDuration + currentSessionDuration)}`;
        
        if (sessionStartTime) {
            timerDiv.classList.add('active-session');
        } else {
            timerDiv.classList.remove('active-session');
        }
    }

    // Fun√ß√£o para iniciar a sess√£o de treino
    function startTrainingSession() {
        if (!sessionStartTime) { // Apenas se uma sess√£o n√£o estiver ativa
            sessionStartTime = Date.now();
            currentSessionTotalNotes = 0;
            currentSessionAcertos = 0; // Zera contadores da sess√£o
            currentSessionErros = 0;
            // Reseta o status das metas para a nova sess√£o
            goalAchievedDuringSession = { notes: false, accuracy: false, time: false };

            document.getElementById("startSessionBtn").disabled = true;
            document.getElementById("endSessionBtn").disabled = false;
            document.getElementById("result").textContent = "Sess√£o de treino iniciada!";
            document.getElementById("result").style.color = "green";
            // Atualiza o timer a cada segundo
            trainingIntervalId = setInterval(updateTrainingTimerDisplay, 1000);
            updateTrainingTimerDisplay(); // Atualiza imediatamente
        }
    }

    // Fun√ß√£o para finalizar a sess√£o de treino
    function endTrainingSession() {
        if (sessionStartTime) { // Apenas se uma sess√£o estiver ativa
            const sessionDuration = Date.now() - sessionStartTime;
            totalTrainingDuration += sessionDuration;

            // Registra a sess√£o no hist√≥rico
            const sessionData = {
                timestamp: new Date().toISOString(),
                durationMs: sessionDuration,
                sessionAcertos: currentSessionAcertos,
                sessionErros: currentSessionErros,
                focusMode: focusModeActive,
                focusedNotes: focusModeActive ? getNotesForFocusMode().filter(n => selectedFocusNotes.includes(n.noteBase)).map(n => n.noteBase) : [],
                accuracyAtSessionEnd: total > 0 ? ((acertos / total) * 100) : 0, // Precis√£o geral no fim da sess√£o
                sessionTotalNotes: currentSessionTotalNotes
            };
            sessionHistory.push(sessionData);
            saveSessionHistory(); // Salva o hist√≥rico atualizado
            displaySessionHistory(); // Atualiza a exibi√ß√£o

            // Adiciona a sess√£o ao ranking
            addSessionToTopScores(sessionData);

            sessionStartTime = null; // Reseta o tempo de in√≠cio
            currentSessionTotalNotes = 0;
            currentSessionAcertos = 0; // Zera contadores da sess√£o
            currentSessionErros = 0;
            saveTotalTrainingDuration(); // Salva o novo total
            clearInterval(trainingIntervalId); // Para o timer
            trainingIntervalId = null;
            document.getElementById("startSessionBtn").disabled = false;
            document.getElementById("endSessionBtn").disabled = true;
            document.getElementById("result").textContent = `Sess√£o finalizada. Dura√ß√£o: ${formatDuration(sessionDuration)}`;
            document.getElementById("result").style.color = "red";
            updateTrainingTimerDisplay(); // Atualiza a exibi√ß√£o final
            checkGoals(true); // Verifica e atualiza o status das metas ap√≥s a sess√£o
        }
    }

    // Carrega o hist√≥rico de sess√µes do localStorage
    function loadSessionHistory() {
        const savedHistory = localStorage.getItem(SESSION_HISTORY_KEY);
        if (savedHistory) {
            sessionHistory = JSON.parse(savedHistory);
        } else {
            sessionHistory = [];
        }
        displaySessionHistory();
    }

    // Salva o hist√≥rico de sess√µes no localStorage
    function saveSessionHistory() {
        localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(sessionHistory));
    }

    // Exibe o hist√≥rico de sess√µes na interface
    function displaySessionHistory() {
        const list = document.getElementById("sessionHistoryList");
        list.innerHTML = ""; // Limpa a lista existente

        if (sessionHistory.length === 0) {
            const listItem = document.createElement("li");
            listItem.textContent = "Nenhuma sess√£o registrada ainda.";
            list.appendChild(listItem);
            return;
        }

        // Exibe as sess√µes mais recentes primeiro
        [...sessionHistory].reverse().forEach(session => {
            const listItem = document.createElement("li");
            listItem.classList.add("session-item");

            const date = new Date(session.timestamp);
            const dateString = date.toLocaleDateString('pt-BR', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });

            const sessionAccuracy = session.sessionAcertos + session.sessionErros > 0 ?
                ((session.sessionAcertos / (session.sessionAcertos + session.sessionErros)) * 100).toFixed(1) : "0.0";

            listItem.innerHTML = `
                <span><strong>Data:</strong> ${dateString}</span>
                <span><strong>Dura√ß√£o:</strong> ${formatDuration(session.durationMs)}</span>
                <span><strong>Total Notas:</strong> ${session.sessionTotalNotes} | <strong>Acertos:</strong> ${session.sessionAcertos} | <strong>Erros:</strong> ${session.sessionErros} | <strong>Precis√£o da sess√£o:</strong> ${sessionAccuracy}%</span>
                <span><strong>Modo Foco:</strong> ${session.focusMode ? 'Ativo' : 'Inativo'} ${session.focusMode && session.focusedNotes.length > 0 ? `<span class="focus-notes">(Notas: ${session.focusedNotes.map(n => baseDisplayNames[n]).join(', ')})</span>` : ''}</span>
            `;
            list.appendChild(listItem);
        });
    }

    // Fun√ß√£o para limpar todo o hist√≥rico de sess√µes
    function clearSessionHistory() {
        if (confirm("Tem certeza que deseja limpar todo o hist√≥rico de sess√µes? Esta a√ß√£o n√£o pode ser desfeita.")) {
            sessionHistory = [];
            saveSessionHistory();
            displaySessionHistory();
            document.getElementById("result").textContent = "Hist√≥rico de sess√µes limpo.";
            document.getElementById("result").style.color = "blue";
        }
    }

    // --- Fun√ß√µes de Metas (ATUALIZADO) ---
    
    // Toca o som de comemora√ß√£o
    function playCelebrationSound() {
        const audio = new Audio(CELEBRATION_SOUND_PATH);
        audio.volume = 0.8; // Volume um pouco mais alto para comemora√ß√£o
        audio.play().catch(e => console.error("Erro ao tocar som de comemora√ß√£o:", e));
    }

    function loadGoals() {
        const savedGoals = localStorage.getItem(GOALS_KEY);
        if (savedGoals) {
            trainingGoals = JSON.parse(savedGoals);
        }
        // Define os valores nos inputs
        document.getElementById("goalQuantityNotes").value = trainingGoals.goalQuantityNotes;
        document.getElementById("minSessionTime").value = trainingGoals.minSessionTimeMinutes;
        document.getElementById("minAccuracy").value = trainingGoals.minAccuracyPercentage;

        // Define o estado dos checkboxes e a habilita√ß√£o dos inputs
        document.getElementById("goalTypeNotes").checked = trainingGoals.goalTypeNotes;
        toggleGoalInput('goalQuantityNotes', trainingGoals.goalTypeNotes);
        
        document.getElementById("goalTypeAccuracy").checked = trainingGoals.goalTypeAccuracy;
        toggleGoalInput('minAccuracy', trainingGoals.goalTypeAccuracy);
        
        document.getElementById("goalTypeTime").checked = trainingGoals.goalTypeTime;
        toggleGoalInput('minSessionTime', trainingGoals.goalTypeTime);

        updateGoalStatus(); // Atualiza o status das metas na interface
    }

    function saveGoals() {
        trainingGoals.goalQuantityNotes = parseInt(document.getElementById("goalQuantityNotes").value, 10);
        trainingGoals.minSessionTimeMinutes = parseInt(document.getElementById("minSessionTime").value, 10);
        trainingGoals.minAccuracyPercentage = parseInt(document.getElementById("minAccuracy").value, 10);
        
        trainingGoals.goalTypeNotes = document.getElementById("goalTypeNotes").checked;
        trainingGoals.goalTypeAccuracy = document.getElementById("goalTypeAccuracy").checked;
        trainingGoals.goalTypeTime = document.getElementById("goalTypeTime").checked;

        localStorage.setItem(GOALS_KEY, JSON.stringify(trainingGoals));
        document.getElementById("result").textContent = "Metas de treino salvas!";
        document.getElementById("result").style.color = "darkgreen";
        updateGoalStatus();
    }

    function toggleGoalInput(inputId, isChecked) {
        document.getElementById(inputId).disabled = !isChecked;
    }

    // `checkGoals` agora recebe um par√¢metro `isEndOfSession`
    function checkGoals(isEndOfSession = false) {
        const statusDiv = document.getElementById("currentGoalsStatus");
        let statusHtml = `
            <span><strong>Metas Ativas:</strong></span><br>
        `;
        let allGoalsAchieved = true; // Assume que todas as metas ativas foram atingidas

        // Meta por Quantidade de Notas
        if (trainingGoals.goalTypeNotes) {
            if (sessionStartTime) { // S√≥ verifica se h√° uma sess√£o ativa
                if (currentSessionTotalNotes >= trainingGoals.goalQuantityNotes) {
                    statusHtml += `<span>‚úÖ Notas (${currentSessionTotalNotes}/${trainingGoals.goalQuantityNotes}): Atingida!</span><br>`;
                    if (!goalAchievedDuringSession.notes) {
                        playCelebrationSound();
                        goalAchievedDuringSession.notes = true;
                    }
                } else {
                    statusHtml += `<span>‚è≥ Notas (${currentSessionTotalNotes}/${trainingGoals.goalQuantityNotes}): Progresso.</span><br>`;
                    allGoalsAchieved = false;
                }
            } else {
                statusHtml += `<span>(Para meta de Notas, inicie uma sess√£o)</span><br>`;
                allGoalsAchieved = false;
            }
        }

        // Meta por Precis√£o
        if (trainingGoals.goalTypeAccuracy) {
            const currentAccuracy = total > 0 ? ((acertos / total) * 100) : 0;
            if (total > 0) {
                if (currentAccuracy >= trainingGoals.minAccuracyPercentage) {
                    statusHtml += `<span>‚úÖ Precis√£o (${currentAccuracy.toFixed(1)}% / ${trainingGoals.minAccuracyPercentage}%): Atingida!</span><br>`;
                    if (!goalAchievedDuringSession.accuracy) {
                        playCelebrationSound();
                        goalAchievedDuringSession.accuracy = true;
                    }
                } else {
                    statusHtml += `<span>‚è≥ Precis√£o (${currentAccuracy.toFixed(1)}% / ${trainingGoals.minAccuracyPercentage}%): Progresso.</span><br>`;
                    allGoalsAchieved = false;
                }
            } else {
                statusHtml += `<span>(Para meta de Precis√£o, toque algumas notas)</span><br>`;
                allGoalsAchieved = false;
            }
        }

        // Meta por Tempo (apenas verificada no final da sess√£o)
        if (trainingGoals.goalTypeTime) {
            const minTimeGoalMs = trainingGoals.minSessionTimeMinutes * 60 * 1000;
            if (isEndOfSession) {
                const lastSession = sessionHistory.length > 0 ? sessionHistory[sessionHistory.length - 1] : null;
                if (lastSession && lastSession.durationMs >= minTimeGoalMs) {
                    statusHtml += `<span>‚úÖ Tempo (${formatDuration(lastSession.durationMs)} / ${trainingGoals.minSessionTimeMinutes}m): Atingida!</span><br>`;
                    if (!goalAchievedDuringSession.time) {
                        playCelebrationSound();
                        goalAchievedDuringSession.time = true;
                    }
                } else if (lastSession) {
                    statusHtml += `<span>‚ùå Tempo (${formatDuration(lastSession.durationMs)} / ${trainingGoals.minSessionTimeMinutes}m): N√£o Atingida.</span><br>`;
                    allGoalsAchieved = false;
                } else {
                    statusHtml += `<span>(Para meta de Tempo, finalize uma sess√£o)</span><br>`;
                    allGoalsAchieved = false;
                }
            } else {
                // Durante a sess√£o, apenas mostra a meta
                statusHtml += `<span>‚è≥ Tempo: ${trainingGoals.minSessionTimeMinutes} minutos por sess√£o.</span><br>`;
                allGoalsAchieved = false; // N√£o pode ser considerada atingida at√© o final
            }
        }

        // Se nenhuma meta estiver ativa, exibe uma mensagem padr√£o
        if (!trainingGoals.goalTypeNotes && !trainingGoals.goalTypeAccuracy && !trainingGoals.goalTypeTime) {
            statusHtml += `<span>Nenhuma meta ativa. Selecione um tipo de meta acima para come√ßar!</span>`;
            allGoalsAchieved = false; // N√£o h√° metas para atingir
        }

        statusDiv.innerHTML = statusHtml;
        statusDiv.classList.remove('warning', 'success'); // Remove ambas as classes para redefinir
        
        // Se todas as metas ativas foram atingidas, ou se n√£o h√° metas ativas, marca como sucesso ou neutro
        if (allGoalsAchieved && (trainingGoals.goalTypeNotes || trainingGoals.goalTypeAccuracy || trainingGoals.goalTypeTime)) {
            statusDiv.classList.add('success'); // Todas as ativas foram atingidas
        } else if (!allGoalsAchieved && (trainingGoals.goalTypeNotes || trainingGoals.goalTypeAccuracy || trainingGoals.goalTypeTime)) {
            statusDiv.classList.add('warning'); // Pelo menos uma ativa n√£o foi atingida ou est√° em progresso
        } else {
             // Nenhuma meta ativa ou nenhuma verifica√ß√£o de tempo ainda
            statusDiv.classList.remove('warning', 'success'); // Garante que n√£o tenha cor
        }
    }


    // Fun√ß√£o para gerar os checkboxes de sele√ß√£o de notas
    function generateNoteSelectionCheckboxes() {
        const noteCheckboxesDiv = document.getElementById("noteCheckboxes");
        noteCheckboxesDiv.innerHTML = ""; // Limpa os checkboxes existentes

        allNotesChromatic.forEach(noteBase => {
            const label = document.createElement("label");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = noteBase;
            checkbox.id = `note-${noteBase}`;
            // Carrega o estado do checkbox com base em `selectedNotesForStudy` carregado do localStorage
            checkbox.checked = selectedNotesForStudy.includes(noteBase);
            checkbox.onchange = updateSelectedNotes; // Chama a fun√ß√£o ao mudar a sele√ß√£o

            label.appendChild(checkbox);
            label.appendChild(document.createTextNode(baseDisplayNames[noteBase]));
            noteCheckboxesDiv.appendChild(label);
        });
    }

    // Fun√ß√£o para atualizar o array selectedNotesForStudy
    function updateSelectedNotes() {
        selectedNotesForStudy = [];
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            if (checkbox.checked) {
                selectedNotesForStudy.push(checkbox.value);
            }
        });
        saveSetting('selectedNotesForStudy', selectedNotesForStudy); // Salva a sele√ß√£o
        
        // Sempre que a sele√ß√£o de notas muda, reiniciamos o n√≠vel de treino
        resetTrainingLevel();
        updateButtons(); // Atualiza os bot√µes de resposta
        document.getElementById("result").textContent = "Sele√ß√£o de notas atualizada!";
        document.getElementById("result").style.color = "darkcyan";
    }

    // Fun√ß√£o para selecionar todas as notas
    function selectAllNotes() {
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
        updateSelectedNotes();
    }

    // Fun√ß√£o para limpar todas as notas selecionadas
    function clearAllNotes() {
        const checkboxes = document.querySelectorAll('#noteCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
        updateSelectedNotes();
    }

    // Fun√ß√£o para reiniciar o n√≠vel de treino (usada ao mudar oitava, sequ√™ncia ou sele√ß√£o de notas)
    function resetTrainingLevel() {
        currentLevel = 2; // Volta ao n√≠vel inicial
        streak = 0; // Zera as streaks
        errorStreak = 0;
        saveTrainingLevel(); // Salva o n√≠vel resetado
        // Regenera a sequ√™ncia base para garantir que a l√≥gica de sele√ß√£o de notas seja aplicada
        noteSequenceForLevel = generateNoteSequenceBase();
    }

    // Fun√ß√£o para salvar o n√≠vel de treino
    function saveTrainingLevel() {
        const levelData = {
            currentLevel: currentLevel,
            streak: streak,
            errorStreak: errorStreak
        };
        localStorage.setItem(TRAINING_LEVEL_KEY, JSON.stringify(levelData));
    }

    // Fun√ß√£o para carregar o n√≠vel de treino
    function loadTrainingLevel() {
        const savedLevel = localStorage.getItem(TRAINING_LEVEL_KEY);
        if (savedLevel) {
            const levelData = JSON.parse(savedLevel);
            currentLevel = levelData.currentLevel || 2;
            streak = levelData.streak || 0;
            errorStreak = levelData.errorStreak || 0;
        }
    }


    // Fun√ß√£o para gerar a sequ√™ncia de notas base (sem a oitava) com base no tipo selecionado
    // AGORA CONSIDERA selectedNotesForStudy
    function generateNoteSequenceBase() {
      let sequence = [];
      let baseSequenceForType = [];

      switch (currentSequenceType) {
        case "random":
          baseSequenceForType = [...originalBaseNotesOrder];
          break;
        case "fourths":
          let currentNoteIndexForth = noteToIndexChromatic["C"];
          for (let i = 0; i < allNotesChromatic.length; i++) {
            baseSequenceForType.push(allNotesChromatic[currentNoteIndexForth]);
            currentNoteIndexForth = (currentNoteIndexForth + 5) % allNotesChromatic.length;
          }
          break;
        case "fifths":
          let currentNoteIndexFifth = noteToIndexChromatic["C"];
          for (let i = 0; i < allNotesChromatic.length; i++) {
            baseSequenceForType.push(allNotesChromatic[currentNoteIndexFifth]);
            currentNoteIndexFifth = (currentNoteIndexFifth + 7) % allNotesChromatic.length;
          }
          break;
        case "chromaticAsc":
          baseSequenceForType = [...allNotesChromatic];
          break;
        case "chromaticDesc":
          baseSequenceForType = [...allNotesChromatic].reverse();
          break;
        default:
          baseSequenceForType = [...originalBaseNotesOrder];
      }

      // Se houver notas selecionadas para estudo, filtra a sequ√™ncia base
      if (selectedNotesForStudy.length > 0) {
          // Garante que as notas na sequ√™ncia final estejam na ordem da baseSequenceForType
          // mas apenas se estiverem em selectedNotesForStudy
          sequence = baseSequenceForType.filter(note => selectedNotesForStudy.includes(note));
          
          // Se a sequ√™ncia filtrada ficar vazia, voltamos a usar todas as notas da baseSequenceForType
          // para evitar um erro e permitir que o treino continue
          if (sequence.length === 0) {
              console.warn("Nenhuma nota selecionada encontrada na sequ√™ncia gerada. Usando todas as notas da sequ√™ncia padr√£o.");
              sequence = baseSequenceForType;
          }
      } else {
          // Se nenhuma nota for selecionada, usa a sequ√™ncia base completa para o tipo
          sequence = baseSequenceForType;
      }
      return sequence;
    }

    // Atualiza os nomes de exibi√ß√£o completos (ex: "C4" -> "D√≥")
    function updateDisplayNames() {
      displayNames = {};
      allNotesChromatic.forEach(noteBase => {
        displayNames[noteBase + currentOctave] = baseDisplayNames[noteBase];
      });
    }

    // Cria/Atualiza os bot√µes na interface
    // AGORA CONSIDERA selectedNotesForStudy
    function updateButtons() {
      const buttonsDiv = document.getElementById("buttons");
      buttonsDiv.innerHTML = "";

      // Pega as notas base que est√£o no n√≠vel atual da sequ√™ncia escolhida
      // E que tamb√©m est√£o entre as notas selecionadas para estudo (se houver)
      let notesToDisplayOnButtons = [];

      if (selectedNotesForStudy.length > 0) {
        // Se h√° notas selecionadas, usa a ordem crom√°tica para determinar o subconjunto vis√≠vel
        // com base no currentLevel.
        // Isso simula o crescimento da dificuldade dentro da sele√ß√£o do usu√°rio.
        const sortedSelectedNotes = allNotesChromatic.filter(note => selectedNotesForStudy.includes(note));
        notesToDisplayOnButtons = sortedSelectedNotes.slice(0, currentLevel);
      } else {
        // Se n√£o h√° notas selecionadas, volta ao comportamento original usando noteSequenceForLevel
        notesToDisplayOnButtons = noteSequenceForLevel.slice(0, currentLevel);
      }
      
      // Se n√£o houver notas para exibir (ex: todas as selecionadas j√° foram dominadas ou nenhuma selecionada e n√≠vel baixo)
      // Usamos todas as notas do n√≠vel atual da sequ√™ncia para evitar bot√µes vazios
      if (notesToDisplayOnButtons.length === 0) {
          // Isso pode acontecer se o currentLevel for muito baixo e as notas selecionadas n√£o estiverem no in√≠cio da sequ√™ncia.
          // Para garantir que sempre haja bot√µes, podemos usar todas as notas selecionadas.
          // Mas isso s√≥ se aplica se houver selectedNotesForStudy, caso contr√°rio, deve usar a sequ√™ncia padr√£o.
          if (selectedNotesForStudy.length > 0) {
              notesToDisplayOnButtons = selectedNotesForStudy;
          } else {
              // Se nenhuma nota selecionada e n√≠vel 0, volta para as 2 primeiras da sequ√™ncia padr√£o
              notesToDisplayOnButtons = noteSequenceForLevel.slice(0, 2); 
              currentLevel = 2; // Garante que o n√≠vel m√≠nimo seja 2 se n√£o houver sele√ß√£o
          }
      }

      notesToDisplayOnButtons.forEach(noteBase => {
        const btn = document.createElement("button");
        const keyText = noteToKeyMap[noteBase] ? `[${noteToKeyMap[noteBase].toUpperCase()}]` : '';
        btn.textContent = `${baseDisplayNames[noteBase]} ${keyText}`;
        btn.onclick = () => checkAnswer(noteBase + currentOctave);
        buttonsDiv.appendChild(btn);
      });
    }

    function updateStats() {
      const statsDiv = document.getElementById("stats");
      const porcentagem = total > 0 ? ((acertos / total) * 100).toFixed(1) : "0.0";
      statsDiv.innerHTML = `üéØ Notas tocadas: ${total} | ‚úÖ Acertos: ${acertos} | ‚ùå Erros: ${erros} | üìä Precis√£o: ${porcentagem}%`;
      checkGoals(); // Tamb√©m atualiza o status das metas quando as estat√≠sticas gerais mudam
    }

    function resetCounters() {
      if (confirm("Tem certeza que deseja zerar todos os contadores de acertos/erros (gerais)? As estat√≠sticas por nota permanecer√£o.")) {
        total = 0;
        acertos = 0;
        erros = 0;
        streak = 0; // Tamb√©m zera a streak
        errorStreak = 0;
        currentLevel = 2; // Volta ao n√≠vel inicial
        saveTrainingLevel(); // Salva o n√≠vel resetado
        updateStats();
        document.getElementById("result").textContent = "üîÑ Contadores gerais reiniciados.";
        document.getElementById("result").style.color = "blue";
        if (currentPlayingAudio) {
          currentPlayingAudio.pause();
          currentPlayingAudio.currentTime = 0;
          currentPlayingAudio = null;
        }
        currentNote = "";
        if (autoPlayTimeout) {
          clearTimeout(autoPlayTimeout);
          autoPlayTimeout = null;
        }
        if (autoPlayNextNote) {
          toggleAutoPlayNextNote(); // Desativa o modo autom√°tico ao reiniciar
        }
        updateButtons(); // Atualiza os bot√µes para refletir o novo n√≠vel
      }
      // N√£o reinicia o tempo de treino com os outros contadores
    }

    function playRealNote(noteWithOctave) { // Ex: "C4"
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
      }
      const audioPath = `${audioBase}${noteWithOctave}.mp3`;
      const audio = new Audio(audioPath);
      audio.volume = 0.7; // Volume padr√£o das notas
      audio.play().then(() => {
        currentPlayingAudio = audio;
      }).catch(e => {
        console.error(`Erro ao tocar ${audioPath}:`, e);
        document.getElementById("result").textContent = "Erro ao carregar o som. Verifique o console do navegador (F12) e os arquivos MP3.";
        document.getElementById("result").style.color = "red";
      });
    }

    // playNote AGORA CONSIDERA selectedNotesForStudy e o Modo Foco
    function playNote() {
      let availableNotesForPlay = [];

      if (focusModeActive) {
          // As notas que ser√£o tocadas no modo foco s√£o as QUALIFICADAS E SELECIONADAS PELO USU√ÅRIO
          const qualifiedAndSelectedFocusNotes = getNotesForFocusMode().filter(note => selectedFocusNotes.includes(note.noteBase));
          
          if (qualifiedAndSelectedFocusNotes.length > 0) {
              availableNotesForPlay = qualifiedAndSelectedFocusNotes.map(n => n.noteBase);
              
              // Se o usu√°rio tamb√©m selecionou notas para estudo no modo geral,
              // o modo foco atua como um filtro SOBRE essas notas selecionadas
              if (selectedNotesForStudy.length > 0) {
                  availableNotesForPlay = availableNotesForPlay.filter(note => selectedNotesForStudy.includes(note));
                  if (availableNotesForPlay.length === 0) {
                      console.warn("Modo Foco: Nenhuma das notas fracas selecionadas est√° entre as notas gerais selecionadas para estudo. Revertendo para notas fracas selecionadas.");
                      availableNotesForPlay = qualifiedAndSelectedFocusNotes.map(n => n.noteBase); // Volta a usar apenas as fracas selecionadas
                  }
              }
          } else {
              // Se o modo foco est√° ativo mas n√£o h√° notas que satisfa√ßam os crit√©rios e/ou foram selecionadas,
              // avisamos o usu√°rio e desativamos o modo foco.
              alert(`Nenhuma nota selecionada no Modo Foco atende aos crit√©rios (erro acima de ${focusModeErrorThreshold}% e ${FOCUS_MODE_MIN_ATTEMPTS} tentativas). Desativando Modo Foco.`);
              focusModeActive = false;
              toggleFocusMode(); // Atualiza o bot√£o e mensagem
              return; // Sai da fun√ß√£o
          }
      } else if (selectedNotesForStudy.length > 0) {
          // Se o usu√°rio selecionou notas para estudo no modo normal,
          // o pool de notas para tocar ser√° limitado pelo currentLevel
          // e as notas devem estar na sequ√™ncia crom√°tica para manter a ordem de progress√£o
          const sortedSelectedNotes = allNotesChromatic.filter(note => selectedNotesForStudy.includes(note));
          availableNotesForPlay = sortedSelectedNotes.slice(0, currentLevel);

          // Garante que o pool n√£o esteja vazio se currentLevel for 0 ou 1 quando deveria ter 2 notas.
          if (availableNotesForPlay.length === 0 && sortedSelectedNotes.length >= 2) {
            availableNotesForPlay = sortedSelectedNotes.slice(0, 2);
            currentLevel = 2; // Garante que o n√≠vel m√≠nimo seja 2 ao iniciar com sele√ß√£o de notas
          } else if (availableNotesForPlay.length === 0 && sortedSelectedNotes.length > 0) {
            // Se s√≥ tem 1 nota selecionada, tocar√° apenas ela
            availableNotesForPlay = sortedSelectedNotes;
            currentLevel = 1;
          } else if (availableNotesForPlay.length === 0) {
            // Caso raro onde selectedNotesForStudy est√° vazio mas a condi√ß√£o passou, impede erro
            document.getElementById("result").textContent = "Nenhuma nota selecionada para tocar.";
            document.getElementById("result").style.color = "orange";
            currentNote = "";
            return;
          }
      } else {
          // Usa as notas da sequ√™ncia gerada, limitada pelo currentLevel
          availableNotesForPlay = noteSequenceForLevel.slice(0, currentLevel);
      }

      if (availableNotesForPlay.length === 0) {
          document.getElementById("result").textContent = "Nenhuma nota dispon√≠vel para tocar. Selecione notas ou ajuste o n√≠vel/sequ√™ncia.";
          document.getElementById("result").style.color = "orange";
          currentNote = ""; // Garante que n√£o h√° nota "pendente"
          return;
      }

      // Escolhe uma nota aleat√≥ria entre as dispon√≠veis (focadas ou normais)
      const randomBaseNote = availableNotesForPlay[Math.floor(Math.random() * availableNotesForPlay.length)];
      currentNote = randomBaseNote + currentOctave; // Armazena a nota completa (ex: "C4")

      playRealNote(currentNote);
      if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
        document.getElementById("result").textContent = "Qual nota foi tocada?";
        document.getElementById("result").style.color = "black";
      } else {
        document.getElementById("result").textContent = ""; // Oculta a mensagem no modo autom√°tico
      }
      total++; // Aumenta o contador APENAS ao tocar uma nova nota (n√£o ao repetir)
      if (sessionStartTime) { // Se uma sess√£o est√° ativa, incrementa o contador de notas da sess√£o
          currentSessionTotalNotes++;
          checkGoals(); // Verifica as metas ao tocar uma nova nota
      }
      updateStats();

      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
    }

    function playFeedbackSound(isCorrect) {
        let soundPath = '';
        let shouldPlay = false;

        if (isCorrect && playCorrectSound) {
            soundPath = CORRECT_SOUND_PATH;
            shouldPlay = true;
        } else if (!isCorrect && playWrongSound) {
            soundPath = WRONG_SOUND_PATH;
            shouldPlay = true;
        }

        if (shouldPlay) {
            const audio = new Audio(soundPath);
            audio.volume = feedbackVolume; // Define o volume usando a vari√°vel global
            audio.play().catch(e => console.error("Erro ao tocar som de feedback:", e));
        }
    }

    function checkAnswer(selectedNoteWithOctave) { // A nota completa que foi clicada/pressionada (ex: "C4")
      const resultDiv = document.getElementById("result");
      if (!currentNote) { // Se nenhuma nota foi tocada ainda
        resultDiv.textContent = "Pressione 'Tocar Nota' ou espa√ßo para come√ßar.";
        resultDiv.style.color = "orange";
        return;
      }

      const playedNoteBase = currentNote.slice(0, -1); // Ex: "C4" -> "C"
      const selectedNoteBase = selectedNoteWithOctave.slice(0, -1); // Ex: "C4" -> "C"

      let isCorrectAnswer = (selectedNoteWithOctave === currentNote);

      if (isCorrectAnswer) {
        acertos++;
        currentSessionAcertos++; // Registra acerto para a sess√£o atual
        streak++;
        errorStreak = 0; // Zera a sequ√™ncia de erros
        noteStats[playedNoteBase].acertos++; // Registra acerto para a nota espec√≠fica
        
        playFeedbackSound(true); // Toca som de acerto
        
        if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
            resultDiv.textContent = `‚úÖ Correto! Era ${displayNames[currentNote]}`;
            resultDiv.style.color = "green";
        } else {
            resultDiv.textContent = "";
        }

        // --- L√≥gica de Aumento de N√≠vel (Dificuldade Din√¢mica) ---
        // O limite agora √© o n√∫mero total de notas na sequ√™ncia gerada OU o n√∫mero de notas selecionadas
        // Se o modo foco estiver ativo, o n√≠vel n√£o aumenta/diminui
        if (!focusModeActive) {
            const maxNotesForLevel = selectedNotesForStudy.length > 0 ? selectedNotesForStudy.length : noteSequenceForLevel.length;
            if (streak >= STREAK_TO_ADVANCE && currentLevel < maxNotesForLevel) {
                currentLevel++;
                streak = 0; // Reseta a streak ao aumentar o n√≠vel
                updateButtons(); // Atualiza os bot√µes para incluir a nova nota
                document.getElementById("result").textContent += ` üéâ Subiu de n√≠vel para ${currentLevel} notas!`;
                document.getElementById("result").style.color = "darkgreen";
            }
        }

      } else { // Resposta Incorreta
        erros++;
        currentSessionErros++; // Registra erro para a sess√£o atual
        streak = 0; // Zera a sequ√™ncia de acertos
        errorStreak++; // Incrementa a sequ√™ncia de erros
        noteStats[playedNoteBase].erros++; // Registra erro para a nota espec√≠fica
        
        playFeedbackSound(false); // Toca som de erro

        if (!autoPlayNextNote || !hideVisualFeedback) { // Se n√£o est√° no modo auto ou se n√£o ocultar feedback
            resultDiv.textContent = `‚ùå Errado! Era ${displayNames[currentNote]}`;
            resultDiv.style.color = "red";
        } else {
            resultDiv.textContent = "";
        }

        // --- L√≥gica de Diminui√ß√£o de N√≠vel (Dificuldade Din√¢mica) ---
        // Garante que o n√≠vel m√≠nimo seja 2 (pelo menos 2 notas para escolher)
        // Se o modo foco estiver ativo, o n√≠vel n√£o aumenta/diminui
        if (!focusModeActive) {
            if (errorStreak >= ERRORS_TO_REDUCE_LEVEL && currentLevel > 2) {
                currentLevel--;
                errorStreak = 0; // Reseta a sequ√™ncia de erros ao diminuir o n√≠vel
                updateButtons(); // Atualiza os bot√µes para remover a nota mais recente
                document.getElementById("result").textContent += ` üìâ N√≠vel diminu√≠do para ${currentLevel} notas para ajudar no foco.`;
                document.getElementById("result").style.color = "darkred";
            }
        }
      }

      saveTrainingLevel(); // Salva o n√≠vel e streak/errorStreak ap√≥s cada resposta
      currentNote = ""; // Reseta a nota atual para que uma nova seja tocada
      updateStats();
      saveNoteStats(); // Salva as estat√≠sticas por nota a cada resposta
      updateNoteStatsDisplay(); // Atualiza o gr√°fico de desempenho
      updateFocusModeNoteSelection(); // Atualiza a lista de notas fracas no modo foco
      checkGoals(); // Verifica as metas ao responder uma nota

      if (autoPlayNextNote) {
        autoPlayTimeout = setTimeout(() => {
          playNote();
        }, autoPlayDelaySeconds * 1000); // Usa o atraso configur√°vel
      }
    }

    // Fun√ß√£o repeatNote_R: Apenas toca a nota sem feedback visual extra
    function repeatNote_R() {
      if (currentNote) {
        playRealNote(currentNote);
        // N√£o altera a mensagem no resultDiv nem a cor, apenas toca a nota
        // Mant√©m a mensagem atual se houver uma (e.g., "Qual nota foi tocada?")
        // ou a √∫ltima mensagem de "Correto!"/"Errado!".
      } else {
        document.getElementById("result").textContent = "N√£o h√° nota para repetir. Pressione 'Tocar Nota' ou espa√ßo.";
        document.getElementById("result").style.color = "orange";
      }
    }
    
    // Fun√ß√£o repeatNote_Enter: Toca a nota e mostra o nome
    function repeatNote_Enter() {
      if (currentNote) {
        playRealNote(currentNote);
        document.getElementById("result").textContent = `üîÅ Repetindo: ${displayNames[currentNote]}`;
        document.getElementById("result").style.color = "blue";
      } else {
        document.getElementById("result").textContent = "N√£o h√° nota para repetir. Pressione 'Tocar Nota' ou espa√ßo.";
        document.getElementById("result").style.color = "orange";
      }
    }

    function changeInstrument() {
      const selected = document.getElementById("instrument").value;
      audioBase = `./${selected}/`;
      currentNote = ""; // Limpa a nota atual para evitar que tente tocar com o timbre antigo
      document.getElementById("result").textContent = `üéº Timbre alterado para: ${selected.replace(/_/g, ' ').replace(/-/g, ' ').replace('.mp3', '').trim()}`;
      document.getElementById("result").style.color = "darkgreen";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('instrument', selected); // Salva a prefer√™ncia
    }

    function changeOctave() {
      currentOctave = parseInt(document.getElementById("octave").value, 10);
      updateDisplayNames(); // Atualiza os nomes de exibi√ß√£o com a nova oitava
      resetTrainingLevel(); // Reinicia o n√≠vel ao mudar a oitava
      updateButtons(); // Recria os bot√µes com a nova oitava nos nomes completos para checagem
      currentNote = "";
      document.getElementById("result").textContent = `üé∂ Oitava alterada para ${currentOctave}`;
      document.getElementById("result").style.color = "purple";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('octave', currentOctave.toString()); // Salva a prefer√™ncia
    }

    function changeSequenceType() {
      currentSequenceType = document.getElementById("sequenceType").value;
      resetTrainingLevel(); // Reinicia o n√≠vel ao mudar a sequ√™ncia
      updateButtons(); // Atualiza os bot√µes com as notas da nova sequ√™ncia
      currentNote = "";
      document.getElementById("result").textContent = `üîÑ Sequ√™ncia alterada para: ${document.getElementById("sequenceType").options[document.getElementById("sequenceType").selectedIndex].text}`;
      document.getElementById("result").style.color = "darkblue";
      if (currentPlayingAudio) {
        currentPlayingAudio.pause();
        currentPlayingAudio.currentTime = 0;
        currentPlayingAudio = null;
      }
      if (autoPlayTimeout) {
        clearTimeout(autoPlayTimeout);
        autoPlayTimeout = null;
      }
      saveSetting('sequenceType', currentSequenceType); // Salva a prefer√™ncia
    }

    function toggleAutoPlayNextNote() {
      autoPlayNextNote = !autoPlayNextNote;
      const button = document.getElementById("toggleAutoPlayNextNoteButton");
      if (autoPlayNextNote) {
        button.textContent = "‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Ativado)";
        button.classList.remove('inactive');
        button.classList.add('active');
        if (!currentNote) { // Se n√£o houver nota tocando, j√° inicia
            playNote();
        }
      } else {
        button.textContent = "‚ñ∂Ô∏è Pr√≥xima Nota Autom√°tico (Desativado)";
        button.classList.remove('active');
        button.classList.add('inactive');
        if (autoPlayTimeout) {
          clearTimeout(autoPlayTimeout);
          autoPlayTimeout = null;
        }
      }
      document.getElementById("result").textContent = `Modo autom√°tico: ${autoPlayNextNote ? 'ATIVADO' : 'DESATIVADO'}`;
      document.getElementById("result").style.color = autoPlayNextNote ? "green" : "red";
    }

    // Fun√ß√£o para atualizar o volume de feedback e salv√°-lo
    function updateFeedbackVolume(value) {
        feedbackVolume = parseFloat(value);
        document.getElementById('feedbackVolumeValue').textContent = `${(feedbackVolume * 100).toFixed(0)}%`;
        saveSetting('feedbackVolume', feedbackVolume); // Salva o novo volume
    }

    // --- Fun√ß√µes de Ranking Local (Top Scores) ---

    // Carrega o ranking do localStorage
    function loadTopScores() {
        const savedScores = localStorage.getItem(TOP_SCORES_KEY);
        if (savedScores) {
            topScores = JSON.parse(savedScores);
        } else {
            topScores = [];
        }
        displayTopScores();
    }

    // Salva o ranking no localStorage
    function saveTopScores() {
        localStorage.setItem(TOP_SCORES_KEY, JSON.stringify(topScores));
    }

    // Adiciona uma sess√£o ao ranking, se for uma das melhores
    function addSessionToTopScores(sessionData) {
        const sessionAccuracy = sessionData.accuracyAtSessionEnd;
        const totalAttempts = sessionData.sessionAcertos + sessionData.sessionErros;

        // S√≥ considera sess√µes com pelo menos 5 tentativas para entrar no ranking
        if (totalAttempts < 5) {
            console.log("Sess√£o muito curta para ranking.");
            return;
        }

        // Cria um objeto de pontua√ß√£o para o ranking
        const newScore = {
            date: sessionData.timestamp,
            accuracy: parseFloat(sessionAccuracy.toFixed(1)),
            durationMs: sessionData.durationMs,
            totalAttempts: totalAttempts
        };

        // Adiciona a nova pontua√ß√£o e mant√©m o array ordenado e limitado
        topScores.push(newScore);
        topScores.sort((a, b) => b.accuracy - a.accuracy || b.durationMs - a.durationMs); // Ordena por precis√£o (maior primeiro), depois por dura√ß√£o (maior primeiro)
        topScores = topScores.slice(0, MAX_TOP_SCORES); // Mant√©m apenas o top N

        saveTopScores();
        displayTopScores();
        document.getElementById("result").textContent += " (Nova pontua√ß√£o adicionada ao ranking!)";
        document.getElementById("result").style.color = "purple";
    }

    // Exibe o ranking na interface
    function displayTopScores() {
        const list = document.getElementById("topScoresList");
        list.innerHTML = ""; // Limpa a lista existente

        if (topScores.length === 0) {
            const listItem = document.createElement("li");
            listItem.textContent = "Nenhuma pontua√ß√£o no ranking ainda. Fa√ßa uma sess√£o para come√ßar!";
            list.appendChild(listItem);
            return;
        }

        topScores.forEach((score, index) => {
            const listItem = document.createElement("li");
            listItem.classList.add("top-score-item");

            const date = new Date(score.date);
            const dateString = date.toLocaleDateString('pt-BR', {
                year: 'numeric', month: 'numeric', day: 'numeric'
            });
            const timeString = date.toLocaleTimeString('pt-BR', {
                hour: '2-digit', minute: '2-digit'
            });

            listItem.innerHTML = `
                <span>#${index + 1}: ${score.accuracy}%</span>
                <span class="score-details">
                    (${score.totalAttempts} tentativas em ${formatDuration(score.durationMs)}) - ${dateString} ${timeString}
                </span>
            `;
            list.appendChild(listItem);
        });
    }

    // Limpa o ranking local
    function clearTopScores() {
        if (confirm("Tem certeza que deseja limpar todo o ranking de melhores pontua√ß√µes? Esta a√ß√£o n√£o pode ser desfeita.")) {
            topScores = [];
            saveTopScores();
            displayTopScores();
            document.getElementById("result").textContent = "Ranking limpo.";
            document.getElementById("result").style.color = "blue";
        }
    }


    // Listener para as teclas do teclado
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();

      if (e.key === "Enter") {
        e.preventDefault(); // Evita que a tecla Enter ative outros bot√µes
        repeatNote_Enter(); // Chama a fun√ß√£o que mostra o nome da nota
        return;
      }
      if (e.key === " ") {
        e.preventDefault(); // Evita que a barra de espa√ßo role a p√°gina
        playNote();
        return;
      }
      // Tecla 'R' para repetir a nota (n√£o conta no contador, n√£o mostra nome)
      if (key === "r") {
        e.preventDefault(); 
        repeatNote_R(); // Chama a fun√ß√£o que apenas toca a nota
        return;
      }

      // Usa o keyToNoteMap para encontrar a nota base correspondente √† tecla pressionada
      const pressedNoteBase = keyToNoteMap[key];
      if (pressedNoteBase) { // Se a tecla pressionada est√° no nosso mapeamento fixo
        const fullPressedNote = pressedNoteBase + currentOctave; // Cria a nota completa com a oitava atual

        let availableNotesForInputCheck = [];

        if (focusModeActive) {
            // No modo foco, as notas v√°lidas para input s√£o as que o usu√°rio SELECIONOU
            // dentro da se√ß√£o de "Sele√ß√£o de Notas no Modo Foco".
            // N√£o importa se elas se qualificam ou n√£o, o usu√°rio j√° as selecionou.
            availableNotesForInputCheck = [...selectedFocusNotes];

            // Se o usu√°rio tamb√©m selecionou notas para estudo no modo geral,
            // o modo foco atua como um filtro SOBRE essas notas selecionadas
            if (selectedNotesForStudy.length > 0) {
                availableNotesForInputCheck = availableNotesForInputCheck.filter(note => selectedNotesForStudy.includes(note));
            }

            if (availableNotesForInputCheck.length === 0) {
                // Se o modo foco est√° ativo mas nenhuma nota foi selecionada (ou as selecionadas n√£o est√£o nas gerais),
                // o input da tecla n√£o deve ser processado como resposta.
                return; 
            }
        } else if (selectedNotesForStudy.length > 0) {
            // Se h√° notas selecionadas para estudo, o input √© limitado a elas
            availableNotesForInputCheck = [...selectedNotesForStudy];
        } else {
            // Se n√£o h√° notas selecionadas para estudo, usa as notas do n√≠vel atual da sequ√™ncia
            availableNotesForInputCheck = noteSequenceForLevel.slice(0, currentLevel);
        }
        
        if (availableNotesForInputCheck.includes(pressedNoteBase)) {
            checkAnswer(fullPressedNote); // Passa a nota completa para a checagem
        }
      }
    });

    // --- Inicializa√ß√£o do aplicativo ---
    // A ordem de carregamento √© importante aqui
    loadSettings(); // Carrega todas as configura√ß√µes salvas PRIMEIRO (instrumento, oitava, sequenceType, autoplay, feedback, selectedNotes, volume feedback, foco)
    generateNoteSelectionCheckboxes(); // Gera os checkboxes de sele√ß√£o de notas e os marca com base em selectedNotesForStudy carregado
    updateSelectedNotes(); // Garante que `selectedNotesForStudy` esteja populado e a l√≥gica de n√≠vel seja resetada se necess√°rio
    updateDisplayNames();
    loadTrainingLevel(); // Carrega o n√≠vel de treino salvo
    noteSequenceForLevel = generateNoteSequenceBase(); // Gera a sequ√™ncia inicial de notas base (aleat√≥ria por padr√£o)
    updateButtons();
    updateStats();
    loadTotalTrainingDuration(); // Carrega o tempo total de treino ao iniciar o app
    loadNoteStats(); // Carrega as estat√≠sticas por nota ao iniciar o app
    updateFocusModeNoteSelection(); // Gera os checkboxes das notas fracas com base nas estat√≠sticas carregadas
    loadSessionHistory(); // Carrega o hist√≥rico de sess√µes ao iniciar o app
    loadGoals(); // Carrega as metas ao iniciar o app
    loadTopScores(); // Carrega o ranking ao iniciar o app

    // Listener para salvar o tempo e o hist√≥rico ao fechar a p√°gina (garante que o tempo da sess√£o ativa seja salvo)
    window.addEventListener('beforeunload', () => {
        if (sessionStartTime) { // Se houver uma sess√£o ativa
            const sessionDuration = Date.now() - sessionStartTime;
            totalTrainingDuration += sessionDuration;

            // Registra a sess√£o no hist√≥rico antes de fechar
            const sessionData = {
                timestamp: new Date().toISOString(),
                durationMs: sessionDuration,
                sessionAcertos: currentSessionAcertos,
                sessionErros: currentSessionErros,
                focusMode: focusModeActive,
                focusedNotes: focusModeActive ? getNotesForFocusMode().filter(n => selectedFocusNotes.includes(n.noteBase)).map(n => n.noteBase) : [],
                accuracyAtSessionEnd: total > 0 ? ((acertos / total) * 100) : 0,
                sessionTotalNotes: currentSessionTotalNotes
            };
            sessionHistory.push(sessionData);
            // Tamb√©m adiciona ao ranking ao fechar a p√°gina, se a sess√£o foi relevante
            addSessionToTopScores(sessionData); // Garante que a sess√£o em andamento seja registrada no ranking
        }
        saveTotalTrainingDuration();
        saveNoteStats(); // Garante que as estat√≠sticas por nota tamb√©m sejam salvas
        saveSessionHistory(); // Garante que o hist√≥rico de sess√µes seja salvo
        saveTrainingLevel(); // Salva o n√≠vel de treino ao fechar
        saveTopScores(); // Garante que o ranking seja salvo ao fechar
        // As metas s√£o salvas ao serem definidas, n√£o ao fechar
    });
  </script>
</body>
</html>
