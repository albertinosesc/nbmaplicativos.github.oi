<!DOCTYPE html> 
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Editor ABC - Est√∫dio Completo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<script src="https://cdn.jsdelivr.net/npm/abcjs@6.5.2/dist/abcjs-basic-min.js"></script>

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { 
    height: 100vh; 
    font-family: 'Segoe UI', Arial, sans-serif; 
    overflow: hidden; 
    background: #f4f4f4;
  }
  
  .header { 
    height: 55px; 
    background: #fff; 
    border-bottom: 1px solid #ccc; 
    display: flex; 
    align-items: center; 
    padding: 0 15px; 
    gap: 8px;
    flex-wrap: wrap;
    min-height: 55px;
    max-height: 75px;
    overflow: visible;
    z-index: 1000;
    position: relative;
  }
  
  .header-btn { 
    padding: 8px 12px; 
    font-size: 13px; 
    cursor: pointer; 
    background: #fff; 
    border: 1px solid #ccc; 
    border-radius: 6px; 
    font-weight: 500; 
    display: flex; 
    align-items: center; 
    gap: 4px; 
    white-space: nowrap;
    flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }
  
  .header-btn:active {
    background-color: #f0f0f0;
  }
  
  .btn-save { background: #22c55e !important; color: white !important; border: none !important; }
  .btn-tuner { background: #6366f1 !important; color: white !important; border: none !important; }
  .btn-train { background: #f97316 !important; color: white !important; border: none !important; }
  
  #playBtn { 
    background: #28a745; 
    color: white; 
    border: none; 
    min-width: 70px; 
    justify-content: center;
    padding: 8px 12px;
  }
  
  #playBtn.playing { background: #dc3545; }
  
  #metronomeVisual { 
    width: 10px; 
    height: 10px; 
    border-radius: 50%; 
    background: #ccc; 
    transition: background 0.1s; 
    margin-left: 3px; 
  }
  
  .metronome-active { background: #2196f3 !important; transform: scale(1.2); }
  
  .control-group { 
    display: flex; 
    align-items: center; 
    gap: 5px; 
    background: #f8f9fa; 
    padding: 6px 10px; 
    border-radius: 20px; 
    border: 1px solid #dee2e6; 
    font-size: 12px; 
    white-space: nowrap;
    flex-shrink: 0;
  }
  
  .control-group button { 
    border: none; 
    background: none; 
    cursor: pointer; 
    font-weight: bold; 
    padding: 2px 6px; 
    font-size: 12px;
    min-width: 24px;
    min-height: 24px;
  }

  .header-main-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
    min-width: 0;
    overflow: visible;
    flex-wrap: wrap;
  }

  .header-right-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: auto;
    flex-shrink: 0;
  }

  .bpm-input {
    width: 45px !important;
    border: none !important;
    background: transparent !important;
    font-weight: bold !important;
    color: #2196f3 !important;
    outline: none !important;
    text-align: center !important;
    font-size: 12px !important;
    padding: 4px !important;
  }

  .zoom-control {
    font-size: 12px;
  }

  .metro-control-group {
    display: flex;
    align-items: center;
    gap: 5px;
    background: #f8f9fa;
    padding: 6px 10px;
    border-radius: 20px;
    border: 1px solid #dee2e6;
    font-size: 12px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .metro-toggle-btn {
    border: none;
    background: none;
    cursor: pointer;
    font-weight: bold;
    padding: 2px 6px;
    display: flex;
    align-items: center;
    gap: 3px;
    font-size: 12px;
  }

  .metro-visual {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #ccc;
    margin-left: 2px;
    display: inline-block;
  }

  .metro-indicator {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    font-size: 11px;
    color: #666;
    margin-left: 3px;
  }

  .metro-time-signature {
    font-size: 11px;
    color: #666;
    margin-left: 3px;
    font-weight: bold;
    background: #f8f9fa;
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid #dee2e6;
  }

  .metro-volume-container {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 5px;
  }

  .metro-volume-slider {
    width: 60px;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: #e9ecef;
    border-radius: 3px;
    outline: none;
  }

  .metro-volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #ef4444;
    cursor: pointer;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }

  .metro-volume-value {
    font-size: 11px;
    color: #666;
    min-width: 28px;
    text-align: center;
    font-weight: bold;
  }

  #musicInfoTag {
    font-size: 11px;
    color: #666;
    font-weight: bold;
    margin-left: 5px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
  }

  .app-container { 
    display: flex; 
    height: calc(100vh - 55px); 
    width: 100%; 
    overflow: hidden; 
    position: relative; 
  }
  
  .sidebar, .editor-container, .score-container {
    flex-shrink: 0;
    transition: all 0.3s ease;
    height: 100%;
    overflow: hidden;
    position: relative;
  }
  
  .sidebar { 
    width: 300px; 
    background: #fff; 
    border-right: 1px solid #ccc; 
    overflow-y: auto; 
    padding: 10px; 
  }
  
  .sidebar.hidden, 
  .editor-container.hidden, 
  .score-container.hidden {
    min-width: 0 !important;
    max-width: 0 !important;
    width: 0 !important;
    padding: 0 !important;
    margin: 0 !important;
    border: none !important;
    opacity: 0;
    visibility: hidden;
    flex: 0 !important;
  }
  
  .editor-container { 
    width: 400px; 
    padding: 10px; 
    display: flex; 
    flex-direction: column; 
    background: #fff; 
    border-right: 1px solid #ccc; 
  }
  
  textarea { 
    width: 100%; 
    height: 100%; 
    font-family: 'Courier New', monospace; 
    font-size: 15px; 
    padding: 15px; 
    border: 1px solid #ddd; 
    border-radius: 4px; 
    resize: none; 
    outline: none; 
  }
  
  .score-container { 
    flex: 1 1 auto; 
    min-width: 300px; 
    padding: 10px; 
    overflow: hidden; 
    display: flex; 
    flex-direction: column; 
  }
  
  .score-container.hidden {
    flex: 0 !important;
  }
  
  #paper-container { 
    flex: 1; 
    overflow: auto !important; 
    background: white; 
    border: 1px solid #ccc; 
    border-radius: 8px;
    height: 100%;
  }

  #paper { 
    padding: 10px; 
    display: block;
    width: 100%;
    height: auto !important;
  }

  #paper svg {
    display: block;
    max-width: none !important; 
  }

  /* DIVISORES ARRAST√ÅVEIS - VERS√ÉO CORRIGIDA */
  .resize-handle {
    position: absolute;
    top: 0;
    right: -10px; /* √Årea maior para touch */
    width: 20px; /* Mais largo para touch */
    height: 100%;
    cursor: col-resize;
    z-index: 100;
    background: transparent;
    touch-action: none;
  }
  
  .resize-handle.resizing {
    background-color: rgba(59, 130, 246, 0.3);
  }
  
  .resize-handle::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 4px; /* Mais grosso */
    height: 50px; /* Mais longo */
    background: #ccc;
    border-radius: 2px;
    transition: all 0.2s;
  }
  
  .resize-handle:hover::after, 
  .resize-handle.resizing::after,
  .resize-handle.touch-active::after {
    background: #3b82f6;
    width: 6px;
  }
  
  /* Overlay durante redimensionamento (apenas para visual) */
  .resize-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    z-index: 999;
    display: none;
  }
  
  .resize-overlay.active {
    display: block;
  }
  
  .size-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 3px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: bold;
    display: none;
    z-index: 101;
  }
  
  .resize-handle:hover .size-indicator,
  .resize-handle.resizing .size-indicator {
    display: block;
  }

  .modal-overlay { 
    display: none; 
    position: fixed; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background: rgba(0,0,0,0.6); 
    z-index: 2000; 
    align-items: center; 
    justify-content: center; 
  }
  
  .modal-content { 
    background: white; 
    padding: 25px; 
    border-radius: 15px; 
    width: 380px; 
    max-width: 90vw;
    text-align: center; 
  }
  
  .modal-content.train { width: 420px; max-width: 95vw; }
  
  .tuner-grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 12px; 
    margin-bottom: 20px; 
  }
  
  .instrument-btn { 
    padding: 15px; 
    border: 1px solid #ddd; 
    border-radius: 10px; 
    cursor: pointer; 
    background: #fdfdfd; 
    font-weight: 600; 
    font-size: 14px;
  }
  
  .notes-container { 
    display: flex; 
    justify-content: center; 
    gap: 8px; 
    margin-top: 15px; 
    flex-wrap: wrap; 
    border-top: 1px solid #eee; 
    padding-top: 20px; 
  }
  
  .note-btn { 
    width: 50px; 
    height: 50px; 
    border-radius: 50%; 
    border: 2px solid #6366f1; 
    background: white; 
    color: #6366f3; 
    cursor: pointer; 
    font-weight: bold; 
    font-size: 14px;
  }
  
  .note-btn.active { background: #6366f1; color: white; }
  
  .btn-stop-tuner { 
    width: 100%; 
    margin-top: 20px; 
    padding: 15px; 
    background: #ff4757; 
    color: white; 
    border: none; 
    border-radius: 8px; 
    font-weight: bold; 
    cursor: pointer; 
    font-size: 16px;
  }

  .training-panel { 
    position: fixed; 
    top: 70px; 
    right: 20px; 
    background: white; 
    border-radius: 12px; 
    padding: 15px; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.15); 
    width: 320px; 
    max-width: 90vw;
    z-index: 1500; 
    display: none;
    transition: all 0.3s ease;
    max-height: 400px;
    overflow: hidden;
  }
  
  .training-panel.active { display: block; }
  .training-panel.minimized { 
    width: 220px; 
    height: auto; 
    max-height: 80px;
    padding: 10px;
  }
  
  .training-header { 
    font-size: 16px; 
    font-weight: bold; 
    margin-bottom: 15px; 
    color: #f97316; 
    display: flex; 
    align-items: center; 
    justify-content: space-between;
  }
  
  .training-header.minimized {
    margin-bottom: 0;
  }
  
  .minimize-btn {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #666;
    padding: 2px 8px;
    border-radius: 4px;
  }
  
  .training-stats { 
    background: #f8f9fa; 
    padding: 12px; 
    border-radius: 8px; 
    margin-bottom: 15px; 
    transition: all 0.3s ease;
  }
  
  .training-panel.minimized .training-stats,
  .training-panel.minimized .training-controls,
  .training-panel.minimized .progress-bar {
    display: none;
  }
  
  .training-mini-stats {
    display: none;
    font-size: 13px;
    color: #666;
    margin-top: 5px;
  }
  
  .training-panel.minimized .training-mini-stats {
    display: block;
  }
  
  .stat-row { 
    display: flex; 
    justify-content: space-between; 
    margin-bottom: 6px; 
    font-size: 14px; 
  }
  
  .stat-value { font-weight: bold; color: #f97316; }
  
  .training-controls { 
    display: flex; 
    gap: 10px; 
    margin-bottom: 15px;
    transition: all 0.3s ease;
  }
  
  .training-btn { 
    flex: 1; 
    padding: 12px; 
    border: none; 
    border-radius: 8px; 
    font-weight: bold; 
    cursor: pointer; 
    font-size: 14px;
  }
  
  .btn-pause { background: #f97316; color: white; }
  .btn-stop { background: #dc3545; color: white; }
  
  .progress-bar { 
    height: 8px; 
    background: #e9ecef; 
    border-radius: 4px; 
    overflow: hidden; 
    margin-top: 15px; 
    transition: all 0.3s ease;
  }

  .progress-fill { 
    height: 100%; 
    background: #22c55e; 
    width: 0%; 
    transition: width 0.3s; 
  }

  .form-group { margin-bottom: 15px; text-align: left; }
  .form-label { display: block; margin-bottom: 5px; font-size: 14px; font-weight: 600; color: #333; }
  .form-input { 
    width: 100%; 
    padding: 12px; 
    border: 1px solid #ddd; 
    border-radius: 8px; 
    font-size: 16px;
  }
  .form-row { display: flex; gap: 10px; }
  .form-row .form-group { flex: 1; }

  .file-container { margin-bottom: 8px; border-radius: 6px; overflow: hidden; border: 1px solid #eee; background: white; }
  .file-header { 
    padding: 15px; 
    background: #fafafa; 
    cursor: pointer; 
    font-size: 14px; 
    font-weight: 600; 
    display: flex; 
    justify-content: space-between; 
  }
  .music-list { display: none; background: #fff; }
  .music-list.show { display: block; }
  .music-item { 
    padding: 12px 15px; 
    font-size: 13px; 
    cursor: pointer; 
    border-bottom: 1px solid #f9f9f9; 
  }
  
  /* Estilos para touch */
  @media (hover: none) and (pointer: coarse) {
    .resize-handle {
      width: 30px;
      right: -15px;
    }
    
    .resize-handle::after {
      width: 6px;
      height: 60px;
    }
  }
</style>
</head>
<body>

<div class="header">
  <div class="header-main-controls">
    <button class="header-btn" onclick="toggleSidebar()">üìÅ Biblioteca</button>
    <button class="header-btn" onclick="toggleEditor()">‚úèÔ∏è Editor</button>
    
    <button class="header-btn btn-save" onclick="salvarArquivoLocal()">üíæ Salvar</button>
    <button class="header-btn btn-tuner" onclick="openTuner()">üé∏ Afinador</button>
    <button class="header-btn btn-train" onclick="openTrainingConfig()">üèãÔ∏è Treino</button>
    
    <div style="width: 1px; height: 25px; background: #ddd; margin: 0 5px;"></div>
    
    <div class="control-group"> 
      Tom: 
      <button onclick="changeTranspose(-1)">-</button>
      <span id="transposeLabel">0</span>
      <button onclick="changeTranspose(1)">+</button>
    </div>
    
    <button id="playBtn" class="header-btn" onclick="togglePlay()">
      <span id="playIcon">‚ñ∂</span> 
      <span id="playText">Tocar</span>
    </button>
    
    <div class="control-group"> 
      BPM: 
      <input type="number" id="bpmValue" class="bpm-input" value="100" min="40" max="300">
      <div id="metronomeVisual"></div>
    </div>
    
    <div class="control-group zoom-control"> 
      Zoom: 
      <button onclick="changeZoom(-10)">-</button>
      <span id="zoomLabel">100%</span>
      <button onclick="changeZoom(10)">+</button>
    </div>

    <div class="metro-control-group">
      <button id="metroToggleBtn" class="metro-toggle-btn" onclick="toggleSimpleMetronome()">
        <span id="metroIcon">ü•Å</span>
        <span id="metroText">Metr√¥nomo</span>
      </button>
      <div id="metroVisual" class="metro-visual"></div>
      <div class="metro-indicator" id="metroStatusIndicator">
        <span id="metroStatusText">OFF</span>
      </div>
      <div class="metro-time-signature" id="metroTimeSigDisplay">4/4</div>
      
      <div class="metro-volume-container">
        <span style="font-size: 11px; color: #666;">üîä</span>
        <input type="range" id="metroVolumeSlider" class="metro-volume-slider" min="0" max="100" value="50">
        <span id="metroVolumeValue" class="metro-volume-value">50%</span>
      </div>
    </div>

    <div id="musicInfoTag" title="Informa√ß√µes da m√∫sica"></div>
  </div>

  <div class="header-right-controls">
    <button class="header-btn" onclick="selectFolder()" style="background: #e3f2fd; color: #2196f3; font-size: 12px; padding: 6px 10px;">
      üìÇ Abrir
    </button>
    <button class="header-btn" onclick="resetLayout()" style="background: #f8f9fa; color: #666; font-size: 12px; padding: 6px 10px;">
      üîÑ Layout
    </button>
  </div>
</div>

<!-- Modal Afinador -->
<div id="tunerModal" class="modal-overlay">
  <div class="modal-content">
    <h3>Afinador Cello Infinito</h3>
    <div class="tuner-grid">
      <div class="instrument-btn" onclick="showTunerNotes('violao')">üé∏ Viol√£o</div>
      <div class="instrument-btn" onclick="showTunerNotes('violino')">üéª Violino</div>
      <div class="instrument-btn" onclick="showTunerNotes('cavaquinho')">ü™ï Cavaco</div>
      <div class="instrument-btn" onclick="showTunerNotes('ukulele')">üå¥ Ukulele</div>
    </div>
    <div id="tunerNotesArea" class="notes-container" style="display:none;"></div>
    <button class="btn-stop-tuner" onclick="stopTunerAudio()">‚èπ PARAR SOM</button>
    <p onclick="closeTuner()" style="margin-top:15px; cursor:pointer; font-size:14px; color:#666">Fechar</p>
  </div>
</div>

<!-- Modal Configura√ß√£o de Treino -->
<div id="trainingModal" class="modal-overlay">
  <div class="modal-content train">
    <h3>üèãÔ∏è Configurar Treino</h3>
    <div class="form-group">
      <label class="form-label">BPM Inicial:</label>
      <input type="number" id="trainStartBpm" class="form-input" value="60" min="40" max="200">
    </div>
    <div class="form-group">
      <label class="form-label">BPM Final:</label>
      <input type="number" id="trainEndBpm" class="form-input" value="120" min="50" max="300">
    </div>
    <div class="form-row">
      <div class="form-group">
        <label class="form-label">Incremento:</label>
        <input type="number" id="trainIncrement" class="form-input" value="5" min="1" max="20">
      </div>
      <div class="form-group">
        <label class="form-label">Repeti√ß√µes por BPM:</label>
        <input type="number" id="trainRepetitions" class="form-input" value="3" min="1" max="10">
      </div>
    </div>
    <div class="form-group">
      <label class="form-label">Intervalo entre repeti√ß√µes (segundos):</label>
      <input type="number" id="trainInterval" class="form-input" value="1" min="0" max="10" step="0.1">
    </div>
    <div class="form-group">
      <label class="form-label" style="display: flex; align-items: center; gap: 5px;">
        <input type="checkbox" id="trainMetronomeDuringInterval" checked>
        Metr√¥nomo durante intervalo
      </label>
    </div>
    <button class="btn-stop-tuner" onclick="startTraining()" style="background: #22c55e;">‚ñ∂ INICIAR TREINO</button>
    <p onclick="closeTrainingModal()" style="margin-top:15px; cursor:pointer; font-size:14px; color:#666">Cancelar</p>
  </div>
</div>

<!-- Painel de Controle de Treino -->
<div id="trainingPanel" class="training-panel">
  <div class="training-header">
    <span>üèãÔ∏è TREINO ATIVO</span>
    <button class="minimize-btn" id="minimizeTrainBtn" onclick="toggleTrainingPanelMinimize()">‚àí</button>
  </div>
  <div class="training-mini-stats">
    <span id="miniTrainBpm">BPM: 60</span> ‚Ä¢ 
    <span id="miniTrainRep">Rep: 1/3</span> ‚Ä¢ 
    <span id="miniTrainStatus">Tocando...</span>
  </div>
  <div class="training-stats">
    <div class="stat-row">
      <span>BPM Atual:</span>
      <span id="currentTrainBpm" class="stat-value">60</span>
    </div>
    <div class="stat-row">
      <span>Repeti√ß√£o:</span>
      <span id="currentRepetition" class="stat-value">1/3</span>
    </div>
    <div class="stat-row">
      <span>Progresso:</span>
      <span id="trainProgress" class="stat-value">0%</span>
    </div>
    <div class="stat-row">
      <span>Status:</span>
      <span id="trainStatus" class="stat-value">Tocando...</span>
    </div>
  </div>
  <div class="training-controls">
    <button class="training-btn btn-pause" onclick="toggleTrainingPause()">‚è∏ Pausar</button>
    <button class="training-btn btn-stop" onclick="stopTraining()">‚èπ Parar</button>
  </div>
  <div class="progress-bar">
    <div class="progress-fill" id="trainProgressBar"></div>
  </div>
</div>

<!-- Overlay para redimensionamento -->
<div class="resize-overlay" id="resizeOverlay"></div>

<div class="app-container">
  <div class="sidebar" id="sidebar">
    <div id="libraryStatus" style="font-size: 12px; margin-bottom: 10px; color: #999;">Carregando...</div>
    <div id="fileContainerList"></div>
    <div class="resize-handle" id="sidebarResize">
      <div class="size-indicator" id="sidebarSize">300px</div>
    </div>
  </div>
  <div class="editor-container" id="editorContainer"><textarea id="abcInput" spellcheck="false">X:1
T:Novo Estudo
Q:1/4=100
M:4/4
L:1/4
K:C
C D E F | G A B c |]</textarea>
    <div class="resize-handle" id="editorResize">
      <div class="size-indicator" id="editorSize">400px</div>
    </div>
  </div>
  <div class="score-container" id="scoreContainer"><div id="paper-container"><div id="paper"></div></div>
    <div class="resize-handle" id="scoreResize">
      <div class="size-indicator" id="scoreSize">flex√≠vel</div>
    </div>
  </div>
</div>


<script>
let visualObj = null, synthControl = null, audioContext = null;
let currentTranspose = 0, currentZoom = 100, metroInterval = null, isPlaying = false;
let currentFileHandle = null, fileLibrary = [];

// --- VARI√ÅVEIS DE TREINO ---
let trainingActive = false;
let trainingPaused = false;
let trainingConfig = {
  startBpm: 60,
  endBpm: 120,
  increment: 5,
  repetitions: 3,
  interval: 1,
  currentBpm: 60,
  currentRepetition: 1,
  currentCycle: 1,
  metronomeDuringInterval: true
};
let trainingTimeout = null;
let intervalMetronomeInterval = null;
let musicDurationMs = 0;

// --- VARI√ÅVEIS DE REDIMENSIONAMENTO ---
let sidebarWidth = 300;
let editorWidth = 400;
let isResizing = false;
let currentResizeHandle = null;
let startX = 0;
let startWidth = 0;

/* --- METR√îNOMO SIMPLES --- */
let metroAudioContext = null;
let metroOscillator = null;
let metroGainNode = null;
let metroFilter = null;
let metroSimpleInterval = null;
let metroIsPlaying = false;
let metroCurrentBeat = 0;
let metroBeatsPerMeasure = 4;
let metroVolume = 0.5;

// Fun√ß√£o para extrair o compasso (M:) do c√≥digo ABC
function extractTimeSignature() {
  const abcText = document.getElementById('abcInput').value;
  const lines = abcText.split('\n');
  
  // Procura pela linha M: (compasso)
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('M:')) {
      const timeSig = trimmed.substring(2).trim();
      
      // Converte diferentes formatos de compasso para n√∫mero de beats
      if (timeSig === '4/4' || timeSig === 'C' || timeSig === 'C|') {
        metroBeatsPerMeasure = 4;
        return '4/4';
      } else if (timeSig === '3/4') {
        metroBeatsPerMeasure = 3;
        return '3/4';
      } else if (timeSig === '2/4') {
        metroBeatsPerMeasure = 2;
        return '2/4';
      } else if (timeSig === '6/8') {
        metroBeatsPerMeasure = 2; // 6/8 tem 2 batidas fortes
        return '6/8';
      } else if (timeSig === '2/2' || timeSig === 'C|') {
        metroBeatsPerMeasure = 2;
        return '2/2';
      } else if (timeSig === '3/8') {
        metroBeatsPerMeasure = 1; // 3/8 tem 1 batida forte
        return '3/8';
      } else {
        // Tenta extrair numerador do formato X/Y
        const match = timeSig.match(/(\d+)\/(\d+)/);
        if (match) {
          const numerator = parseInt(match[1]);
          const denominator = parseInt(match[2]);
          
          // Para compassos simples, beats = numerador
          // Para compassos compostos (denominador 8 e numerador m√∫ltiplo de 3), beats = numerador / 3
          if (denominator === 8 && numerator % 3 === 0) {
            metroBeatsPerMeasure = numerator / 3;
          } else {
            metroBeatsPerMeasure = numerator;
          }
          return timeSig;
        }
      }
    }
  }
  
  // Compasso padr√£o se n√£o encontrar
  metroBeatsPerMeasure = 4;
  return '4/4';
}

// Atualizar display do compasso
function updateTimeSignatureDisplay() {
  const timeSig = extractTimeSignature();
  document.getElementById('metroTimeSigDisplay').textContent = timeSig;
}

// Toggle do metr√¥nomo simples
function toggleSimpleMetronome() {
  if (metroIsPlaying) {
    stopSimpleMetronome();
  } else {
    startSimpleMetronome();
  }
}

// Iniciar metr√¥nomo simples
function startSimpleMetronome() {
  if (metroIsPlaying) return;
  
  // Atualizar compasso baseado no c√≥digo ABC
  updateTimeSignatureDisplay();
  
  // Obter BPM atual da m√∫sica
  const bpm = parseInt(document.getElementById('bpmValue').value);
  
  // Obter volume do slider
  const volumeSlider = document.getElementById('metroVolumeSlider');
  metroVolume = volumeSlider ? parseInt(volumeSlider.value) / 100 : 0.5;
  
  // Inicializar AudioContext se necess√°rio
  if (!metroAudioContext) {
    metroAudioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  // Criar n√≥s de √°udio
  metroOscillator = metroAudioContext.createOscillator();
  metroGainNode = metroAudioContext.createGain();
  metroFilter = metroAudioContext.createBiquadFilter();
  
  // Configurar filtro (som mais agrad√°vel)
  metroFilter.type = 'lowpass';
  metroFilter.frequency.setValueAtTime(800, metroAudioContext.currentTime);
  
  // Conectar n√≥s
  metroOscillator.connect(metroFilter);
  metroFilter.connect(metroGainNode);
  metroGainNode.connect(metroAudioContext.destination);
  
  // Configurar oscilador
  metroOscillator.type = 'sine';
  
  // Configurar ganho (volume)
  metroGainNode.gain.setValueAtTime(0, metroAudioContext.currentTime);
  
  // Iniciar oscilador
  metroOscillator.start();
  
  // Iniciar intervalo
  const msPerBeat = 60000 / bpm;
  metroCurrentBeat = 0;
  metroIsPlaying = true;
  
  // Atualizar UI
  updateMetroUI();
  
  // Tocar primeiro beat imediatamente
  playMetroClick();
  
  // Configurar intervalo
  metroSimpleInterval = setInterval(() => {
    if (metroIsPlaying) {
      metroCurrentBeat = (metroCurrentBeat + 1) % metroBeatsPerMeasure;
      playMetroClick();
    }
  }, msPerBeat);
}

// Tocar clique do metr√¥nomo
function playMetroClick() {
  if (!metroAudioContext || !metroIsPlaying) return;
  
  // Determinar frequ√™ncia baseado no beat
  let frequency = 800; // Hz para beats normais
  let duration = 0.05; // segundos
  
  if (metroCurrentBeat === 0) {
    // Beat forte (primeiro tempo)
    frequency = 1200;
    duration = 0.08;
  }
  
  // Atualizar oscilador
  metroOscillator.frequency.setValueAtTime(frequency, metroAudioContext.currentTime);
  
  // Envelope ADSR r√°pido
  const now = metroAudioContext.currentTime;
  metroGainNode.gain.cancelScheduledValues(now);
  metroGainNode.gain.setValueAtTime(0, now);
  metroGainNode.gain.linearRampToValueAtTime(metroVolume * 0.3, now + 0.001);
  metroGainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
  
  // Atualizar indicador visual
  updateMetroVisual();
}

// Atualizar UI do metr√¥nomo
function updateMetroUI() {
  const metroIcon = document.getElementById('metroIcon');
  const metroText = document.getElementById('metroText');
  const metroStatusText = document.getElementById('metroStatusText');
  const metroStatusIndicator = document.getElementById('metroStatusIndicator');
  const metroVisual = document.getElementById('metroVisual');
  
  if (metroIsPlaying) {
    metroIcon.textContent = "‚èπ";
    metroText.textContent = "Parar";
    metroStatusText.textContent = "ON";
    metroStatusIndicator.classList.add('active');
    if (metroVisual) metroVisual.style.background = "#ef4444";
  } else {
    metroIcon.textContent = "ü•Å";
    metroText.textContent = "Metr√¥nomo";
    metroStatusText.textContent = "OFF";
    metroStatusIndicator.classList.remove('active');
    if (metroVisual) metroVisual.style.background = "#ccc";
  }
}

// Atualizar indicador visual
function updateMetroVisual() {
  const visual = document.getElementById('metroVisual');
  if (visual) {
    visual.classList.remove('active');
    void visual.offsetWidth; // Trigger reflow
    visual.classList.add('active');
  }
}

// Parar metr√¥nomo simples
function stopSimpleMetronome() {
  if (!metroIsPlaying) return;
  
  // Parar intervalo
  if (metroSimpleInterval) {
    clearInterval(metroSimpleInterval);
    metroSimpleInterval = null;
  }
  
  // Parar √°udio
  if (metroOscillator) {
    try {
      const now = metroAudioContext.currentTime;
      metroGainNode.gain.cancelScheduledValues(now);
      metroGainNode.gain.setValueAtTime(metroGainNode.gain.value, now);
      metroGainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      setTimeout(() => {
        if (metroOscillator) {
          metroOscillator.stop();
          metroOscillator.disconnect();
        }
      }, 100);
    } catch (e) {
      console.error("Erro ao parar metr√¥nomo:", e);
    }
    metroOscillator = null;
  }
  
  // Resetar estado
  metroIsPlaying = false;
  metroCurrentBeat = 0;
  
  // Atualizar UI
  updateMetroUI();
}

// Sincronizar metr√¥nomo com BPM quando mudar
function syncMetroWithBPM() {
  if (metroIsPlaying) {
    stopSimpleMetronome();
    setTimeout(startSimpleMetronome, 100);
  }
}

// Atualizar volume do metr√¥nomo
function updateMetroVolume() {
  const volumeSlider = document.getElementById('metroVolumeSlider');
  const volumeValue = document.getElementById('metroVolumeValue');
  
  if (volumeSlider && volumeValue) {
    const value = volumeSlider.value;
    volumeValue.textContent = value + '%';
    metroVolume = value / 100;
  }
}

// Evento para quando o c√≥digo ABC mudar (para detectar mudan√ßa de compasso)
function onAbcInputChange() {
  updateTimeSignatureDisplay();
  if (metroIsPlaying) {
    // Reiniciar metr√¥nomo com novo compasso
    stopSimpleMetronome();
    setTimeout(startSimpleMetronome, 100);
  }
}

/* --- SISTEMA DE TREINO MELHORADO --- */
function openTrainingConfig() {
  document.getElementById('trainingModal').style.display = 'flex';
}

function closeTrainingModal() {
  document.getElementById('trainingModal').style.display = 'none';
}

// Minimizar/Maximizar painel de treino
function toggleTrainingPanelMinimize() {
  const panel = document.getElementById('trainingPanel');
  const minimizeBtn = document.getElementById('minimizeTrainBtn');
  
  panel.classList.toggle('minimized');
  
  if (panel.classList.contains('minimized')) {
    minimizeBtn.textContent = "+";
    minimizeBtn.title = "Maximizar";
  } else {
    minimizeBtn.textContent = "‚àí";
    minimizeBtn.title = "Minimizar";
  }
}

// Iniciar treino
async function startTraining() {
  trainingConfig.startBpm = parseInt(document.getElementById('trainStartBpm').value);
  trainingConfig.endBpm = parseInt(document.getElementById('trainEndBpm').value);
  trainingConfig.increment = parseInt(document.getElementById('trainIncrement').value);
  trainingConfig.repetitions = parseInt(document.getElementById('trainRepetitions').value);
  trainingConfig.interval = parseFloat(document.getElementById('trainInterval').value);
  trainingConfig.metronomeDuringInterval = document.getElementById('trainMetronomeDuringInterval').checked;
  
  if (trainingConfig.startBpm >= trainingConfig.endBpm) {
    alert("BPM inicial deve ser menor que BPM final!");
    return;
  }
  
  musicDurationMs = calculateMusicDuration(trainingConfig.startBpm);
  
  trainingActive = true;
  trainingPaused = false;
  trainingConfig.currentBpm = trainingConfig.startBpm;
  trainingConfig.currentRepetition = 1;
  trainingConfig.currentCycle = 1;
  
  // Mostrar painel de treino (n√£o minimizado por padr√£o)
  const panel = document.getElementById('trainingPanel');
  panel.classList.add('active');
  panel.classList.remove('minimized');
  document.getElementById('minimizeTrainBtn').textContent = "‚àí";
  
  document.getElementById('trainingModal').style.display = 'none';
  
  updateTrainingUI();
  document.getElementById('trainStatus').textContent = "Iniciando...";
  document.getElementById('miniTrainStatus').textContent = "Iniciando...";
  
  setTimeout(() => {
    if (trainingActive && !trainingPaused) {
      startTrainingCycle();
    }
  }, 500);
}

// Iniciar ciclo de treino
function startTrainingCycle() {
  if (!trainingActive || trainingPaused) return;
  
  // Parar metr√¥nomo de intervalo se estiver tocando
  stopIntervalMetronome();
  
  // Parar qualquer playback em andamento
  if (synthControl && isPlaying) {
    synthControl.stop();
    synthControl = null;
    isPlaying = false;
  }
  stopVisualMetronome();
  
  const totalCycles = Math.ceil((trainingConfig.endBpm - trainingConfig.startBpm) / trainingConfig.increment);
  const currentCycleIndex = Math.floor((trainingConfig.currentBpm - trainingConfig.startBpm) / trainingConfig.increment);
  const progress = Math.round(((currentCycleIndex * trainingConfig.repetitions + trainingConfig.currentRepetition - 1) / 
                              (totalCycles * trainingConfig.repetitions)) * 100);
  
  document.getElementById('currentTrainBpm').textContent = trainingConfig.currentBpm;
  document.getElementById('currentRepetition').textContent = 
    trainingConfig.currentRepetition + '/' + trainingConfig.repetitions;
  document.getElementById('trainProgress').textContent = progress + '%';
  document.getElementById('trainProgressBar').style.width = progress + '%';
  document.getElementById('trainStatus').textContent = "Tocando...";
  
  // Atualizar mini stats
  document.getElementById('miniTrainBpm').textContent = "BPM: " + trainingConfig.currentBpm;
  document.getElementById('miniTrainRep').textContent = "Rep: " + trainingConfig.currentRepetition + '/' + trainingConfig.repetitions;
  document.getElementById('miniTrainStatus').textContent = "Tocando...";
  
  document.getElementById('bpmValue').value = trainingConfig.currentBpm;
  musicDurationMs = calculateMusicDuration(trainingConfig.currentBpm);
  
  // Iniciar playback com o BPM atual
  setTimeout(() => {
    if (trainingActive && !trainingPaused) {
      startPlaybackWithBpm(trainingConfig.currentBpm);
    }
  }, 100);
  
  trainingTimeout = setTimeout(() => {
    if (!trainingActive || trainingPaused) return;
    prepareNextRepetition();
  }, musicDurationMs + 100);
}

// Preparar pr√≥xima repeti√ß√£o (agora com metr√¥nomo durante intervalo)
function prepareNextRepetition() {
  if (!trainingActive || trainingPaused) return;
  
  // Parar playback atual
  if (synthControl && isPlaying) {
    synthControl.stop();
    synthControl = null;
    isPlaying = false;
  }
  stopVisualMetronome();
  
  document.getElementById('trainStatus').textContent = "Intervalo...";
  document.getElementById('miniTrainStatus').textContent = "Intervalo...";
  
  // Iniciar metr√¥nomo durante intervalo se configurado
  if (trainingConfig.metronomeDuringInterval) {
    startIntervalMetronome();
  }
  
  // Agendar pr√≥xima repeti√ß√£o ap√≥s o intervalo configurado
  setTimeout(() => {
    if (!trainingActive || trainingPaused) return;
    
    // Parar metr√¥nomo de intervalo
    stopIntervalMetronome();
    
    // Avan√ßar repeti√ß√£o ou BPM
    if (trainingConfig.currentRepetition < trainingConfig.repetitions) {
      trainingConfig.currentRepetition++;
    } else {
      trainingConfig.currentRepetition = 1;
      trainingConfig.currentBpm += trainingConfig.increment;
      
      // Verificar se terminou
      if (trainingConfig.currentBpm > trainingConfig.endBpm) {
        stopTraining();
        alert("üéâ Treino conclu√≠do!");
        return;
      }
    }
    
    // Iniciar pr√≥ximo ciclo imediatamente ap√≥s o intervalo
    startTrainingCycle();
  }, trainingConfig.interval * 1000);
}

// Iniciar metr√¥nomo durante intervalo
function startIntervalMetronome() {
  if (intervalMetronomeInterval) {
    clearInterval(intervalMetronomeInterval);
  }
  
  const bpm = trainingConfig.currentBpm;
  const msPerBeat = 60000 / bpm;
  let intervalBeat = 0;
  
  // Tocar primeiro beat imediatamente
  playIntervalMetroClick();
  
  intervalMetronomeInterval = setInterval(() => {
    intervalBeat = (intervalBeat + 1) % metroBeatsPerMeasure;
    playIntervalMetroClick();
  }, msPerBeat);
}

// Tocar clique do metr√¥nomo de intervalo
function playIntervalMetroClick() {
  if (!metroAudioContext || !trainingActive) return;
  
  // Usar o mesmo volume do metr√¥nomo principal
  const volume = metroVolume;
  
  // Determinar frequ√™ncia baseado no beat
  let frequency = 600; // Hz mais baixa para intervalo
  let duration = 0.04; // segundos mais curtos
  
  // Tocar som do metr√¥nomo
  if (metroAudioContext) {
    const oscillator = metroAudioContext.createOscillator();
    const gainNode = metroAudioContext.createGain();
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequency, metroAudioContext.currentTime);
    
    // Conectar n√≥s
    oscillator.connect(gainNode);
    gainNode.connect(metroAudioContext.destination);
    
    // Envelope ADSR r√°pido
    const now = metroAudioContext.currentTime;
    gainNode.gain.setValueAtTime(0, now);
    gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.001); // Volume mais baixo
    gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
    
    // Iniciar e parar
    oscillator.start();
    oscillator.stop(now + duration + 0.1);
  }
}

// Parar metr√¥nomo de intervalo
function stopIntervalMetronome() {
  if (intervalMetronomeInterval) {
    clearInterval(intervalMetronomeInterval);
    intervalMetronomeInterval = null;
  }
}

// Pausar/Retomar treino
function toggleTrainingPause() {
  if (!trainingActive) return;
  
  trainingPaused = !trainingPaused;
  
  const pauseBtn = document.querySelector('.btn-pause');
  if (trainingPaused) {
    pauseBtn.textContent = "‚ñ∂ Retomar";
    document.getElementById('trainStatus').textContent = "Pausado";
    document.getElementById('miniTrainStatus').textContent = "Pausado";
    
    if (synthControl && isPlaying) {
      try {
        synthControl.pause();
      } catch (e) {}
    }
    
    // Parar timeout e metr√¥nomo de intervalo
    if (trainingTimeout) {
      clearTimeout(trainingTimeout);
      trainingTimeout = null;
    }
    
    stopIntervalMetronome();
  } else {
    pauseBtn.textContent = "‚è∏ Pausar";
    document.getElementById('trainStatus').textContent = "Retomando...";
    document.getElementById('miniTrainStatus').textContent = "Retomando...";
    
    if (synthControl && isPlaying) {
      try {
        synthControl.play();
      } catch (e) {}
    }
    
    setTimeout(() => {
      if (trainingActive && !trainingPaused) {
        const remainingTime = musicDurationMs - (synthControl ? (synthControl.position() || 0) * musicDurationMs : 0);
        if (remainingTime > 0) {
          trainingTimeout = setTimeout(() => {
            if (trainingActive && !trainingPaused) {
              prepareNextRepetition();
            }
          }, remainingTime);
        } else {
          startTrainingCycle();
        }
      }
    }, 100);
  }
}

// Parar treino
function stopTraining() {
  trainingActive = false;
  trainingPaused = false;
  
  // Limpar timeouts
  if (trainingTimeout) {
    clearTimeout(trainingTimeout);
    trainingTimeout = null;
  }
  
  // Parar metr√¥nomo de intervalo
  stopIntervalMetronome();
  
  // Parar playback atual
  stopPlayback();
  
  // Esconder painel de treino
  document.getElementById('trainingPanel').classList.remove('active');
  
  // Resetar BPM para o valor original
  document.getElementById('bpmValue').value = 100;
  
  // Resetar estado de playback
  isPlaying = false;
  document.getElementById("playBtn").classList.remove("playing"); 
  document.getElementById("playIcon").innerText = "‚ñ∂";
}

// Atualizar UI do treino
function updateTrainingUI() {
  if (!trainingActive) return;
  
  document.getElementById('currentTrainBpm').textContent = trainingConfig.currentBpm;
  document.getElementById('currentRepetition').textContent = 
    trainingConfig.currentRepetition + '/' + trainingConfig.repetitions;
}

// Fun√ß√£o para iniciar playback com BPM espec√≠fico (usada no treino)
async function startPlaybackWithBpm(bpm) {
  if (!trainingActive || trainingPaused) return;
  
  try {
    const btn = document.getElementById("playBtn");
    isPlaying = true; 
    btn.classList.add("playing"); 
    btn.querySelector('#playIcon').innerText = "‚èπ";
    
    if (!audioContext) audioContext = new AudioContext();
    
    const abcText = document.getElementById('abcInput').value;
    const lines = abcText.split('\n');
    
    let qLineFound = false;
    let updatedLines = lines.map(line => {
      if (line.trim().startsWith('Q:')) {
        qLineFound = true;
        const qParts = line.split('=');
        if (qParts.length > 0) {
          return `Q:${qParts[0].split(':')[1].trim()}=${bpm}`;
        }
        return `Q:1/4=${bpm}`;
      }
      return line;
    });
    
    if (!qLineFound) {
      const xIndex = updatedLines.findIndex(l => l.trim().startsWith('X:'));
      if (xIndex !== -1) {
        const tIndex = updatedLines.findIndex((l, idx) => idx > xIndex && l.trim().startsWith('T:'));
        const insertIndex = tIndex !== -1 ? tIndex + 1 : xIndex + 1;
        updatedLines.splice(insertIndex, 0, `Q:1/4=${bpm}`);
      } else {
        updatedLines.splice(1, 0, `Q:1/4=${bpm}`);
      }
    }
    
    const updatedAbcText = updatedLines.join('\n');
    
    // Renderizar visualmente
    visualObj = ABCJS.renderAbc("paper", updatedAbcText, { 
      scale: currentZoom / 100, 
      visualTranspose: currentTranspose, 
      responsive: "resize" 
    })[0];
    
    // Criar controle de s√≠ntese
    synthControl = new ABCJS.synth.CreateSynth();
    await synthControl.init({ 
      visualObj, 
      audioContext, 
      soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/", 
      options: { 
        program: 0, 
        midiTranspose: currentTranspose,
        chordsOff: false,
        qpm: bpm  // Usar o BPM especificado
      } 
    });
    
    await synthControl.prime(); 
    await synthControl.start(); 
    startVisualMetronome();
    
    // Verificar quando a m√∫sica termina
    const checkEndInterval = setInterval(() => {
      if (!trainingActive || !isPlaying || trainingPaused) {
        clearInterval(checkEndInterval);
        return;
      }
      
      try {
        if (synthControl && synthControl.position() >= 0.99) {
          clearInterval(checkEndInterval);
          if (synthControl) {
            synthControl.stop();
            synthControl = null;
          }
          stopVisualMetronome();
          document.getElementById("playBtn").classList.remove("playing"); 
          document.getElementById("playIcon").innerText = "‚ñ∂";
          isPlaying = false;
        }
      } catch (e) {}
    }, 100);
    
  } catch (e) { 
    console.error("Erro ao tocar no treino:", e);
    isPlaying = false; 
    document.getElementById("playBtn").classList.remove("playing"); 
    document.getElementById("playIcon").innerText = "‚ñ∂";
    
    // Tentar continuar mesmo com erro
    if (trainingActive && !trainingPaused) {
      setTimeout(prepareNextRepetition, 100);
    }
  }
}

/* --- AFINADOR (WEB AUDIO) --- */
let oscillator = null, gainNode = null, currentActiveNoteBtn = null;
const freqs = { 'E,,': 82.41, 'A,,': 110.00, 'D,': 146.83, 'G,': 196.00, 'B,': 246.94, 'E': 329.63, 'D': 293.66, 'A': 440.00, 'e': 659.25, 'B': 493.88, 'G': 392.00, 'd': 587.33, 'C': 261.63 };

function openTuner() { 
  document.getElementById('tunerModal').style.display = 'flex';
}

function closeTuner() { 
  stopTunerAudio(); 
  document.getElementById('tunerModal').style.display = 'none'; 
}

function playTunerNote(freqKey, btnElement) {
  if (!audioContext) audioContext = new AudioContext();
  if (currentActiveNoteBtn === btnElement) { stopTunerAudio(); return; }
  stopTunerAudio();
  currentActiveNoteBtn = btnElement; btnElement.classList.add('active');
  oscillator = audioContext.createOscillator(); gainNode = audioContext.createGain();
  oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(freqs[freqKey], audioContext.currentTime);
  const filter = audioContext.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(1000, audioContext.currentTime);
  oscillator.connect(filter); filter.connect(gainNode); gainNode.connect(audioContext.destination);
  gainNode.gain.setValueAtTime(0, audioContext.currentTime); gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
  oscillator.start();
}

function stopTunerAudio() {
  if (oscillator) { 
    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1); 
    const os = oscillator; 
    setTimeout(() => os.stop(), 120); 
    oscillator = null; 
  }
  if (currentActiveNoteBtn) { 
    currentActiveNoteBtn.classList.remove('active'); 
    currentActiveNoteBtn = null; 
  }
}

function showTunerNotes(inst) {
  stopTunerAudio(); 
  const area = document.getElementById('tunerNotesArea'); 
  area.style.display = 'flex'; 
  area.innerHTML = '';
  const instData = {
    violao: { nomes: ['E2','A2','D3','G3','B3','E4'], notas: ['E,,', 'A,,', 'D,', 'G,', 'B,', 'E'] },
    violino: { nomes: ['G3','D4','A4','E5'], notas: ['G,', 'D', 'A', 'e'] },
    cavaquinho: { nomes: ['D4','G4','B4','D5'], notas: ['D', 'G', 'B', 'd'] },
    ukulele: { nomes: ['G4','C4','E4','A4'], notas: ['G', 'C', 'E', 'A'] }
  };
  instData[inst].nomes.forEach((nome, idx) => {
    const btn = document.createElement('button'); 
    btn.className = 'note-btn'; 
    btn.innerText = nome;
    btn.onclick = () => playTunerNote(instData[inst].notas[idx], btn); 
    area.appendChild(btn);
  });
}

/* --- SISTEMA DE REDIMENSIONAMENTO SIMPLIFICADO E FUNCIONAL --- */
function initResizeHandles() {
  const handles = ['sidebarResize', 'editorResize', 'scoreResize'];
  
  handles.forEach(handleId => {
    const handle = document.getElementById(handleId);
    if (!handle) return;
    
    // Adicionar classe para identifica√ß√£o
    handle.dataset.handleId = handleId;
    
    // Evento de mouse
    handle.addEventListener('mousedown', startResize);
    
    // Evento de touch - VERS√ÉO SIMPLIFICADA
    handle.addEventListener('touchstart', function(e) {
      if (e.touches.length === 1) {
        // Converter touch para mouse event
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY,
          bubbles: true,
          cancelable: true
        });
        
        // Disparar o evento de mouse
        this.dispatchEvent(mouseEvent);
        
        // Adicionar classe visual
        this.classList.add('touch-active');
        
        // Ativar overlay
        document.getElementById('resizeOverlay').classList.add('active');
        
        // Prevenir comportamento padr√£o
        e.preventDefault();
      }
    }, { passive: false });
  });
  
  // Adicionar eventos globais
  document.addEventListener('mousemove', handleResize);
  document.addEventListener('mouseup', stopResize);
  
  // Eventos globais de touch
  document.addEventListener('touchmove', function(e) {
    if (isResizing && e.touches.length === 1) {
      // Converter touch para mouse event
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY,
        bubbles: true,
        cancelable: true
      });
      
      // Disparar o evento de mouse
      handleResize(mouseEvent);
      
      // Prevenir comportamento padr√£o
      e.preventDefault();
    }
  }, { passive: false });
  
  document.addEventListener('touchend', function(e) {
    if (isResizing) {
      stopResize();
      
      // Remover classe visual de todos os handles
      document.querySelectorAll('.resize-handle').forEach(h => {
        h.classList.remove('touch-active');
      });
      
      // Desativar overlay
      document.getElementById('resizeOverlay').classList.remove('active');
      
      e.preventDefault();
    }
  }, { passive: false });
  
  updateSizeIndicators();
}

function startResize(e) {
  // S√≥ iniciar se clicou diretamente no handle
  if (!e.target.classList.contains('resize-handle')) return;
  
  e.preventDefault();
  isResizing = true;
  currentResizeHandle = e.target;
  
  const handleId = currentResizeHandle.dataset.handleId || currentResizeHandle.id;
  currentResizeHandle.dataset.handleId = handleId;
  
  startX = e.clientX;
  
  // Determinar largura inicial
  if (handleId === 'sidebarResize') {
    startWidth = sidebarWidth;
  } else if (handleId === 'editorResize') {
    startWidth = editorWidth;
  } else if (handleId === 'scoreResize') {
    const score = document.getElementById('scoreContainer');
    startWidth = score ? score.offsetWidth : 0;
  }
  
  // Adicionar classe visual
  currentResizeHandle.classList.add('resizing');
  
  // Bloquear sele√ß√£o de texto
  document.body.style.userSelect = 'none';
  document.body.style.cursor = 'col-resize';
  
  // Ativar overlay
  document.getElementById('resizeOverlay').classList.add('active');
}

function handleResize(e) {
  if (!isResizing || !currentResizeHandle) return;
  
  e.preventDefault();
  const deltaX = e.clientX - startX;
  const handleId = currentResizeHandle.dataset.handleId || currentResizeHandle.id;
  
  if (handleId === 'sidebarResize') {
    const newWidth = Math.max(200, Math.min(600, startWidth + deltaX));
    sidebarWidth = newWidth;
    document.getElementById('sidebar').style.width = `${sidebarWidth}px`;
    document.getElementById('sidebarSize').textContent = `${sidebarWidth}px`;
    
  } else if (handleId === 'editorResize') {
    const newWidth = Math.max(300, Math.min(800, startWidth + deltaX));
    editorWidth = newWidth;
    document.getElementById('editorContainer').style.width = `${editorWidth}px`;
    document.getElementById('editorSize').textContent = `${editorWidth}px`;
    
  } else if (handleId === 'scoreResize') {
    const targetElement = document.getElementById('scoreContainer');
    if (targetElement) {
      const newWidth = Math.max(400, startWidth + deltaX);
      document.getElementById('scoreSize').textContent = `${Math.round(newWidth)}px`;
    }
  }
  
  // Atualizar renderiza√ß√£o
  if (visualObj) {
    setTimeout(renderScore, 50);
  }
}

function stopResize() {
  if (!isResizing) return;
  
  isResizing = false;
  
  // Remover classes visuais
  if (currentResizeHandle) {
    currentResizeHandle.classList.remove('resizing');
    currentResizeHandle.classList.remove('touch-active');
  }
  
  // Restaurar sele√ß√£o de texto
  document.body.style.userSelect = '';
  document.body.style.cursor = '';
  
  // Desativar overlay
  document.getElementById('resizeOverlay').classList.remove('active');
  
  updateSizeIndicators();
  saveLayoutToStorage();
  currentResizeHandle = null;
}

function updateSizeIndicators() {
  const sidebar = document.getElementById('sidebar');
  if (sidebar && !sidebar.classList.contains('hidden')) {
    sidebarWidth = sidebar.offsetWidth;
    document.getElementById('sidebarSize').textContent = `${sidebarWidth}px`;
  }
  
  const editor = document.getElementById('editorContainer');
  if (editor && !editor.classList.contains('hidden')) {
    editorWidth = editor.offsetWidth;
    document.getElementById('editorSize').textContent = `${editorWidth}px`;
  }
  
  const score = document.getElementById('scoreContainer');
  if (score && !score.classList.contains('hidden')) {
    const scoreWidth = score.offsetWidth;
    document.getElementById('scoreSize').textContent = `${scoreWidth}px`;
  }
}

function saveLayoutToStorage() {
  try {
    const layout = {
      sidebarWidth: sidebarWidth,
      editorWidth: editorWidth,
      sidebarVisible: !document.getElementById('sidebar').classList.contains('hidden'),
      editorVisible: !document.getElementById('editorContainer').classList.contains('hidden'),
      scoreVisible: !document.getElementById('scoreContainer').classList.contains('hidden')
    };
    localStorage.setItem('abcEditorLayout', JSON.stringify(layout));
  } catch (e) {
    console.error('Erro ao salvar layout:', e);
  }
}

function loadLayoutFromStorage() {
  try {
    const saved = localStorage.getItem('abcEditorLayout');
    if (saved) {
      const layout = JSON.parse(saved);
      
      if (layout.sidebarWidth) {
        sidebarWidth = layout.sidebarWidth;
        document.getElementById('sidebar').style.width = `${sidebarWidth}px`;
      }
      
      if (layout.editorWidth) {
        editorWidth = layout.editorWidth;
        document.getElementById('editorContainer').style.width = `${editorWidth}px`;
      }
      
      if (layout.sidebarVisible === false) {
        document.getElementById('sidebar').classList.add('hidden');
      }
      if (layout.editorVisible === false) {
        document.getElementById('editorContainer').classList.add('hidden');
      }
      if (layout.scoreVisible === false) {
        document.getElementById('scoreContainer').classList.add('hidden');
      }
      
      setTimeout(updateSizeIndicators, 100);
      updateLayoutAfterToggle();
    }
  } catch (e) {
    console.error('Erro ao carregar layout:', e);
  }
}

function resetLayout() {
  sidebarWidth = 300;
  editorWidth = 400;
  
  const sidebar = document.getElementById('sidebar');
  const editor = document.getElementById('editorContainer');
  const score = document.getElementById('scoreContainer');
  
  sidebar.style.width = `${sidebarWidth}px`;
  sidebar.style.flex = '';
  sidebar.classList.remove('hidden');
  
  editor.style.width = `${editorWidth}px`;
  editor.style.flex = '';
  editor.classList.remove('hidden');
  
  score.style.flex = '1 1 auto';
  score.classList.remove('hidden');
  
  updateSizeIndicators();
  localStorage.removeItem('abcEditorLayout');
  
  if (visualObj) {
    setTimeout(renderScore, 100);
  }
  
  alert('Layout restaurado para padr√£o!');
}

/* --- FUN√á√ïES TOGGLE MELHORADAS --- */
function toggleSidebar() { 
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.toggle('hidden');
  updateLayoutAfterToggle();
  updateSizeIndicators();
  saveLayoutToStorage();
  setTimeout(renderScore, 350);
}

function toggleEditor() { 
  const editor = document.getElementById('editorContainer');
  editor.classList.toggle('hidden');
  updateLayoutAfterToggle();
  updateSizeIndicators();
  saveLayoutToStorage();
  setTimeout(renderScore, 350);
}

function toggleScore() { 
  const score = document.getElementById('scoreContainer');
  score.classList.toggle('hidden');
  
  if (!score.classList.contains('hidden')) {
    score.style.flex = '1 1 auto';
  }
  
  updateSizeIndicators();
  saveLayoutToStorage();
  setTimeout(renderScore, 350);
}

function updateLayoutAfterToggle() {
  const sidebar = document.getElementById('sidebar');
  const editor = document.getElementById('editorContainer');
  const score = document.getElementById('scoreContainer');
  
  // Resetar todos os estilos flex primeiro
  sidebar.style.flex = '';
  editor.style.flex = '';
  score.style.flex = '';
  
  // Calcular pain√©is vis√≠veis
  const visiblePanels = [sidebar, editor, score].filter(
    panel => !panel.classList.contains('hidden')
  ).length;
  
  if (visiblePanels === 1) {
    // Apenas um painel vis√≠vel
    if (!sidebar.classList.contains('hidden')) {
      sidebar.style.flex = '1 1 100%';
    } else if (!editor.classList.contains('hidden')) {
      editor.style.flex = '1 1 100%';
    } else {
      score.style.flex = '1 1 100%';
    }
  } else if (visiblePanels === 2) {
    // Dois pain√©is vis√≠veis
    if (!sidebar.classList.contains('hidden') && !editor.classList.contains('hidden')) {
      sidebar.style.flex = '0 0 auto';
      editor.style.flex = '0 0 auto';
      score.style.flex = '1 1 auto';
    } else if (!sidebar.classList.contains('hidden') && !score.classList.contains('hidden')) {
      sidebar.style.flex = '0 0 auto';
      score.style.flex = '1 1 auto';
    } else if (!editor.classList.contains('hidden') && !score.classList.contains('hidden')) {
      editor.style.flex = '0 0 auto';
      score.style.flex = '1 1 auto';
    }
  } else {
    // Tr√™s pain√©is vis√≠veis - layout padr√£o
    sidebar.style.flex = '0 0 auto';
    editor.style.flex = '0 0 auto';
    score.style.flex = '1 1 auto';
  }
}

/* --- FUN√á√ïES AUXILIARES PARA DURA√á√ÉO DA M√öSICA --- */
function calculateMusicDuration(bpm) {
  const abcText = document.getElementById('abcInput').value;
  const lines = abcText.split('\n');
  
  let defaultNoteLength = 1/4;
  let meter = "4/4";
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('L:')) {
      const lValue = trimmed.substring(2).trim();
      if (lValue === '1/8') defaultNoteLength = 1/8;
      else if (lValue === '1/16') defaultNoteLength = 1/16;
      else if (lValue === '1/2') defaultNoteLength = 1/2;
      else if (lValue === '1') defaultNoteLength = 1;
    }
    if (trimmed.startsWith('M:')) {
      meter = trimmed.substring(2).trim();
    }
  }
  
  let beatsPerMeasure = 4;
  let beatValue = 4;
  
  if (meter.includes('/')) {
    const parts = meter.split('/');
    const numerator = parseInt(parts[0]) || 4;
    const denominator = parseInt(parts[1]) || 4;
    
    if (denominator === 8 && numerator % 3 === 0) {
      beatsPerMeasure = numerator / 3;
      beatValue = 8;
    } else {
      beatsPerMeasure = numerator;
      beatValue = denominator;
    }
  }
  
  let measureCount = 0;
  let inMusic = false;
  
  for (const line of lines) {
    const trimmed = line.trim();
    
    if (trimmed.startsWith('K:')) {
      inMusic = true;
      continue;
    }
    
    if (inMusic && trimmed && !trimmed.startsWith('%')) {
      const bars = (trimmed.match(/\|/g) || []).length;
      measureCount += bars;
      
      if (!trimmed.includes('|') && trimmed !== '') {
        measureCount += 1;
      }
    }
  }
  
  if (measureCount === 0) {
    const musicLines = lines.filter(l => {
      const trimmed = l.trim();
      return trimmed && !trimmed.startsWith('%') && !trimmed.startsWith('X:') && 
             !trimmed.startsWith('T:') && !trimmed.startsWith('M:') && 
             !trimmed.startsWith('L:') && !trimmed.startsWith('K:') && 
             !trimmed.startsWith('Q:');
    });
    
    if (musicLines.length > 0) {
      measureCount = Math.max(1, musicLines.length);
    } else {
      measureCount = 2;
    }
  }
  
  const totalBeats = measureCount * beatsPerMeasure;
  const msPerBeat = 60000 / bpm;
  const beatRatio = 4 / beatValue;
  
  return Math.ceil(totalBeats * msPerBeat * beatRatio);
}

/* --- PLAY E TRANSPOSE CORRIGIDO --- */
async function togglePlay() {
  // Se o treino est√° ativo, pausar/retomar treino
  if (trainingActive) {
    toggleTrainingPause();
    return;
  }
  
  const btn = document.getElementById("playBtn");
  if (isPlaying) { 
    stopPlayback(); 
    isPlaying = false; 
    return; 
  }
  
  try {
    isPlaying = true; 
    const bpm = parseInt(document.getElementById('bpmValue').value);
    btn.classList.add("playing"); 
    btn.querySelector('#playIcon').innerText = "‚èπ";
    
    if (!audioContext) audioContext = new AudioContext();
    
    const abcText = document.getElementById('abcInput').value;
    const lines = abcText.split('\n');
    
    let qLineFound = false;
    let updatedLines = lines.map(line => {
      if (line.trim().startsWith('Q:')) {
        qLineFound = true;
        const qParts = line.split('=');
        if (qParts.length > 0) {
          return `Q:${qParts[0].split(':')[1].trim()}=${bpm}`;
        }
        return `Q:1/4=${bpm}`;
      }
      return line;
    });
    
    if (!qLineFound) {
      const xIndex = updatedLines.findIndex(l => l.trim().startsWith('X:'));
      if (xIndex !== -1) {
        const tIndex = updatedLines.findIndex((l, idx) => idx > xIndex && l.trim().startsWith('T:'));
        const insertIndex = tIndex !== -1 ? tIndex + 1 : xIndex + 1;
        updatedLines.splice(insertIndex, 0, `Q:1/4=${bpm}`);
      } else {
        updatedLines.splice(1, 0, `Q:1/4=${bpm}`);
      }
    }
    
    visualObj = ABCJS.renderAbc("paper", updatedLines.join('\n'), { 
      scale: currentZoom / 100, 
      visualTranspose: currentTranspose, 
      responsive: "resize" 
    })[0];
    
    synthControl = new ABCJS.synth.CreateSynth();
    await synthControl.init({ 
      visualObj, 
      audioContext, 
      soundFontUrl: "https://paulrosen.github.io/midi-js-soundfonts/FluidR3_GM/", 
      options: { 
        program: 0, 
        midiTranspose: currentTranspose,
        chordsOff: false,
        qpm: bpm
      } 
    });
    
    await synthControl.prime(); 
    await synthControl.start(); 
    startVisualMetronome();
    
    const checkEndInterval = setInterval(() => {
      if (!isPlaying) {
        clearInterval(checkEndInterval);
        return;
      }
      
      try {
        if (synthControl && synthControl.position() >= 0.99) {
          clearInterval(checkEndInterval);
          stopPlayback();
          isPlaying = false;
        }
      } catch (e) {}
    }, 100);
    
  } catch (e) { 
    console.error("Erro ao tocar:", e);
    isPlaying = false; 
  }
}

function stopPlayback() { 
  if (synthControl) { 
    try { 
      synthControl.stop(); 
    } catch (e) {} 
    synthControl = null; 
  } 
  stopVisualMetronome(); 
  document.getElementById("playBtn").classList.remove("playing"); 
  document.getElementById("playIcon").innerText = "‚ñ∂"; 
}

/* --- RENDERIZA√á√ÉO DA PARTITURA --- */
let renderTimeout = null;

function renderScore() { 
  try {
    const abcText = document.getElementById('abcInput').value;
    const escalaDesejada = currentZoom / 100;
    const container = document.getElementById('paper-container');
    
    // CALCULAR LARGURA DISPON√çVEL COM ZOOM
    const availableWidth = container.clientWidth - 20;
    const scaledWidth = availableWidth / escalaDesejada; // ‚Üê AJUSTE CR√çTICO
    
    document.getElementById('paper').innerHTML = "";

    visualObj = ABCJS.renderAbc("paper", abcText, { 
      scale: escalaDesejada,
      visualTranspose: currentTranspose,
      responsive: "resize",
      staffwidth: scaledWidth, // ‚Üê Largura ajustada pelo zoom
      paddingtop: 0,
      paddingbottom: 30,
      paddingright: 0,
      paddingleft: 0,
      add_classes: true
    })[0]; 

  } catch (e) {
    console.error("Erro ao renderizar:", e);
  }
}

function updateScoreWithDebounce() {
  if (renderTimeout) {
    clearTimeout(renderTimeout);
  }
  
  renderTimeout = setTimeout(() => {
    renderScore();
  }, 500);
}

/* --- BIBLIOTECA (GITHUB + LOCAL) --- */
async function carregarArquivosServidor() {
  const status = document.getElementById('libraryStatus');
  for (const url of arquivosNoServidor) {
    try {
      const resp = await fetch(url);
      if (resp.ok) {
        const content = await resp.text();
        fileLibrary.push({ name: url.split('/').pop(), content, handle: null });
      }
    } catch (e) { console.error("Erro ao carregar remoto:", url); }
  }
  status.innerText = "Arquivos carregados.";
  renderLibrary();
}

async function selectFolder() {
  const dirHandle = await window.showDirectoryPicker();
  fileLibrary = fileLibrary.filter(f => f.handle === null);
  for await (const entry of dirHandle.values()) {
    if (entry.name.endsWith('.txt')) {
      const file = await entry.getFile();
      fileLibrary.push({ name: entry.name, content: await file.text(), handle: entry });
    }
  }
  renderLibrary();
}

function renderLibrary() {
  const container = document.getElementById('fileContainerList'); container.innerHTML = '';
  fileLibrary.forEach((file, fIdx) => {
    const fDiv = document.createElement('div'); fDiv.className = 'file-container';
    fDiv.innerHTML = `<div class="file-header" onclick="toggleAccordion(${fIdx})"><span>${file.handle ? 'üìÅ' : 'üåê'} ${file.name}</span></div><div class="music-list" id="list-${fIdx}"></div>`;
    const mList = fDiv.querySelector('.music-list');
    const musics = extractMusics(file.content);
    musics.forEach(m => {
      const mDiv = document.createElement('div'); mDiv.className = 'music-item'; mDiv.innerText = `üéµ ${m.title}`;
      mDiv.onclick = () => { 
        currentFileHandle = file.handle; 
        document.getElementById('abcInput').value = m.content; 
        document.getElementById('musicInfoTag').innerText = "| " + m.title; 
        renderScore();
        stopTraining();
      };
      mList.appendChild(mDiv);
    });
    container.appendChild(fDiv);
  });
}

function extractMusics(content) {
  const musics = []; const lines = content.split('\n'); let current = null;
  lines.forEach(l => {
    if (l.trim().startsWith('X:')) { if (current) musics.push(current); current = { title: "Sem t√≠tulo", content: l + '\n' }; }
    else if (current) { current.content += l + '\n'; if (l.trim().startsWith('T:')) current.title = l.replace('T:', '').trim(); }
  });
  if (current) musics.push(current); return musics;
}

async function salvarArquivoLocal() {
  if (!currentFileHandle) { alert("Arquivos do servidor n√£o podem ser salvos localmente aqui."); return; }
  const writable = await currentFileHandle.createWritable();
  await writable.write(document.getElementById('abcInput').value);
  await writable.close();
  alert("Salvo com sucesso!");
}

/* --- UTILIT√ÅRIOS --- */
function updateBPM() { 
  const bpm = parseInt(document.getElementById('bpmValue').value);
  
  const abcText = document.getElementById('abcInput').value;
  const lines = abcText.split('\n');
  
  let qLineFound = false;
  let updatedLines = lines.map(line => {
    if (line.trim().startsWith('Q:')) {
      qLineFound = true;
      const qParts = line.split('=');
      if (qParts.length > 0) {
        return `Q:${qParts[0].split(':')[1].trim()}=${bpm}`;
      }
      return `Q:1/4=${bpm}`;
    }
    return line;
  });
  
  if (!qLineFound) {
    const xIndex = updatedLines.findIndex(l => l.trim().startsWith('X:'));
    if (xIndex !== -1) {
      const tIndex = updatedLines.findIndex((l, idx) => idx > xIndex && l.trim().startsWith('T:'));
      const insertIndex = tIndex !== -1 ? tIndex + 1 : xIndex + 1;
      updatedLines.splice(insertIndex, 0, `Q:1/4=${bpm}`);
    } else {
      updatedLines.splice(1, 0, `Q:1/4=${bpm}`);
    }
  }
  
  document.getElementById('abcInput').value = updatedLines.join('\n');
  
  if (isPlaying && !trainingActive) { 
    stopPlayback(); 
    setTimeout(togglePlay, 100); 
  } else {
    renderScore(); 
  }
  
  // Sincronizar metr√¥nomo com novo BPM
  syncMetroWithBPM();
}

function changeZoom(n) { 
  currentZoom = Math.max(10, currentZoom + n);
  const label = document.getElementById('zoomLabel');
  if (label) label.textContent = currentZoom + '%'; 
  renderScore(); 
}

function startVisualMetronome() { 
  stopVisualMetronome(); 
  const bpm = parseInt(document.getElementById('bpmValue').value);
  const ms = 60000 / bpm; 
  const dot = document.getElementById('metronomeVisual'); 
  metroInterval = setInterval(() => { 
    dot.classList.add('metronome-active'); 
    setTimeout(() => dot.classList.remove('metronome-active'), 100); 
  }, ms); 
}

function stopVisualMetronome() { 
  if (metroInterval) clearInterval(metroInterval); 
}

function changeTranspose(n) { 
  currentTranspose += n; 
  document.getElementById('transposeLabel').textContent = currentTranspose; 
  renderScore(); 
}

function toggleAccordion(idx) { 
  document.getElementById(`list-${idx}`).classList.toggle('show'); 
}

// Lista de arquivos do servidor
const arquivosNoServidor = [
  'musica/Hino01.txt', 
  'livro/8012 - PDF - Guitarra - 1001 Jazz Licks - Jack Shneidman.txt'
];

window.onload = () => { 
  renderScore(); 
  carregarArquivosServidor(); 
  
  initResizeHandles();
  loadLayoutFromStorage();
  
  const abcInput = document.getElementById('abcInput');
  abcInput.addEventListener('input', updateScoreWithDebounce);
  abcInput.addEventListener('input', onAbcInputChange);
  
  document.getElementById('bpmValue').addEventListener('change', updateBPM);
  document.getElementById('bpmValue').addEventListener('keyup', function(e) {
    if (e.key === 'Enter') {
      updateBPM();
    }
  });
  
  const volumeSlider = document.getElementById('metroVolumeSlider');
  if (volumeSlider) {
    volumeSlider.addEventListener('input', updateMetroVolume);
  }
  
  window.addEventListener('resize', updateSizeIndicators);
  
  updateTimeSignatureDisplay();
  
  // Feedback t√°til para dispositivos touch
  if ('ontouchstart' in window) {
    document.querySelectorAll('.header-btn, .control-group button, .training-btn, .note-btn, .instrument-btn').forEach(btn => {
      btn.addEventListener('touchstart', function() {
        this.style.transform = 'scale(0.98)';
        this.style.transition = 'transform 0.1s';
      });
      
      btn.addEventListener('touchend', function() {
        this.style.transform = 'scale(1)';
      });
    });
  }
};
</script>
</body>
</html>
